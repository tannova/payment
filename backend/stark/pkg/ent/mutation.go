// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"gitlab.com/mcuc/monorepo/backend/stark/pkg/ent/cryptowallet"
	"gitlab.com/mcuc/monorepo/backend/stark/pkg/ent/merchantuserbankaccount"
	"gitlab.com/mcuc/monorepo/backend/stark/pkg/ent/payment"
	"gitlab.com/mcuc/monorepo/backend/stark/pkg/ent/paymentbankingdetail"
	"gitlab.com/mcuc/monorepo/backend/stark/pkg/ent/paymentcryptodetail"
	"gitlab.com/mcuc/monorepo/backend/stark/pkg/ent/paymentewalletdetail"
	"gitlab.com/mcuc/monorepo/backend/stark/pkg/ent/paymenttelcodetail"
	"gitlab.com/mcuc/monorepo/backend/stark/pkg/ent/predicate"
	"gitlab.com/mcuc/monorepo/backend/stark/pkg/ent/revision"
	"gitlab.com/mcuc/monorepo/backend/stark/pkg/ent/setting"
	"gitlab.com/mcuc/monorepo/backend/stark/pkg/ent/systembankaccount"
	"gitlab.com/mcuc/monorepo/backend/stark/pkg/ent/systemcryptohotwallet"
	"gitlab.com/mcuc/monorepo/backend/stark/pkg/ent/systemewallet"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCryptoWallet            = "CryptoWallet"
	TypeMerchantUserBankAccount = "MerchantUserBankAccount"
	TypePayment                 = "Payment"
	TypePaymentBankingDetail    = "PaymentBankingDetail"
	TypePaymentCryptoDetail     = "PaymentCryptoDetail"
	TypePaymentEWalletDetail    = "PaymentEWalletDetail"
	TypePaymentTelcoDetail      = "PaymentTelcoDetail"
	TypeRevision                = "Revision"
	TypeSetting                 = "Setting"
	TypeSystemBankAccount       = "SystemBankAccount"
	TypeSystemCryptoHotWallet   = "SystemCryptoHotWallet"
	TypeSystemEWallet           = "SystemEWallet"
)

// CryptoWalletMutation represents an operation that mutates the CryptoWallet nodes in the graph.
type CryptoWalletMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	merchant_id            *int64
	addmerchant_id         *int64
	merchant_user_id       *int64
	addmerchant_user_id    *int64
	crypto_type            *int32
	addcrypto_type         *int32
	crypto_network_type    *int32
	addcrypto_network_type *int32
	address                *string
	status                 *int32
	addstatus              *int32
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*CryptoWallet, error)
	predicates             []predicate.CryptoWallet
}

var _ ent.Mutation = (*CryptoWalletMutation)(nil)

// cryptowalletOption allows management of the mutation configuration using functional options.
type cryptowalletOption func(*CryptoWalletMutation)

// newCryptoWalletMutation creates new mutation for the CryptoWallet entity.
func newCryptoWalletMutation(c config, op Op, opts ...cryptowalletOption) *CryptoWalletMutation {
	m := &CryptoWalletMutation{
		config:        c,
		op:            op,
		typ:           TypeCryptoWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCryptoWalletID sets the ID field of the mutation.
func withCryptoWalletID(id int64) cryptowalletOption {
	return func(m *CryptoWalletMutation) {
		var (
			err   error
			once  sync.Once
			value *CryptoWallet
		)
		m.oldValue = func(ctx context.Context) (*CryptoWallet, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CryptoWallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCryptoWallet sets the old CryptoWallet of the mutation.
func withCryptoWallet(node *CryptoWallet) cryptowalletOption {
	return func(m *CryptoWalletMutation) {
		m.oldValue = func(context.Context) (*CryptoWallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CryptoWalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CryptoWalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CryptoWallet entities.
func (m *CryptoWalletMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CryptoWalletMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *CryptoWalletMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CryptoWalletMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CryptoWallet entity.
// If the CryptoWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptoWalletMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CryptoWalletMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CryptoWalletMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CryptoWalletMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CryptoWallet entity.
// If the CryptoWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptoWalletMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CryptoWalletMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *CryptoWalletMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CryptoWalletMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CryptoWallet entity.
// If the CryptoWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptoWalletMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CryptoWalletMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *CryptoWalletMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *CryptoWalletMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the CryptoWallet entity.
// If the CryptoWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptoWalletMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *CryptoWalletMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *CryptoWalletMutation) SetMerchantID(i int64) {
	m.merchant_id = &i
	m.addmerchant_id = nil
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *CryptoWalletMutation) MerchantID() (r int64, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the CryptoWallet entity.
// If the CryptoWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptoWalletMutation) OldMerchantID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// AddMerchantID adds i to the "merchant_id" field.
func (m *CryptoWalletMutation) AddMerchantID(i int64) {
	if m.addmerchant_id != nil {
		*m.addmerchant_id += i
	} else {
		m.addmerchant_id = &i
	}
}

// AddedMerchantID returns the value that was added to the "merchant_id" field in this mutation.
func (m *CryptoWalletMutation) AddedMerchantID() (r int64, exists bool) {
	v := m.addmerchant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *CryptoWalletMutation) ResetMerchantID() {
	m.merchant_id = nil
	m.addmerchant_id = nil
}

// SetMerchantUserID sets the "merchant_user_id" field.
func (m *CryptoWalletMutation) SetMerchantUserID(i int64) {
	m.merchant_user_id = &i
	m.addmerchant_user_id = nil
}

// MerchantUserID returns the value of the "merchant_user_id" field in the mutation.
func (m *CryptoWalletMutation) MerchantUserID() (r int64, exists bool) {
	v := m.merchant_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantUserID returns the old "merchant_user_id" field's value of the CryptoWallet entity.
// If the CryptoWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptoWalletMutation) OldMerchantUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantUserID: %w", err)
	}
	return oldValue.MerchantUserID, nil
}

// AddMerchantUserID adds i to the "merchant_user_id" field.
func (m *CryptoWalletMutation) AddMerchantUserID(i int64) {
	if m.addmerchant_user_id != nil {
		*m.addmerchant_user_id += i
	} else {
		m.addmerchant_user_id = &i
	}
}

// AddedMerchantUserID returns the value that was added to the "merchant_user_id" field in this mutation.
func (m *CryptoWalletMutation) AddedMerchantUserID() (r int64, exists bool) {
	v := m.addmerchant_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMerchantUserID resets all changes to the "merchant_user_id" field.
func (m *CryptoWalletMutation) ResetMerchantUserID() {
	m.merchant_user_id = nil
	m.addmerchant_user_id = nil
}

// SetCryptoType sets the "crypto_type" field.
func (m *CryptoWalletMutation) SetCryptoType(i int32) {
	m.crypto_type = &i
	m.addcrypto_type = nil
}

// CryptoType returns the value of the "crypto_type" field in the mutation.
func (m *CryptoWalletMutation) CryptoType() (r int32, exists bool) {
	v := m.crypto_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCryptoType returns the old "crypto_type" field's value of the CryptoWallet entity.
// If the CryptoWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptoWalletMutation) OldCryptoType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCryptoType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCryptoType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCryptoType: %w", err)
	}
	return oldValue.CryptoType, nil
}

// AddCryptoType adds i to the "crypto_type" field.
func (m *CryptoWalletMutation) AddCryptoType(i int32) {
	if m.addcrypto_type != nil {
		*m.addcrypto_type += i
	} else {
		m.addcrypto_type = &i
	}
}

// AddedCryptoType returns the value that was added to the "crypto_type" field in this mutation.
func (m *CryptoWalletMutation) AddedCryptoType() (r int32, exists bool) {
	v := m.addcrypto_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetCryptoType resets all changes to the "crypto_type" field.
func (m *CryptoWalletMutation) ResetCryptoType() {
	m.crypto_type = nil
	m.addcrypto_type = nil
}

// SetCryptoNetworkType sets the "crypto_network_type" field.
func (m *CryptoWalletMutation) SetCryptoNetworkType(i int32) {
	m.crypto_network_type = &i
	m.addcrypto_network_type = nil
}

// CryptoNetworkType returns the value of the "crypto_network_type" field in the mutation.
func (m *CryptoWalletMutation) CryptoNetworkType() (r int32, exists bool) {
	v := m.crypto_network_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCryptoNetworkType returns the old "crypto_network_type" field's value of the CryptoWallet entity.
// If the CryptoWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptoWalletMutation) OldCryptoNetworkType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCryptoNetworkType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCryptoNetworkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCryptoNetworkType: %w", err)
	}
	return oldValue.CryptoNetworkType, nil
}

// AddCryptoNetworkType adds i to the "crypto_network_type" field.
func (m *CryptoWalletMutation) AddCryptoNetworkType(i int32) {
	if m.addcrypto_network_type != nil {
		*m.addcrypto_network_type += i
	} else {
		m.addcrypto_network_type = &i
	}
}

// AddedCryptoNetworkType returns the value that was added to the "crypto_network_type" field in this mutation.
func (m *CryptoWalletMutation) AddedCryptoNetworkType() (r int32, exists bool) {
	v := m.addcrypto_network_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetCryptoNetworkType resets all changes to the "crypto_network_type" field.
func (m *CryptoWalletMutation) ResetCryptoNetworkType() {
	m.crypto_network_type = nil
	m.addcrypto_network_type = nil
}

// SetAddress sets the "address" field.
func (m *CryptoWalletMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *CryptoWalletMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the CryptoWallet entity.
// If the CryptoWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptoWalletMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *CryptoWalletMutation) ResetAddress() {
	m.address = nil
}

// SetStatus sets the "status" field.
func (m *CryptoWalletMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CryptoWalletMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CryptoWallet entity.
// If the CryptoWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptoWalletMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CryptoWalletMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CryptoWalletMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CryptoWalletMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Where appends a list predicates to the CryptoWalletMutation builder.
func (m *CryptoWalletMutation) Where(ps ...predicate.CryptoWallet) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CryptoWalletMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CryptoWallet).
func (m *CryptoWalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CryptoWalletMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, cryptowallet.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cryptowallet.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, cryptowallet.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, cryptowallet.FieldUpdatedBy)
	}
	if m.merchant_id != nil {
		fields = append(fields, cryptowallet.FieldMerchantID)
	}
	if m.merchant_user_id != nil {
		fields = append(fields, cryptowallet.FieldMerchantUserID)
	}
	if m.crypto_type != nil {
		fields = append(fields, cryptowallet.FieldCryptoType)
	}
	if m.crypto_network_type != nil {
		fields = append(fields, cryptowallet.FieldCryptoNetworkType)
	}
	if m.address != nil {
		fields = append(fields, cryptowallet.FieldAddress)
	}
	if m.status != nil {
		fields = append(fields, cryptowallet.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CryptoWalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cryptowallet.FieldCreatedAt:
		return m.CreatedAt()
	case cryptowallet.FieldUpdatedAt:
		return m.UpdatedAt()
	case cryptowallet.FieldCreatedBy:
		return m.CreatedBy()
	case cryptowallet.FieldUpdatedBy:
		return m.UpdatedBy()
	case cryptowallet.FieldMerchantID:
		return m.MerchantID()
	case cryptowallet.FieldMerchantUserID:
		return m.MerchantUserID()
	case cryptowallet.FieldCryptoType:
		return m.CryptoType()
	case cryptowallet.FieldCryptoNetworkType:
		return m.CryptoNetworkType()
	case cryptowallet.FieldAddress:
		return m.Address()
	case cryptowallet.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CryptoWalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cryptowallet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cryptowallet.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cryptowallet.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case cryptowallet.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case cryptowallet.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case cryptowallet.FieldMerchantUserID:
		return m.OldMerchantUserID(ctx)
	case cryptowallet.FieldCryptoType:
		return m.OldCryptoType(ctx)
	case cryptowallet.FieldCryptoNetworkType:
		return m.OldCryptoNetworkType(ctx)
	case cryptowallet.FieldAddress:
		return m.OldAddress(ctx)
	case cryptowallet.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown CryptoWallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CryptoWalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cryptowallet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cryptowallet.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cryptowallet.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case cryptowallet.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case cryptowallet.FieldMerchantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case cryptowallet.FieldMerchantUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantUserID(v)
		return nil
	case cryptowallet.FieldCryptoType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCryptoType(v)
		return nil
	case cryptowallet.FieldCryptoNetworkType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCryptoNetworkType(v)
		return nil
	case cryptowallet.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case cryptowallet.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CryptoWallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CryptoWalletMutation) AddedFields() []string {
	var fields []string
	if m.addmerchant_id != nil {
		fields = append(fields, cryptowallet.FieldMerchantID)
	}
	if m.addmerchant_user_id != nil {
		fields = append(fields, cryptowallet.FieldMerchantUserID)
	}
	if m.addcrypto_type != nil {
		fields = append(fields, cryptowallet.FieldCryptoType)
	}
	if m.addcrypto_network_type != nil {
		fields = append(fields, cryptowallet.FieldCryptoNetworkType)
	}
	if m.addstatus != nil {
		fields = append(fields, cryptowallet.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CryptoWalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cryptowallet.FieldMerchantID:
		return m.AddedMerchantID()
	case cryptowallet.FieldMerchantUserID:
		return m.AddedMerchantUserID()
	case cryptowallet.FieldCryptoType:
		return m.AddedCryptoType()
	case cryptowallet.FieldCryptoNetworkType:
		return m.AddedCryptoNetworkType()
	case cryptowallet.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CryptoWalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cryptowallet.FieldMerchantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMerchantID(v)
		return nil
	case cryptowallet.FieldMerchantUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMerchantUserID(v)
		return nil
	case cryptowallet.FieldCryptoType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCryptoType(v)
		return nil
	case cryptowallet.FieldCryptoNetworkType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCryptoNetworkType(v)
		return nil
	case cryptowallet.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CryptoWallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CryptoWalletMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CryptoWalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CryptoWalletMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CryptoWallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CryptoWalletMutation) ResetField(name string) error {
	switch name {
	case cryptowallet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cryptowallet.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cryptowallet.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case cryptowallet.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case cryptowallet.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case cryptowallet.FieldMerchantUserID:
		m.ResetMerchantUserID()
		return nil
	case cryptowallet.FieldCryptoType:
		m.ResetCryptoType()
		return nil
	case cryptowallet.FieldCryptoNetworkType:
		m.ResetCryptoNetworkType()
		return nil
	case cryptowallet.FieldAddress:
		m.ResetAddress()
		return nil
	case cryptowallet.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown CryptoWallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CryptoWalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CryptoWalletMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CryptoWalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CryptoWalletMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CryptoWalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CryptoWalletMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CryptoWalletMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CryptoWallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CryptoWalletMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CryptoWallet edge %s", name)
}

// MerchantUserBankAccountMutation represents an operation that mutates the MerchantUserBankAccount nodes in the graph.
type MerchantUserBankAccountMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	created_by     *string
	updated_by     *string
	bank_name      *int32
	addbank_name   *int32
	account_number *string
	account_name   *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*MerchantUserBankAccount, error)
	predicates     []predicate.MerchantUserBankAccount
}

var _ ent.Mutation = (*MerchantUserBankAccountMutation)(nil)

// merchantuserbankaccountOption allows management of the mutation configuration using functional options.
type merchantuserbankaccountOption func(*MerchantUserBankAccountMutation)

// newMerchantUserBankAccountMutation creates new mutation for the MerchantUserBankAccount entity.
func newMerchantUserBankAccountMutation(c config, op Op, opts ...merchantuserbankaccountOption) *MerchantUserBankAccountMutation {
	m := &MerchantUserBankAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeMerchantUserBankAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMerchantUserBankAccountID sets the ID field of the mutation.
func withMerchantUserBankAccountID(id int64) merchantuserbankaccountOption {
	return func(m *MerchantUserBankAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *MerchantUserBankAccount
		)
		m.oldValue = func(ctx context.Context) (*MerchantUserBankAccount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MerchantUserBankAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMerchantUserBankAccount sets the old MerchantUserBankAccount of the mutation.
func withMerchantUserBankAccount(node *MerchantUserBankAccount) merchantuserbankaccountOption {
	return func(m *MerchantUserBankAccountMutation) {
		m.oldValue = func(context.Context) (*MerchantUserBankAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MerchantUserBankAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MerchantUserBankAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MerchantUserBankAccount entities.
func (m *MerchantUserBankAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MerchantUserBankAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *MerchantUserBankAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MerchantUserBankAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MerchantUserBankAccount entity.
// If the MerchantUserBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantUserBankAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MerchantUserBankAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MerchantUserBankAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MerchantUserBankAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MerchantUserBankAccount entity.
// If the MerchantUserBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantUserBankAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MerchantUserBankAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *MerchantUserBankAccountMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MerchantUserBankAccountMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MerchantUserBankAccount entity.
// If the MerchantUserBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantUserBankAccountMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MerchantUserBankAccountMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MerchantUserBankAccountMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MerchantUserBankAccountMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MerchantUserBankAccount entity.
// If the MerchantUserBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantUserBankAccountMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MerchantUserBankAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetBankName sets the "bank_name" field.
func (m *MerchantUserBankAccountMutation) SetBankName(i int32) {
	m.bank_name = &i
	m.addbank_name = nil
}

// BankName returns the value of the "bank_name" field in the mutation.
func (m *MerchantUserBankAccountMutation) BankName() (r int32, exists bool) {
	v := m.bank_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBankName returns the old "bank_name" field's value of the MerchantUserBankAccount entity.
// If the MerchantUserBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantUserBankAccountMutation) OldBankName(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBankName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBankName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankName: %w", err)
	}
	return oldValue.BankName, nil
}

// AddBankName adds i to the "bank_name" field.
func (m *MerchantUserBankAccountMutation) AddBankName(i int32) {
	if m.addbank_name != nil {
		*m.addbank_name += i
	} else {
		m.addbank_name = &i
	}
}

// AddedBankName returns the value that was added to the "bank_name" field in this mutation.
func (m *MerchantUserBankAccountMutation) AddedBankName() (r int32, exists bool) {
	v := m.addbank_name
	if v == nil {
		return
	}
	return *v, true
}

// ResetBankName resets all changes to the "bank_name" field.
func (m *MerchantUserBankAccountMutation) ResetBankName() {
	m.bank_name = nil
	m.addbank_name = nil
}

// SetAccountNumber sets the "account_number" field.
func (m *MerchantUserBankAccountMutation) SetAccountNumber(s string) {
	m.account_number = &s
}

// AccountNumber returns the value of the "account_number" field in the mutation.
func (m *MerchantUserBankAccountMutation) AccountNumber() (r string, exists bool) {
	v := m.account_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountNumber returns the old "account_number" field's value of the MerchantUserBankAccount entity.
// If the MerchantUserBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantUserBankAccountMutation) OldAccountNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccountNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccountNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountNumber: %w", err)
	}
	return oldValue.AccountNumber, nil
}

// ResetAccountNumber resets all changes to the "account_number" field.
func (m *MerchantUserBankAccountMutation) ResetAccountNumber() {
	m.account_number = nil
}

// SetAccountName sets the "account_name" field.
func (m *MerchantUserBankAccountMutation) SetAccountName(s string) {
	m.account_name = &s
}

// AccountName returns the value of the "account_name" field in the mutation.
func (m *MerchantUserBankAccountMutation) AccountName() (r string, exists bool) {
	v := m.account_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountName returns the old "account_name" field's value of the MerchantUserBankAccount entity.
// If the MerchantUserBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantUserBankAccountMutation) OldAccountName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccountName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountName: %w", err)
	}
	return oldValue.AccountName, nil
}

// ResetAccountName resets all changes to the "account_name" field.
func (m *MerchantUserBankAccountMutation) ResetAccountName() {
	m.account_name = nil
}

// Where appends a list predicates to the MerchantUserBankAccountMutation builder.
func (m *MerchantUserBankAccountMutation) Where(ps ...predicate.MerchantUserBankAccount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MerchantUserBankAccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MerchantUserBankAccount).
func (m *MerchantUserBankAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MerchantUserBankAccountMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, merchantuserbankaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, merchantuserbankaccount.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, merchantuserbankaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, merchantuserbankaccount.FieldUpdatedBy)
	}
	if m.bank_name != nil {
		fields = append(fields, merchantuserbankaccount.FieldBankName)
	}
	if m.account_number != nil {
		fields = append(fields, merchantuserbankaccount.FieldAccountNumber)
	}
	if m.account_name != nil {
		fields = append(fields, merchantuserbankaccount.FieldAccountName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MerchantUserBankAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case merchantuserbankaccount.FieldCreatedAt:
		return m.CreatedAt()
	case merchantuserbankaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case merchantuserbankaccount.FieldCreatedBy:
		return m.CreatedBy()
	case merchantuserbankaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case merchantuserbankaccount.FieldBankName:
		return m.BankName()
	case merchantuserbankaccount.FieldAccountNumber:
		return m.AccountNumber()
	case merchantuserbankaccount.FieldAccountName:
		return m.AccountName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MerchantUserBankAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case merchantuserbankaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case merchantuserbankaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case merchantuserbankaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case merchantuserbankaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case merchantuserbankaccount.FieldBankName:
		return m.OldBankName(ctx)
	case merchantuserbankaccount.FieldAccountNumber:
		return m.OldAccountNumber(ctx)
	case merchantuserbankaccount.FieldAccountName:
		return m.OldAccountName(ctx)
	}
	return nil, fmt.Errorf("unknown MerchantUserBankAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantUserBankAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case merchantuserbankaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case merchantuserbankaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case merchantuserbankaccount.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case merchantuserbankaccount.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case merchantuserbankaccount.FieldBankName:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankName(v)
		return nil
	case merchantuserbankaccount.FieldAccountNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountNumber(v)
		return nil
	case merchantuserbankaccount.FieldAccountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountName(v)
		return nil
	}
	return fmt.Errorf("unknown MerchantUserBankAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MerchantUserBankAccountMutation) AddedFields() []string {
	var fields []string
	if m.addbank_name != nil {
		fields = append(fields, merchantuserbankaccount.FieldBankName)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MerchantUserBankAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case merchantuserbankaccount.FieldBankName:
		return m.AddedBankName()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantUserBankAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case merchantuserbankaccount.FieldBankName:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBankName(v)
		return nil
	}
	return fmt.Errorf("unknown MerchantUserBankAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MerchantUserBankAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MerchantUserBankAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MerchantUserBankAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MerchantUserBankAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MerchantUserBankAccountMutation) ResetField(name string) error {
	switch name {
	case merchantuserbankaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case merchantuserbankaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case merchantuserbankaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case merchantuserbankaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case merchantuserbankaccount.FieldBankName:
		m.ResetBankName()
		return nil
	case merchantuserbankaccount.FieldAccountNumber:
		m.ResetAccountNumber()
		return nil
	case merchantuserbankaccount.FieldAccountName:
		m.ResetAccountName()
		return nil
	}
	return fmt.Errorf("unknown MerchantUserBankAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MerchantUserBankAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MerchantUserBankAccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MerchantUserBankAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MerchantUserBankAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MerchantUserBankAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MerchantUserBankAccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MerchantUserBankAccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MerchantUserBankAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MerchantUserBankAccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MerchantUserBankAccount edge %s", name)
}

// PaymentMutation represents an operation that mutates the Payment nodes in the graph.
type PaymentMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int64
	created_by                     *string
	created_at                     *time.Time
	updated_by                     *string
	updated_at                     *time.Time
	approved_by                    *string
	approved_at                    *time.Time
	merchant_id                    *int64
	addmerchant_id                 *int64
	merchant_user_id               *int64
	addmerchant_user_id            *int64
	method                         *int32
	addmethod                      *int32
	_type                          *int32
	add_type                       *int32
	status                         *int32
	addstatus                      *int32
	clearedFields                  map[string]struct{}
	payment_banking_detail         map[int64]struct{}
	removedpayment_banking_detail  map[int64]struct{}
	clearedpayment_banking_detail  bool
	payment_telco_detail           map[int64]struct{}
	removedpayment_telco_detail    map[int64]struct{}
	clearedpayment_telco_detail    bool
	payment_e_wallet_detail        map[int64]struct{}
	removedpayment_e_wallet_detail map[int64]struct{}
	clearedpayment_e_wallet_detail bool
	payment_crypto_detail          map[int64]struct{}
	removedpayment_crypto_detail   map[int64]struct{}
	clearedpayment_crypto_detail   bool
	revisions                      map[int64]struct{}
	removedrevisions               map[int64]struct{}
	clearedrevisions               bool
	done                           bool
	oldValue                       func(context.Context) (*Payment, error)
	predicates                     []predicate.Payment
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows management of the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for the Payment entity.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the ID field of the mutation.
func withPaymentID(id int64) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Payment entities.
func (m *PaymentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedBy sets the "created_by" field.
func (m *PaymentMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PaymentMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PaymentMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PaymentMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PaymentMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PaymentMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetApprovedBy sets the "approved_by" field.
func (m *PaymentMutation) SetApprovedBy(s string) {
	m.approved_by = &s
}

// ApprovedBy returns the value of the "approved_by" field in the mutation.
func (m *PaymentMutation) ApprovedBy() (r string, exists bool) {
	v := m.approved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedBy returns the old "approved_by" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldApprovedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApprovedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApprovedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedBy: %w", err)
	}
	return oldValue.ApprovedBy, nil
}

// ClearApprovedBy clears the value of the "approved_by" field.
func (m *PaymentMutation) ClearApprovedBy() {
	m.approved_by = nil
	m.clearedFields[payment.FieldApprovedBy] = struct{}{}
}

// ApprovedByCleared returns if the "approved_by" field was cleared in this mutation.
func (m *PaymentMutation) ApprovedByCleared() bool {
	_, ok := m.clearedFields[payment.FieldApprovedBy]
	return ok
}

// ResetApprovedBy resets all changes to the "approved_by" field.
func (m *PaymentMutation) ResetApprovedBy() {
	m.approved_by = nil
	delete(m.clearedFields, payment.FieldApprovedBy)
}

// SetApprovedAt sets the "approved_at" field.
func (m *PaymentMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *PaymentMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldApprovedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *PaymentMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[payment.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *PaymentMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[payment.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *PaymentMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, payment.FieldApprovedAt)
}

// SetMerchantID sets the "merchant_id" field.
func (m *PaymentMutation) SetMerchantID(i int64) {
	m.merchant_id = &i
	m.addmerchant_id = nil
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *PaymentMutation) MerchantID() (r int64, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldMerchantID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// AddMerchantID adds i to the "merchant_id" field.
func (m *PaymentMutation) AddMerchantID(i int64) {
	if m.addmerchant_id != nil {
		*m.addmerchant_id += i
	} else {
		m.addmerchant_id = &i
	}
}

// AddedMerchantID returns the value that was added to the "merchant_id" field in this mutation.
func (m *PaymentMutation) AddedMerchantID() (r int64, exists bool) {
	v := m.addmerchant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *PaymentMutation) ResetMerchantID() {
	m.merchant_id = nil
	m.addmerchant_id = nil
}

// SetMerchantUserID sets the "merchant_user_id" field.
func (m *PaymentMutation) SetMerchantUserID(i int64) {
	m.merchant_user_id = &i
	m.addmerchant_user_id = nil
}

// MerchantUserID returns the value of the "merchant_user_id" field in the mutation.
func (m *PaymentMutation) MerchantUserID() (r int64, exists bool) {
	v := m.merchant_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantUserID returns the old "merchant_user_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldMerchantUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantUserID: %w", err)
	}
	return oldValue.MerchantUserID, nil
}

// AddMerchantUserID adds i to the "merchant_user_id" field.
func (m *PaymentMutation) AddMerchantUserID(i int64) {
	if m.addmerchant_user_id != nil {
		*m.addmerchant_user_id += i
	} else {
		m.addmerchant_user_id = &i
	}
}

// AddedMerchantUserID returns the value that was added to the "merchant_user_id" field in this mutation.
func (m *PaymentMutation) AddedMerchantUserID() (r int64, exists bool) {
	v := m.addmerchant_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMerchantUserID resets all changes to the "merchant_user_id" field.
func (m *PaymentMutation) ResetMerchantUserID() {
	m.merchant_user_id = nil
	m.addmerchant_user_id = nil
}

// SetMethod sets the "method" field.
func (m *PaymentMutation) SetMethod(i int32) {
	m.method = &i
	m.addmethod = nil
}

// Method returns the value of the "method" field in the mutation.
func (m *PaymentMutation) Method() (r int32, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldMethod(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// AddMethod adds i to the "method" field.
func (m *PaymentMutation) AddMethod(i int32) {
	if m.addmethod != nil {
		*m.addmethod += i
	} else {
		m.addmethod = &i
	}
}

// AddedMethod returns the value that was added to the "method" field in this mutation.
func (m *PaymentMutation) AddedMethod() (r int32, exists bool) {
	v := m.addmethod
	if v == nil {
		return
	}
	return *v, true
}

// ResetMethod resets all changes to the "method" field.
func (m *PaymentMutation) ResetMethod() {
	m.method = nil
	m.addmethod = nil
}

// SetType sets the "type" field.
func (m *PaymentMutation) SetType(i int32) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *PaymentMutation) GetType() (r int32, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *PaymentMutation) AddType(i int32) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *PaymentMutation) AddedType() (r int32, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *PaymentMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetStatus sets the "status" field.
func (m *PaymentMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PaymentMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *PaymentMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PaymentMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *PaymentMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// AddPaymentBankingDetailIDs adds the "payment_banking_detail" edge to the PaymentBankingDetail entity by ids.
func (m *PaymentMutation) AddPaymentBankingDetailIDs(ids ...int64) {
	if m.payment_banking_detail == nil {
		m.payment_banking_detail = make(map[int64]struct{})
	}
	for i := range ids {
		m.payment_banking_detail[ids[i]] = struct{}{}
	}
}

// ClearPaymentBankingDetail clears the "payment_banking_detail" edge to the PaymentBankingDetail entity.
func (m *PaymentMutation) ClearPaymentBankingDetail() {
	m.clearedpayment_banking_detail = true
}

// PaymentBankingDetailCleared reports if the "payment_banking_detail" edge to the PaymentBankingDetail entity was cleared.
func (m *PaymentMutation) PaymentBankingDetailCleared() bool {
	return m.clearedpayment_banking_detail
}

// RemovePaymentBankingDetailIDs removes the "payment_banking_detail" edge to the PaymentBankingDetail entity by IDs.
func (m *PaymentMutation) RemovePaymentBankingDetailIDs(ids ...int64) {
	if m.removedpayment_banking_detail == nil {
		m.removedpayment_banking_detail = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.payment_banking_detail, ids[i])
		m.removedpayment_banking_detail[ids[i]] = struct{}{}
	}
}

// RemovedPaymentBankingDetail returns the removed IDs of the "payment_banking_detail" edge to the PaymentBankingDetail entity.
func (m *PaymentMutation) RemovedPaymentBankingDetailIDs() (ids []int64) {
	for id := range m.removedpayment_banking_detail {
		ids = append(ids, id)
	}
	return
}

// PaymentBankingDetailIDs returns the "payment_banking_detail" edge IDs in the mutation.
func (m *PaymentMutation) PaymentBankingDetailIDs() (ids []int64) {
	for id := range m.payment_banking_detail {
		ids = append(ids, id)
	}
	return
}

// ResetPaymentBankingDetail resets all changes to the "payment_banking_detail" edge.
func (m *PaymentMutation) ResetPaymentBankingDetail() {
	m.payment_banking_detail = nil
	m.clearedpayment_banking_detail = false
	m.removedpayment_banking_detail = nil
}

// AddPaymentTelcoDetailIDs adds the "payment_telco_detail" edge to the PaymentTelcoDetail entity by ids.
func (m *PaymentMutation) AddPaymentTelcoDetailIDs(ids ...int64) {
	if m.payment_telco_detail == nil {
		m.payment_telco_detail = make(map[int64]struct{})
	}
	for i := range ids {
		m.payment_telco_detail[ids[i]] = struct{}{}
	}
}

// ClearPaymentTelcoDetail clears the "payment_telco_detail" edge to the PaymentTelcoDetail entity.
func (m *PaymentMutation) ClearPaymentTelcoDetail() {
	m.clearedpayment_telco_detail = true
}

// PaymentTelcoDetailCleared reports if the "payment_telco_detail" edge to the PaymentTelcoDetail entity was cleared.
func (m *PaymentMutation) PaymentTelcoDetailCleared() bool {
	return m.clearedpayment_telco_detail
}

// RemovePaymentTelcoDetailIDs removes the "payment_telco_detail" edge to the PaymentTelcoDetail entity by IDs.
func (m *PaymentMutation) RemovePaymentTelcoDetailIDs(ids ...int64) {
	if m.removedpayment_telco_detail == nil {
		m.removedpayment_telco_detail = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.payment_telco_detail, ids[i])
		m.removedpayment_telco_detail[ids[i]] = struct{}{}
	}
}

// RemovedPaymentTelcoDetail returns the removed IDs of the "payment_telco_detail" edge to the PaymentTelcoDetail entity.
func (m *PaymentMutation) RemovedPaymentTelcoDetailIDs() (ids []int64) {
	for id := range m.removedpayment_telco_detail {
		ids = append(ids, id)
	}
	return
}

// PaymentTelcoDetailIDs returns the "payment_telco_detail" edge IDs in the mutation.
func (m *PaymentMutation) PaymentTelcoDetailIDs() (ids []int64) {
	for id := range m.payment_telco_detail {
		ids = append(ids, id)
	}
	return
}

// ResetPaymentTelcoDetail resets all changes to the "payment_telco_detail" edge.
func (m *PaymentMutation) ResetPaymentTelcoDetail() {
	m.payment_telco_detail = nil
	m.clearedpayment_telco_detail = false
	m.removedpayment_telco_detail = nil
}

// AddPaymentEWalletDetailIDs adds the "payment_e_wallet_detail" edge to the PaymentEWalletDetail entity by ids.
func (m *PaymentMutation) AddPaymentEWalletDetailIDs(ids ...int64) {
	if m.payment_e_wallet_detail == nil {
		m.payment_e_wallet_detail = make(map[int64]struct{})
	}
	for i := range ids {
		m.payment_e_wallet_detail[ids[i]] = struct{}{}
	}
}

// ClearPaymentEWalletDetail clears the "payment_e_wallet_detail" edge to the PaymentEWalletDetail entity.
func (m *PaymentMutation) ClearPaymentEWalletDetail() {
	m.clearedpayment_e_wallet_detail = true
}

// PaymentEWalletDetailCleared reports if the "payment_e_wallet_detail" edge to the PaymentEWalletDetail entity was cleared.
func (m *PaymentMutation) PaymentEWalletDetailCleared() bool {
	return m.clearedpayment_e_wallet_detail
}

// RemovePaymentEWalletDetailIDs removes the "payment_e_wallet_detail" edge to the PaymentEWalletDetail entity by IDs.
func (m *PaymentMutation) RemovePaymentEWalletDetailIDs(ids ...int64) {
	if m.removedpayment_e_wallet_detail == nil {
		m.removedpayment_e_wallet_detail = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.payment_e_wallet_detail, ids[i])
		m.removedpayment_e_wallet_detail[ids[i]] = struct{}{}
	}
}

// RemovedPaymentEWalletDetail returns the removed IDs of the "payment_e_wallet_detail" edge to the PaymentEWalletDetail entity.
func (m *PaymentMutation) RemovedPaymentEWalletDetailIDs() (ids []int64) {
	for id := range m.removedpayment_e_wallet_detail {
		ids = append(ids, id)
	}
	return
}

// PaymentEWalletDetailIDs returns the "payment_e_wallet_detail" edge IDs in the mutation.
func (m *PaymentMutation) PaymentEWalletDetailIDs() (ids []int64) {
	for id := range m.payment_e_wallet_detail {
		ids = append(ids, id)
	}
	return
}

// ResetPaymentEWalletDetail resets all changes to the "payment_e_wallet_detail" edge.
func (m *PaymentMutation) ResetPaymentEWalletDetail() {
	m.payment_e_wallet_detail = nil
	m.clearedpayment_e_wallet_detail = false
	m.removedpayment_e_wallet_detail = nil
}

// AddPaymentCryptoDetailIDs adds the "payment_crypto_detail" edge to the PaymentCryptoDetail entity by ids.
func (m *PaymentMutation) AddPaymentCryptoDetailIDs(ids ...int64) {
	if m.payment_crypto_detail == nil {
		m.payment_crypto_detail = make(map[int64]struct{})
	}
	for i := range ids {
		m.payment_crypto_detail[ids[i]] = struct{}{}
	}
}

// ClearPaymentCryptoDetail clears the "payment_crypto_detail" edge to the PaymentCryptoDetail entity.
func (m *PaymentMutation) ClearPaymentCryptoDetail() {
	m.clearedpayment_crypto_detail = true
}

// PaymentCryptoDetailCleared reports if the "payment_crypto_detail" edge to the PaymentCryptoDetail entity was cleared.
func (m *PaymentMutation) PaymentCryptoDetailCleared() bool {
	return m.clearedpayment_crypto_detail
}

// RemovePaymentCryptoDetailIDs removes the "payment_crypto_detail" edge to the PaymentCryptoDetail entity by IDs.
func (m *PaymentMutation) RemovePaymentCryptoDetailIDs(ids ...int64) {
	if m.removedpayment_crypto_detail == nil {
		m.removedpayment_crypto_detail = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.payment_crypto_detail, ids[i])
		m.removedpayment_crypto_detail[ids[i]] = struct{}{}
	}
}

// RemovedPaymentCryptoDetail returns the removed IDs of the "payment_crypto_detail" edge to the PaymentCryptoDetail entity.
func (m *PaymentMutation) RemovedPaymentCryptoDetailIDs() (ids []int64) {
	for id := range m.removedpayment_crypto_detail {
		ids = append(ids, id)
	}
	return
}

// PaymentCryptoDetailIDs returns the "payment_crypto_detail" edge IDs in the mutation.
func (m *PaymentMutation) PaymentCryptoDetailIDs() (ids []int64) {
	for id := range m.payment_crypto_detail {
		ids = append(ids, id)
	}
	return
}

// ResetPaymentCryptoDetail resets all changes to the "payment_crypto_detail" edge.
func (m *PaymentMutation) ResetPaymentCryptoDetail() {
	m.payment_crypto_detail = nil
	m.clearedpayment_crypto_detail = false
	m.removedpayment_crypto_detail = nil
}

// AddRevisionIDs adds the "revisions" edge to the Revision entity by ids.
func (m *PaymentMutation) AddRevisionIDs(ids ...int64) {
	if m.revisions == nil {
		m.revisions = make(map[int64]struct{})
	}
	for i := range ids {
		m.revisions[ids[i]] = struct{}{}
	}
}

// ClearRevisions clears the "revisions" edge to the Revision entity.
func (m *PaymentMutation) ClearRevisions() {
	m.clearedrevisions = true
}

// RevisionsCleared reports if the "revisions" edge to the Revision entity was cleared.
func (m *PaymentMutation) RevisionsCleared() bool {
	return m.clearedrevisions
}

// RemoveRevisionIDs removes the "revisions" edge to the Revision entity by IDs.
func (m *PaymentMutation) RemoveRevisionIDs(ids ...int64) {
	if m.removedrevisions == nil {
		m.removedrevisions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.revisions, ids[i])
		m.removedrevisions[ids[i]] = struct{}{}
	}
}

// RemovedRevisions returns the removed IDs of the "revisions" edge to the Revision entity.
func (m *PaymentMutation) RemovedRevisionsIDs() (ids []int64) {
	for id := range m.removedrevisions {
		ids = append(ids, id)
	}
	return
}

// RevisionsIDs returns the "revisions" edge IDs in the mutation.
func (m *PaymentMutation) RevisionsIDs() (ids []int64) {
	for id := range m.revisions {
		ids = append(ids, id)
	}
	return
}

// ResetRevisions resets all changes to the "revisions" edge.
func (m *PaymentMutation) ResetRevisions() {
	m.revisions = nil
	m.clearedrevisions = false
	m.removedrevisions = nil
}

// Where appends a list predicates to the PaymentMutation builder.
func (m *PaymentMutation) Where(ps ...predicate.Payment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_by != nil {
		fields = append(fields, payment.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, payment.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, payment.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, payment.FieldUpdatedAt)
	}
	if m.approved_by != nil {
		fields = append(fields, payment.FieldApprovedBy)
	}
	if m.approved_at != nil {
		fields = append(fields, payment.FieldApprovedAt)
	}
	if m.merchant_id != nil {
		fields = append(fields, payment.FieldMerchantID)
	}
	if m.merchant_user_id != nil {
		fields = append(fields, payment.FieldMerchantUserID)
	}
	if m.method != nil {
		fields = append(fields, payment.FieldMethod)
	}
	if m._type != nil {
		fields = append(fields, payment.FieldType)
	}
	if m.status != nil {
		fields = append(fields, payment.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldCreatedBy:
		return m.CreatedBy()
	case payment.FieldCreatedAt:
		return m.CreatedAt()
	case payment.FieldUpdatedBy:
		return m.UpdatedBy()
	case payment.FieldUpdatedAt:
		return m.UpdatedAt()
	case payment.FieldApprovedBy:
		return m.ApprovedBy()
	case payment.FieldApprovedAt:
		return m.ApprovedAt()
	case payment.FieldMerchantID:
		return m.MerchantID()
	case payment.FieldMerchantUserID:
		return m.MerchantUserID()
	case payment.FieldMethod:
		return m.Method()
	case payment.FieldType:
		return m.GetType()
	case payment.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case payment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case payment.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case payment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case payment.FieldApprovedBy:
		return m.OldApprovedBy(ctx)
	case payment.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case payment.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case payment.FieldMerchantUserID:
		return m.OldMerchantUserID(ctx)
	case payment.FieldMethod:
		return m.OldMethod(ctx)
	case payment.FieldType:
		return m.OldType(ctx)
	case payment.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case payment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case payment.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case payment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case payment.FieldApprovedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedBy(v)
		return nil
	case payment.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case payment.FieldMerchantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case payment.FieldMerchantUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantUserID(v)
		return nil
	case payment.FieldMethod:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case payment.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case payment.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMutation) AddedFields() []string {
	var fields []string
	if m.addmerchant_id != nil {
		fields = append(fields, payment.FieldMerchantID)
	}
	if m.addmerchant_user_id != nil {
		fields = append(fields, payment.FieldMerchantUserID)
	}
	if m.addmethod != nil {
		fields = append(fields, payment.FieldMethod)
	}
	if m.add_type != nil {
		fields = append(fields, payment.FieldType)
	}
	if m.addstatus != nil {
		fields = append(fields, payment.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldMerchantID:
		return m.AddedMerchantID()
	case payment.FieldMerchantUserID:
		return m.AddedMerchantUserID()
	case payment.FieldMethod:
		return m.AddedMethod()
	case payment.FieldType:
		return m.AddedType()
	case payment.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payment.FieldMerchantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMerchantID(v)
		return nil
	case payment.FieldMerchantUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMerchantUserID(v)
		return nil
	case payment.FieldMethod:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMethod(v)
		return nil
	case payment.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case payment.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payment.FieldApprovedBy) {
		fields = append(fields, payment.FieldApprovedBy)
	}
	if m.FieldCleared(payment.FieldApprovedAt) {
		fields = append(fields, payment.FieldApprovedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	switch name {
	case payment.FieldApprovedBy:
		m.ClearApprovedBy()
		return nil
	case payment.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	}
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case payment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case payment.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case payment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case payment.FieldApprovedBy:
		m.ResetApprovedBy()
		return nil
	case payment.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case payment.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case payment.FieldMerchantUserID:
		m.ResetMerchantUserID()
		return nil
	case payment.FieldMethod:
		m.ResetMethod()
		return nil
	case payment.FieldType:
		m.ResetType()
		return nil
	case payment.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.payment_banking_detail != nil {
		edges = append(edges, payment.EdgePaymentBankingDetail)
	}
	if m.payment_telco_detail != nil {
		edges = append(edges, payment.EdgePaymentTelcoDetail)
	}
	if m.payment_e_wallet_detail != nil {
		edges = append(edges, payment.EdgePaymentEWalletDetail)
	}
	if m.payment_crypto_detail != nil {
		edges = append(edges, payment.EdgePaymentCryptoDetail)
	}
	if m.revisions != nil {
		edges = append(edges, payment.EdgeRevisions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgePaymentBankingDetail:
		ids := make([]ent.Value, 0, len(m.payment_banking_detail))
		for id := range m.payment_banking_detail {
			ids = append(ids, id)
		}
		return ids
	case payment.EdgePaymentTelcoDetail:
		ids := make([]ent.Value, 0, len(m.payment_telco_detail))
		for id := range m.payment_telco_detail {
			ids = append(ids, id)
		}
		return ids
	case payment.EdgePaymentEWalletDetail:
		ids := make([]ent.Value, 0, len(m.payment_e_wallet_detail))
		for id := range m.payment_e_wallet_detail {
			ids = append(ids, id)
		}
		return ids
	case payment.EdgePaymentCryptoDetail:
		ids := make([]ent.Value, 0, len(m.payment_crypto_detail))
		for id := range m.payment_crypto_detail {
			ids = append(ids, id)
		}
		return ids
	case payment.EdgeRevisions:
		ids := make([]ent.Value, 0, len(m.revisions))
		for id := range m.revisions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedpayment_banking_detail != nil {
		edges = append(edges, payment.EdgePaymentBankingDetail)
	}
	if m.removedpayment_telco_detail != nil {
		edges = append(edges, payment.EdgePaymentTelcoDetail)
	}
	if m.removedpayment_e_wallet_detail != nil {
		edges = append(edges, payment.EdgePaymentEWalletDetail)
	}
	if m.removedpayment_crypto_detail != nil {
		edges = append(edges, payment.EdgePaymentCryptoDetail)
	}
	if m.removedrevisions != nil {
		edges = append(edges, payment.EdgeRevisions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgePaymentBankingDetail:
		ids := make([]ent.Value, 0, len(m.removedpayment_banking_detail))
		for id := range m.removedpayment_banking_detail {
			ids = append(ids, id)
		}
		return ids
	case payment.EdgePaymentTelcoDetail:
		ids := make([]ent.Value, 0, len(m.removedpayment_telco_detail))
		for id := range m.removedpayment_telco_detail {
			ids = append(ids, id)
		}
		return ids
	case payment.EdgePaymentEWalletDetail:
		ids := make([]ent.Value, 0, len(m.removedpayment_e_wallet_detail))
		for id := range m.removedpayment_e_wallet_detail {
			ids = append(ids, id)
		}
		return ids
	case payment.EdgePaymentCryptoDetail:
		ids := make([]ent.Value, 0, len(m.removedpayment_crypto_detail))
		for id := range m.removedpayment_crypto_detail {
			ids = append(ids, id)
		}
		return ids
	case payment.EdgeRevisions:
		ids := make([]ent.Value, 0, len(m.removedrevisions))
		for id := range m.removedrevisions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedpayment_banking_detail {
		edges = append(edges, payment.EdgePaymentBankingDetail)
	}
	if m.clearedpayment_telco_detail {
		edges = append(edges, payment.EdgePaymentTelcoDetail)
	}
	if m.clearedpayment_e_wallet_detail {
		edges = append(edges, payment.EdgePaymentEWalletDetail)
	}
	if m.clearedpayment_crypto_detail {
		edges = append(edges, payment.EdgePaymentCryptoDetail)
	}
	if m.clearedrevisions {
		edges = append(edges, payment.EdgeRevisions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	switch name {
	case payment.EdgePaymentBankingDetail:
		return m.clearedpayment_banking_detail
	case payment.EdgePaymentTelcoDetail:
		return m.clearedpayment_telco_detail
	case payment.EdgePaymentEWalletDetail:
		return m.clearedpayment_e_wallet_detail
	case payment.EdgePaymentCryptoDetail:
		return m.clearedpayment_crypto_detail
	case payment.EdgeRevisions:
		return m.clearedrevisions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	switch name {
	case payment.EdgePaymentBankingDetail:
		m.ResetPaymentBankingDetail()
		return nil
	case payment.EdgePaymentTelcoDetail:
		m.ResetPaymentTelcoDetail()
		return nil
	case payment.EdgePaymentEWalletDetail:
		m.ResetPaymentEWalletDetail()
		return nil
	case payment.EdgePaymentCryptoDetail:
		m.ResetPaymentCryptoDetail()
		return nil
	case payment.EdgeRevisions:
		m.ResetRevisions()
		return nil
	}
	return fmt.Errorf("unknown Payment edge %s", name)
}

// PaymentBankingDetailMutation represents an operation that mutates the PaymentBankingDetail nodes in the graph.
type PaymentBankingDetailMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int64
	created_at                   *time.Time
	updated_at                   *time.Time
	created_by                   *string
	updated_by                   *string
	payment_code                 *string
	merchant_user_id             *int64
	addmerchant_user_id          *int64
	merchant_user_bank_name      *int32
	addmerchant_user_bank_name   *int32
	merchant_user_account_number *string
	merchant_user_account_name   *string
	system_account_bank_name     *int32
	addsystem_account_bank_name  *int32
	system_account_number        *string
	system_account_name          *string
	image_url                    *string
	tx_id                        *string
	amount                       *uint64
	addamount                    *uint64
	fee                          *uint64
	addfee                       *uint64
	clearedFields                map[string]struct{}
	payment                      *int64
	clearedpayment               bool
	done                         bool
	oldValue                     func(context.Context) (*PaymentBankingDetail, error)
	predicates                   []predicate.PaymentBankingDetail
}

var _ ent.Mutation = (*PaymentBankingDetailMutation)(nil)

// paymentbankingdetailOption allows management of the mutation configuration using functional options.
type paymentbankingdetailOption func(*PaymentBankingDetailMutation)

// newPaymentBankingDetailMutation creates new mutation for the PaymentBankingDetail entity.
func newPaymentBankingDetailMutation(c config, op Op, opts ...paymentbankingdetailOption) *PaymentBankingDetailMutation {
	m := &PaymentBankingDetailMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentBankingDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentBankingDetailID sets the ID field of the mutation.
func withPaymentBankingDetailID(id int64) paymentbankingdetailOption {
	return func(m *PaymentBankingDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentBankingDetail
		)
		m.oldValue = func(ctx context.Context) (*PaymentBankingDetail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentBankingDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentBankingDetail sets the old PaymentBankingDetail of the mutation.
func withPaymentBankingDetail(node *PaymentBankingDetail) paymentbankingdetailOption {
	return func(m *PaymentBankingDetailMutation) {
		m.oldValue = func(context.Context) (*PaymentBankingDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentBankingDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentBankingDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentBankingDetail entities.
func (m *PaymentBankingDetailMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentBankingDetailMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentBankingDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentBankingDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentBankingDetail entity.
// If the PaymentBankingDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentBankingDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentBankingDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentBankingDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentBankingDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PaymentBankingDetail entity.
// If the PaymentBankingDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentBankingDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentBankingDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PaymentBankingDetailMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PaymentBankingDetailMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PaymentBankingDetail entity.
// If the PaymentBankingDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentBankingDetailMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PaymentBankingDetailMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PaymentBankingDetailMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PaymentBankingDetailMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PaymentBankingDetail entity.
// If the PaymentBankingDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentBankingDetailMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PaymentBankingDetailMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetPaymentCode sets the "payment_code" field.
func (m *PaymentBankingDetailMutation) SetPaymentCode(s string) {
	m.payment_code = &s
}

// PaymentCode returns the value of the "payment_code" field in the mutation.
func (m *PaymentBankingDetailMutation) PaymentCode() (r string, exists bool) {
	v := m.payment_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentCode returns the old "payment_code" field's value of the PaymentBankingDetail entity.
// If the PaymentBankingDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentBankingDetailMutation) OldPaymentCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentCode: %w", err)
	}
	return oldValue.PaymentCode, nil
}

// ClearPaymentCode clears the value of the "payment_code" field.
func (m *PaymentBankingDetailMutation) ClearPaymentCode() {
	m.payment_code = nil
	m.clearedFields[paymentbankingdetail.FieldPaymentCode] = struct{}{}
}

// PaymentCodeCleared returns if the "payment_code" field was cleared in this mutation.
func (m *PaymentBankingDetailMutation) PaymentCodeCleared() bool {
	_, ok := m.clearedFields[paymentbankingdetail.FieldPaymentCode]
	return ok
}

// ResetPaymentCode resets all changes to the "payment_code" field.
func (m *PaymentBankingDetailMutation) ResetPaymentCode() {
	m.payment_code = nil
	delete(m.clearedFields, paymentbankingdetail.FieldPaymentCode)
}

// SetMerchantUserID sets the "merchant_user_id" field.
func (m *PaymentBankingDetailMutation) SetMerchantUserID(i int64) {
	m.merchant_user_id = &i
	m.addmerchant_user_id = nil
}

// MerchantUserID returns the value of the "merchant_user_id" field in the mutation.
func (m *PaymentBankingDetailMutation) MerchantUserID() (r int64, exists bool) {
	v := m.merchant_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantUserID returns the old "merchant_user_id" field's value of the PaymentBankingDetail entity.
// If the PaymentBankingDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentBankingDetailMutation) OldMerchantUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantUserID: %w", err)
	}
	return oldValue.MerchantUserID, nil
}

// AddMerchantUserID adds i to the "merchant_user_id" field.
func (m *PaymentBankingDetailMutation) AddMerchantUserID(i int64) {
	if m.addmerchant_user_id != nil {
		*m.addmerchant_user_id += i
	} else {
		m.addmerchant_user_id = &i
	}
}

// AddedMerchantUserID returns the value that was added to the "merchant_user_id" field in this mutation.
func (m *PaymentBankingDetailMutation) AddedMerchantUserID() (r int64, exists bool) {
	v := m.addmerchant_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMerchantUserID clears the value of the "merchant_user_id" field.
func (m *PaymentBankingDetailMutation) ClearMerchantUserID() {
	m.merchant_user_id = nil
	m.addmerchant_user_id = nil
	m.clearedFields[paymentbankingdetail.FieldMerchantUserID] = struct{}{}
}

// MerchantUserIDCleared returns if the "merchant_user_id" field was cleared in this mutation.
func (m *PaymentBankingDetailMutation) MerchantUserIDCleared() bool {
	_, ok := m.clearedFields[paymentbankingdetail.FieldMerchantUserID]
	return ok
}

// ResetMerchantUserID resets all changes to the "merchant_user_id" field.
func (m *PaymentBankingDetailMutation) ResetMerchantUserID() {
	m.merchant_user_id = nil
	m.addmerchant_user_id = nil
	delete(m.clearedFields, paymentbankingdetail.FieldMerchantUserID)
}

// SetMerchantUserBankName sets the "merchant_user_bank_name" field.
func (m *PaymentBankingDetailMutation) SetMerchantUserBankName(i int32) {
	m.merchant_user_bank_name = &i
	m.addmerchant_user_bank_name = nil
}

// MerchantUserBankName returns the value of the "merchant_user_bank_name" field in the mutation.
func (m *PaymentBankingDetailMutation) MerchantUserBankName() (r int32, exists bool) {
	v := m.merchant_user_bank_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantUserBankName returns the old "merchant_user_bank_name" field's value of the PaymentBankingDetail entity.
// If the PaymentBankingDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentBankingDetailMutation) OldMerchantUserBankName(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantUserBankName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantUserBankName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantUserBankName: %w", err)
	}
	return oldValue.MerchantUserBankName, nil
}

// AddMerchantUserBankName adds i to the "merchant_user_bank_name" field.
func (m *PaymentBankingDetailMutation) AddMerchantUserBankName(i int32) {
	if m.addmerchant_user_bank_name != nil {
		*m.addmerchant_user_bank_name += i
	} else {
		m.addmerchant_user_bank_name = &i
	}
}

// AddedMerchantUserBankName returns the value that was added to the "merchant_user_bank_name" field in this mutation.
func (m *PaymentBankingDetailMutation) AddedMerchantUserBankName() (r int32, exists bool) {
	v := m.addmerchant_user_bank_name
	if v == nil {
		return
	}
	return *v, true
}

// ClearMerchantUserBankName clears the value of the "merchant_user_bank_name" field.
func (m *PaymentBankingDetailMutation) ClearMerchantUserBankName() {
	m.merchant_user_bank_name = nil
	m.addmerchant_user_bank_name = nil
	m.clearedFields[paymentbankingdetail.FieldMerchantUserBankName] = struct{}{}
}

// MerchantUserBankNameCleared returns if the "merchant_user_bank_name" field was cleared in this mutation.
func (m *PaymentBankingDetailMutation) MerchantUserBankNameCleared() bool {
	_, ok := m.clearedFields[paymentbankingdetail.FieldMerchantUserBankName]
	return ok
}

// ResetMerchantUserBankName resets all changes to the "merchant_user_bank_name" field.
func (m *PaymentBankingDetailMutation) ResetMerchantUserBankName() {
	m.merchant_user_bank_name = nil
	m.addmerchant_user_bank_name = nil
	delete(m.clearedFields, paymentbankingdetail.FieldMerchantUserBankName)
}

// SetMerchantUserAccountNumber sets the "merchant_user_account_number" field.
func (m *PaymentBankingDetailMutation) SetMerchantUserAccountNumber(s string) {
	m.merchant_user_account_number = &s
}

// MerchantUserAccountNumber returns the value of the "merchant_user_account_number" field in the mutation.
func (m *PaymentBankingDetailMutation) MerchantUserAccountNumber() (r string, exists bool) {
	v := m.merchant_user_account_number
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantUserAccountNumber returns the old "merchant_user_account_number" field's value of the PaymentBankingDetail entity.
// If the PaymentBankingDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentBankingDetailMutation) OldMerchantUserAccountNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantUserAccountNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantUserAccountNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantUserAccountNumber: %w", err)
	}
	return oldValue.MerchantUserAccountNumber, nil
}

// ClearMerchantUserAccountNumber clears the value of the "merchant_user_account_number" field.
func (m *PaymentBankingDetailMutation) ClearMerchantUserAccountNumber() {
	m.merchant_user_account_number = nil
	m.clearedFields[paymentbankingdetail.FieldMerchantUserAccountNumber] = struct{}{}
}

// MerchantUserAccountNumberCleared returns if the "merchant_user_account_number" field was cleared in this mutation.
func (m *PaymentBankingDetailMutation) MerchantUserAccountNumberCleared() bool {
	_, ok := m.clearedFields[paymentbankingdetail.FieldMerchantUserAccountNumber]
	return ok
}

// ResetMerchantUserAccountNumber resets all changes to the "merchant_user_account_number" field.
func (m *PaymentBankingDetailMutation) ResetMerchantUserAccountNumber() {
	m.merchant_user_account_number = nil
	delete(m.clearedFields, paymentbankingdetail.FieldMerchantUserAccountNumber)
}

// SetMerchantUserAccountName sets the "merchant_user_account_name" field.
func (m *PaymentBankingDetailMutation) SetMerchantUserAccountName(s string) {
	m.merchant_user_account_name = &s
}

// MerchantUserAccountName returns the value of the "merchant_user_account_name" field in the mutation.
func (m *PaymentBankingDetailMutation) MerchantUserAccountName() (r string, exists bool) {
	v := m.merchant_user_account_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantUserAccountName returns the old "merchant_user_account_name" field's value of the PaymentBankingDetail entity.
// If the PaymentBankingDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentBankingDetailMutation) OldMerchantUserAccountName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantUserAccountName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantUserAccountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantUserAccountName: %w", err)
	}
	return oldValue.MerchantUserAccountName, nil
}

// ClearMerchantUserAccountName clears the value of the "merchant_user_account_name" field.
func (m *PaymentBankingDetailMutation) ClearMerchantUserAccountName() {
	m.merchant_user_account_name = nil
	m.clearedFields[paymentbankingdetail.FieldMerchantUserAccountName] = struct{}{}
}

// MerchantUserAccountNameCleared returns if the "merchant_user_account_name" field was cleared in this mutation.
func (m *PaymentBankingDetailMutation) MerchantUserAccountNameCleared() bool {
	_, ok := m.clearedFields[paymentbankingdetail.FieldMerchantUserAccountName]
	return ok
}

// ResetMerchantUserAccountName resets all changes to the "merchant_user_account_name" field.
func (m *PaymentBankingDetailMutation) ResetMerchantUserAccountName() {
	m.merchant_user_account_name = nil
	delete(m.clearedFields, paymentbankingdetail.FieldMerchantUserAccountName)
}

// SetSystemAccountBankName sets the "system_account_bank_name" field.
func (m *PaymentBankingDetailMutation) SetSystemAccountBankName(i int32) {
	m.system_account_bank_name = &i
	m.addsystem_account_bank_name = nil
}

// SystemAccountBankName returns the value of the "system_account_bank_name" field in the mutation.
func (m *PaymentBankingDetailMutation) SystemAccountBankName() (r int32, exists bool) {
	v := m.system_account_bank_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemAccountBankName returns the old "system_account_bank_name" field's value of the PaymentBankingDetail entity.
// If the PaymentBankingDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentBankingDetailMutation) OldSystemAccountBankName(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSystemAccountBankName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSystemAccountBankName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemAccountBankName: %w", err)
	}
	return oldValue.SystemAccountBankName, nil
}

// AddSystemAccountBankName adds i to the "system_account_bank_name" field.
func (m *PaymentBankingDetailMutation) AddSystemAccountBankName(i int32) {
	if m.addsystem_account_bank_name != nil {
		*m.addsystem_account_bank_name += i
	} else {
		m.addsystem_account_bank_name = &i
	}
}

// AddedSystemAccountBankName returns the value that was added to the "system_account_bank_name" field in this mutation.
func (m *PaymentBankingDetailMutation) AddedSystemAccountBankName() (r int32, exists bool) {
	v := m.addsystem_account_bank_name
	if v == nil {
		return
	}
	return *v, true
}

// ClearSystemAccountBankName clears the value of the "system_account_bank_name" field.
func (m *PaymentBankingDetailMutation) ClearSystemAccountBankName() {
	m.system_account_bank_name = nil
	m.addsystem_account_bank_name = nil
	m.clearedFields[paymentbankingdetail.FieldSystemAccountBankName] = struct{}{}
}

// SystemAccountBankNameCleared returns if the "system_account_bank_name" field was cleared in this mutation.
func (m *PaymentBankingDetailMutation) SystemAccountBankNameCleared() bool {
	_, ok := m.clearedFields[paymentbankingdetail.FieldSystemAccountBankName]
	return ok
}

// ResetSystemAccountBankName resets all changes to the "system_account_bank_name" field.
func (m *PaymentBankingDetailMutation) ResetSystemAccountBankName() {
	m.system_account_bank_name = nil
	m.addsystem_account_bank_name = nil
	delete(m.clearedFields, paymentbankingdetail.FieldSystemAccountBankName)
}

// SetSystemAccountNumber sets the "system_account_number" field.
func (m *PaymentBankingDetailMutation) SetSystemAccountNumber(s string) {
	m.system_account_number = &s
}

// SystemAccountNumber returns the value of the "system_account_number" field in the mutation.
func (m *PaymentBankingDetailMutation) SystemAccountNumber() (r string, exists bool) {
	v := m.system_account_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemAccountNumber returns the old "system_account_number" field's value of the PaymentBankingDetail entity.
// If the PaymentBankingDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentBankingDetailMutation) OldSystemAccountNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSystemAccountNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSystemAccountNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemAccountNumber: %w", err)
	}
	return oldValue.SystemAccountNumber, nil
}

// ClearSystemAccountNumber clears the value of the "system_account_number" field.
func (m *PaymentBankingDetailMutation) ClearSystemAccountNumber() {
	m.system_account_number = nil
	m.clearedFields[paymentbankingdetail.FieldSystemAccountNumber] = struct{}{}
}

// SystemAccountNumberCleared returns if the "system_account_number" field was cleared in this mutation.
func (m *PaymentBankingDetailMutation) SystemAccountNumberCleared() bool {
	_, ok := m.clearedFields[paymentbankingdetail.FieldSystemAccountNumber]
	return ok
}

// ResetSystemAccountNumber resets all changes to the "system_account_number" field.
func (m *PaymentBankingDetailMutation) ResetSystemAccountNumber() {
	m.system_account_number = nil
	delete(m.clearedFields, paymentbankingdetail.FieldSystemAccountNumber)
}

// SetSystemAccountName sets the "system_account_name" field.
func (m *PaymentBankingDetailMutation) SetSystemAccountName(s string) {
	m.system_account_name = &s
}

// SystemAccountName returns the value of the "system_account_name" field in the mutation.
func (m *PaymentBankingDetailMutation) SystemAccountName() (r string, exists bool) {
	v := m.system_account_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemAccountName returns the old "system_account_name" field's value of the PaymentBankingDetail entity.
// If the PaymentBankingDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentBankingDetailMutation) OldSystemAccountName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSystemAccountName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSystemAccountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemAccountName: %w", err)
	}
	return oldValue.SystemAccountName, nil
}

// ClearSystemAccountName clears the value of the "system_account_name" field.
func (m *PaymentBankingDetailMutation) ClearSystemAccountName() {
	m.system_account_name = nil
	m.clearedFields[paymentbankingdetail.FieldSystemAccountName] = struct{}{}
}

// SystemAccountNameCleared returns if the "system_account_name" field was cleared in this mutation.
func (m *PaymentBankingDetailMutation) SystemAccountNameCleared() bool {
	_, ok := m.clearedFields[paymentbankingdetail.FieldSystemAccountName]
	return ok
}

// ResetSystemAccountName resets all changes to the "system_account_name" field.
func (m *PaymentBankingDetailMutation) ResetSystemAccountName() {
	m.system_account_name = nil
	delete(m.clearedFields, paymentbankingdetail.FieldSystemAccountName)
}

// SetImageURL sets the "image_url" field.
func (m *PaymentBankingDetailMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *PaymentBankingDetailMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the PaymentBankingDetail entity.
// If the PaymentBankingDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentBankingDetailMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *PaymentBankingDetailMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[paymentbankingdetail.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *PaymentBankingDetailMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[paymentbankingdetail.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *PaymentBankingDetailMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, paymentbankingdetail.FieldImageURL)
}

// SetTxID sets the "tx_id" field.
func (m *PaymentBankingDetailMutation) SetTxID(s string) {
	m.tx_id = &s
}

// TxID returns the value of the "tx_id" field in the mutation.
func (m *PaymentBankingDetailMutation) TxID() (r string, exists bool) {
	v := m.tx_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTxID returns the old "tx_id" field's value of the PaymentBankingDetail entity.
// If the PaymentBankingDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentBankingDetailMutation) OldTxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxID: %w", err)
	}
	return oldValue.TxID, nil
}

// ClearTxID clears the value of the "tx_id" field.
func (m *PaymentBankingDetailMutation) ClearTxID() {
	m.tx_id = nil
	m.clearedFields[paymentbankingdetail.FieldTxID] = struct{}{}
}

// TxIDCleared returns if the "tx_id" field was cleared in this mutation.
func (m *PaymentBankingDetailMutation) TxIDCleared() bool {
	_, ok := m.clearedFields[paymentbankingdetail.FieldTxID]
	return ok
}

// ResetTxID resets all changes to the "tx_id" field.
func (m *PaymentBankingDetailMutation) ResetTxID() {
	m.tx_id = nil
	delete(m.clearedFields, paymentbankingdetail.FieldTxID)
}

// SetAmount sets the "amount" field.
func (m *PaymentBankingDetailMutation) SetAmount(u uint64) {
	m.amount = &u
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentBankingDetailMutation) Amount() (r uint64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the PaymentBankingDetail entity.
// If the PaymentBankingDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentBankingDetailMutation) OldAmount(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds u to the "amount" field.
func (m *PaymentBankingDetailMutation) AddAmount(u uint64) {
	if m.addamount != nil {
		*m.addamount += u
	} else {
		m.addamount = &u
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentBankingDetailMutation) AddedAmount() (r uint64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *PaymentBankingDetailMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[paymentbankingdetail.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *PaymentBankingDetailMutation) AmountCleared() bool {
	_, ok := m.clearedFields[paymentbankingdetail.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentBankingDetailMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, paymentbankingdetail.FieldAmount)
}

// SetFee sets the "fee" field.
func (m *PaymentBankingDetailMutation) SetFee(u uint64) {
	m.fee = &u
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *PaymentBankingDetailMutation) Fee() (r uint64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the PaymentBankingDetail entity.
// If the PaymentBankingDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentBankingDetailMutation) OldFee(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds u to the "fee" field.
func (m *PaymentBankingDetailMutation) AddFee(u uint64) {
	if m.addfee != nil {
		*m.addfee += u
	} else {
		m.addfee = &u
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *PaymentBankingDetailMutation) AddedFee() (r uint64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *PaymentBankingDetailMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[paymentbankingdetail.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *PaymentBankingDetailMutation) FeeCleared() bool {
	_, ok := m.clearedFields[paymentbankingdetail.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *PaymentBankingDetailMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, paymentbankingdetail.FieldFee)
}

// SetPaymentID sets the "payment" edge to the Payment entity by id.
func (m *PaymentBankingDetailMutation) SetPaymentID(id int64) {
	m.payment = &id
}

// ClearPayment clears the "payment" edge to the Payment entity.
func (m *PaymentBankingDetailMutation) ClearPayment() {
	m.clearedpayment = true
}

// PaymentCleared reports if the "payment" edge to the Payment entity was cleared.
func (m *PaymentBankingDetailMutation) PaymentCleared() bool {
	return m.clearedpayment
}

// PaymentID returns the "payment" edge ID in the mutation.
func (m *PaymentBankingDetailMutation) PaymentID() (id int64, exists bool) {
	if m.payment != nil {
		return *m.payment, true
	}
	return
}

// PaymentIDs returns the "payment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentID instead. It exists only for internal usage by the builders.
func (m *PaymentBankingDetailMutation) PaymentIDs() (ids []int64) {
	if id := m.payment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPayment resets all changes to the "payment" edge.
func (m *PaymentBankingDetailMutation) ResetPayment() {
	m.payment = nil
	m.clearedpayment = false
}

// Where appends a list predicates to the PaymentBankingDetailMutation builder.
func (m *PaymentBankingDetailMutation) Where(ps ...predicate.PaymentBankingDetail) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PaymentBankingDetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PaymentBankingDetail).
func (m *PaymentBankingDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentBankingDetailMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, paymentbankingdetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, paymentbankingdetail.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, paymentbankingdetail.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, paymentbankingdetail.FieldUpdatedBy)
	}
	if m.payment_code != nil {
		fields = append(fields, paymentbankingdetail.FieldPaymentCode)
	}
	if m.merchant_user_id != nil {
		fields = append(fields, paymentbankingdetail.FieldMerchantUserID)
	}
	if m.merchant_user_bank_name != nil {
		fields = append(fields, paymentbankingdetail.FieldMerchantUserBankName)
	}
	if m.merchant_user_account_number != nil {
		fields = append(fields, paymentbankingdetail.FieldMerchantUserAccountNumber)
	}
	if m.merchant_user_account_name != nil {
		fields = append(fields, paymentbankingdetail.FieldMerchantUserAccountName)
	}
	if m.system_account_bank_name != nil {
		fields = append(fields, paymentbankingdetail.FieldSystemAccountBankName)
	}
	if m.system_account_number != nil {
		fields = append(fields, paymentbankingdetail.FieldSystemAccountNumber)
	}
	if m.system_account_name != nil {
		fields = append(fields, paymentbankingdetail.FieldSystemAccountName)
	}
	if m.image_url != nil {
		fields = append(fields, paymentbankingdetail.FieldImageURL)
	}
	if m.tx_id != nil {
		fields = append(fields, paymentbankingdetail.FieldTxID)
	}
	if m.amount != nil {
		fields = append(fields, paymentbankingdetail.FieldAmount)
	}
	if m.fee != nil {
		fields = append(fields, paymentbankingdetail.FieldFee)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentBankingDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentbankingdetail.FieldCreatedAt:
		return m.CreatedAt()
	case paymentbankingdetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case paymentbankingdetail.FieldCreatedBy:
		return m.CreatedBy()
	case paymentbankingdetail.FieldUpdatedBy:
		return m.UpdatedBy()
	case paymentbankingdetail.FieldPaymentCode:
		return m.PaymentCode()
	case paymentbankingdetail.FieldMerchantUserID:
		return m.MerchantUserID()
	case paymentbankingdetail.FieldMerchantUserBankName:
		return m.MerchantUserBankName()
	case paymentbankingdetail.FieldMerchantUserAccountNumber:
		return m.MerchantUserAccountNumber()
	case paymentbankingdetail.FieldMerchantUserAccountName:
		return m.MerchantUserAccountName()
	case paymentbankingdetail.FieldSystemAccountBankName:
		return m.SystemAccountBankName()
	case paymentbankingdetail.FieldSystemAccountNumber:
		return m.SystemAccountNumber()
	case paymentbankingdetail.FieldSystemAccountName:
		return m.SystemAccountName()
	case paymentbankingdetail.FieldImageURL:
		return m.ImageURL()
	case paymentbankingdetail.FieldTxID:
		return m.TxID()
	case paymentbankingdetail.FieldAmount:
		return m.Amount()
	case paymentbankingdetail.FieldFee:
		return m.Fee()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentBankingDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentbankingdetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case paymentbankingdetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case paymentbankingdetail.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case paymentbankingdetail.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case paymentbankingdetail.FieldPaymentCode:
		return m.OldPaymentCode(ctx)
	case paymentbankingdetail.FieldMerchantUserID:
		return m.OldMerchantUserID(ctx)
	case paymentbankingdetail.FieldMerchantUserBankName:
		return m.OldMerchantUserBankName(ctx)
	case paymentbankingdetail.FieldMerchantUserAccountNumber:
		return m.OldMerchantUserAccountNumber(ctx)
	case paymentbankingdetail.FieldMerchantUserAccountName:
		return m.OldMerchantUserAccountName(ctx)
	case paymentbankingdetail.FieldSystemAccountBankName:
		return m.OldSystemAccountBankName(ctx)
	case paymentbankingdetail.FieldSystemAccountNumber:
		return m.OldSystemAccountNumber(ctx)
	case paymentbankingdetail.FieldSystemAccountName:
		return m.OldSystemAccountName(ctx)
	case paymentbankingdetail.FieldImageURL:
		return m.OldImageURL(ctx)
	case paymentbankingdetail.FieldTxID:
		return m.OldTxID(ctx)
	case paymentbankingdetail.FieldAmount:
		return m.OldAmount(ctx)
	case paymentbankingdetail.FieldFee:
		return m.OldFee(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentBankingDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentBankingDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentbankingdetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case paymentbankingdetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case paymentbankingdetail.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case paymentbankingdetail.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case paymentbankingdetail.FieldPaymentCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentCode(v)
		return nil
	case paymentbankingdetail.FieldMerchantUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantUserID(v)
		return nil
	case paymentbankingdetail.FieldMerchantUserBankName:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantUserBankName(v)
		return nil
	case paymentbankingdetail.FieldMerchantUserAccountNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantUserAccountNumber(v)
		return nil
	case paymentbankingdetail.FieldMerchantUserAccountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantUserAccountName(v)
		return nil
	case paymentbankingdetail.FieldSystemAccountBankName:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemAccountBankName(v)
		return nil
	case paymentbankingdetail.FieldSystemAccountNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemAccountNumber(v)
		return nil
	case paymentbankingdetail.FieldSystemAccountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemAccountName(v)
		return nil
	case paymentbankingdetail.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case paymentbankingdetail.FieldTxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxID(v)
		return nil
	case paymentbankingdetail.FieldAmount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case paymentbankingdetail.FieldFee:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentBankingDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentBankingDetailMutation) AddedFields() []string {
	var fields []string
	if m.addmerchant_user_id != nil {
		fields = append(fields, paymentbankingdetail.FieldMerchantUserID)
	}
	if m.addmerchant_user_bank_name != nil {
		fields = append(fields, paymentbankingdetail.FieldMerchantUserBankName)
	}
	if m.addsystem_account_bank_name != nil {
		fields = append(fields, paymentbankingdetail.FieldSystemAccountBankName)
	}
	if m.addamount != nil {
		fields = append(fields, paymentbankingdetail.FieldAmount)
	}
	if m.addfee != nil {
		fields = append(fields, paymentbankingdetail.FieldFee)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentBankingDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymentbankingdetail.FieldMerchantUserID:
		return m.AddedMerchantUserID()
	case paymentbankingdetail.FieldMerchantUserBankName:
		return m.AddedMerchantUserBankName()
	case paymentbankingdetail.FieldSystemAccountBankName:
		return m.AddedSystemAccountBankName()
	case paymentbankingdetail.FieldAmount:
		return m.AddedAmount()
	case paymentbankingdetail.FieldFee:
		return m.AddedFee()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentBankingDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymentbankingdetail.FieldMerchantUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMerchantUserID(v)
		return nil
	case paymentbankingdetail.FieldMerchantUserBankName:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMerchantUserBankName(v)
		return nil
	case paymentbankingdetail.FieldSystemAccountBankName:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSystemAccountBankName(v)
		return nil
	case paymentbankingdetail.FieldAmount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case paymentbankingdetail.FieldFee:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentBankingDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentBankingDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymentbankingdetail.FieldPaymentCode) {
		fields = append(fields, paymentbankingdetail.FieldPaymentCode)
	}
	if m.FieldCleared(paymentbankingdetail.FieldMerchantUserID) {
		fields = append(fields, paymentbankingdetail.FieldMerchantUserID)
	}
	if m.FieldCleared(paymentbankingdetail.FieldMerchantUserBankName) {
		fields = append(fields, paymentbankingdetail.FieldMerchantUserBankName)
	}
	if m.FieldCleared(paymentbankingdetail.FieldMerchantUserAccountNumber) {
		fields = append(fields, paymentbankingdetail.FieldMerchantUserAccountNumber)
	}
	if m.FieldCleared(paymentbankingdetail.FieldMerchantUserAccountName) {
		fields = append(fields, paymentbankingdetail.FieldMerchantUserAccountName)
	}
	if m.FieldCleared(paymentbankingdetail.FieldSystemAccountBankName) {
		fields = append(fields, paymentbankingdetail.FieldSystemAccountBankName)
	}
	if m.FieldCleared(paymentbankingdetail.FieldSystemAccountNumber) {
		fields = append(fields, paymentbankingdetail.FieldSystemAccountNumber)
	}
	if m.FieldCleared(paymentbankingdetail.FieldSystemAccountName) {
		fields = append(fields, paymentbankingdetail.FieldSystemAccountName)
	}
	if m.FieldCleared(paymentbankingdetail.FieldImageURL) {
		fields = append(fields, paymentbankingdetail.FieldImageURL)
	}
	if m.FieldCleared(paymentbankingdetail.FieldTxID) {
		fields = append(fields, paymentbankingdetail.FieldTxID)
	}
	if m.FieldCleared(paymentbankingdetail.FieldAmount) {
		fields = append(fields, paymentbankingdetail.FieldAmount)
	}
	if m.FieldCleared(paymentbankingdetail.FieldFee) {
		fields = append(fields, paymentbankingdetail.FieldFee)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentBankingDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentBankingDetailMutation) ClearField(name string) error {
	switch name {
	case paymentbankingdetail.FieldPaymentCode:
		m.ClearPaymentCode()
		return nil
	case paymentbankingdetail.FieldMerchantUserID:
		m.ClearMerchantUserID()
		return nil
	case paymentbankingdetail.FieldMerchantUserBankName:
		m.ClearMerchantUserBankName()
		return nil
	case paymentbankingdetail.FieldMerchantUserAccountNumber:
		m.ClearMerchantUserAccountNumber()
		return nil
	case paymentbankingdetail.FieldMerchantUserAccountName:
		m.ClearMerchantUserAccountName()
		return nil
	case paymentbankingdetail.FieldSystemAccountBankName:
		m.ClearSystemAccountBankName()
		return nil
	case paymentbankingdetail.FieldSystemAccountNumber:
		m.ClearSystemAccountNumber()
		return nil
	case paymentbankingdetail.FieldSystemAccountName:
		m.ClearSystemAccountName()
		return nil
	case paymentbankingdetail.FieldImageURL:
		m.ClearImageURL()
		return nil
	case paymentbankingdetail.FieldTxID:
		m.ClearTxID()
		return nil
	case paymentbankingdetail.FieldAmount:
		m.ClearAmount()
		return nil
	case paymentbankingdetail.FieldFee:
		m.ClearFee()
		return nil
	}
	return fmt.Errorf("unknown PaymentBankingDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentBankingDetailMutation) ResetField(name string) error {
	switch name {
	case paymentbankingdetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case paymentbankingdetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case paymentbankingdetail.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case paymentbankingdetail.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case paymentbankingdetail.FieldPaymentCode:
		m.ResetPaymentCode()
		return nil
	case paymentbankingdetail.FieldMerchantUserID:
		m.ResetMerchantUserID()
		return nil
	case paymentbankingdetail.FieldMerchantUserBankName:
		m.ResetMerchantUserBankName()
		return nil
	case paymentbankingdetail.FieldMerchantUserAccountNumber:
		m.ResetMerchantUserAccountNumber()
		return nil
	case paymentbankingdetail.FieldMerchantUserAccountName:
		m.ResetMerchantUserAccountName()
		return nil
	case paymentbankingdetail.FieldSystemAccountBankName:
		m.ResetSystemAccountBankName()
		return nil
	case paymentbankingdetail.FieldSystemAccountNumber:
		m.ResetSystemAccountNumber()
		return nil
	case paymentbankingdetail.FieldSystemAccountName:
		m.ResetSystemAccountName()
		return nil
	case paymentbankingdetail.FieldImageURL:
		m.ResetImageURL()
		return nil
	case paymentbankingdetail.FieldTxID:
		m.ResetTxID()
		return nil
	case paymentbankingdetail.FieldAmount:
		m.ResetAmount()
		return nil
	case paymentbankingdetail.FieldFee:
		m.ResetFee()
		return nil
	}
	return fmt.Errorf("unknown PaymentBankingDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentBankingDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.payment != nil {
		edges = append(edges, paymentbankingdetail.EdgePayment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentBankingDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymentbankingdetail.EdgePayment:
		if id := m.payment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentBankingDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentBankingDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentBankingDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpayment {
		edges = append(edges, paymentbankingdetail.EdgePayment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentBankingDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case paymentbankingdetail.EdgePayment:
		return m.clearedpayment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentBankingDetailMutation) ClearEdge(name string) error {
	switch name {
	case paymentbankingdetail.EdgePayment:
		m.ClearPayment()
		return nil
	}
	return fmt.Errorf("unknown PaymentBankingDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentBankingDetailMutation) ResetEdge(name string) error {
	switch name {
	case paymentbankingdetail.EdgePayment:
		m.ResetPayment()
		return nil
	}
	return fmt.Errorf("unknown PaymentBankingDetail edge %s", name)
}

// PaymentCryptoDetailMutation represents an operation that mutates the PaymentCryptoDetail nodes in the graph.
type PaymentCryptoDetailMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	crypto_type            *int32
	addcrypto_type         *int32
	crypto_network_type    *int32
	addcrypto_network_type *int32
	crypto_wallet_name     *int32
	addcrypto_wallet_name  *int32
	receiver_address       *string
	sender_address         *string
	amount                 *float64
	addamount              *float64
	received_amount        *float64
	addreceived_amount     *float64
	tx_hash                *string
	tx_id                  *string
	fee                    *float64
	addfee                 *float64
	image_url              *string
	clearedFields          map[string]struct{}
	payment                *int64
	clearedpayment         bool
	done                   bool
	oldValue               func(context.Context) (*PaymentCryptoDetail, error)
	predicates             []predicate.PaymentCryptoDetail
}

var _ ent.Mutation = (*PaymentCryptoDetailMutation)(nil)

// paymentcryptodetailOption allows management of the mutation configuration using functional options.
type paymentcryptodetailOption func(*PaymentCryptoDetailMutation)

// newPaymentCryptoDetailMutation creates new mutation for the PaymentCryptoDetail entity.
func newPaymentCryptoDetailMutation(c config, op Op, opts ...paymentcryptodetailOption) *PaymentCryptoDetailMutation {
	m := &PaymentCryptoDetailMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentCryptoDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentCryptoDetailID sets the ID field of the mutation.
func withPaymentCryptoDetailID(id int64) paymentcryptodetailOption {
	return func(m *PaymentCryptoDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentCryptoDetail
		)
		m.oldValue = func(ctx context.Context) (*PaymentCryptoDetail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentCryptoDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentCryptoDetail sets the old PaymentCryptoDetail of the mutation.
func withPaymentCryptoDetail(node *PaymentCryptoDetail) paymentcryptodetailOption {
	return func(m *PaymentCryptoDetailMutation) {
		m.oldValue = func(context.Context) (*PaymentCryptoDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentCryptoDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentCryptoDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentCryptoDetail entities.
func (m *PaymentCryptoDetailMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentCryptoDetailMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentCryptoDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentCryptoDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentCryptoDetail entity.
// If the PaymentCryptoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCryptoDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentCryptoDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentCryptoDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentCryptoDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PaymentCryptoDetail entity.
// If the PaymentCryptoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCryptoDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentCryptoDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PaymentCryptoDetailMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PaymentCryptoDetailMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PaymentCryptoDetail entity.
// If the PaymentCryptoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCryptoDetailMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PaymentCryptoDetailMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PaymentCryptoDetailMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PaymentCryptoDetailMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PaymentCryptoDetail entity.
// If the PaymentCryptoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCryptoDetailMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PaymentCryptoDetailMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetCryptoType sets the "crypto_type" field.
func (m *PaymentCryptoDetailMutation) SetCryptoType(i int32) {
	m.crypto_type = &i
	m.addcrypto_type = nil
}

// CryptoType returns the value of the "crypto_type" field in the mutation.
func (m *PaymentCryptoDetailMutation) CryptoType() (r int32, exists bool) {
	v := m.crypto_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCryptoType returns the old "crypto_type" field's value of the PaymentCryptoDetail entity.
// If the PaymentCryptoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCryptoDetailMutation) OldCryptoType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCryptoType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCryptoType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCryptoType: %w", err)
	}
	return oldValue.CryptoType, nil
}

// AddCryptoType adds i to the "crypto_type" field.
func (m *PaymentCryptoDetailMutation) AddCryptoType(i int32) {
	if m.addcrypto_type != nil {
		*m.addcrypto_type += i
	} else {
		m.addcrypto_type = &i
	}
}

// AddedCryptoType returns the value that was added to the "crypto_type" field in this mutation.
func (m *PaymentCryptoDetailMutation) AddedCryptoType() (r int32, exists bool) {
	v := m.addcrypto_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetCryptoType resets all changes to the "crypto_type" field.
func (m *PaymentCryptoDetailMutation) ResetCryptoType() {
	m.crypto_type = nil
	m.addcrypto_type = nil
}

// SetCryptoNetworkType sets the "crypto_network_type" field.
func (m *PaymentCryptoDetailMutation) SetCryptoNetworkType(i int32) {
	m.crypto_network_type = &i
	m.addcrypto_network_type = nil
}

// CryptoNetworkType returns the value of the "crypto_network_type" field in the mutation.
func (m *PaymentCryptoDetailMutation) CryptoNetworkType() (r int32, exists bool) {
	v := m.crypto_network_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCryptoNetworkType returns the old "crypto_network_type" field's value of the PaymentCryptoDetail entity.
// If the PaymentCryptoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCryptoDetailMutation) OldCryptoNetworkType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCryptoNetworkType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCryptoNetworkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCryptoNetworkType: %w", err)
	}
	return oldValue.CryptoNetworkType, nil
}

// AddCryptoNetworkType adds i to the "crypto_network_type" field.
func (m *PaymentCryptoDetailMutation) AddCryptoNetworkType(i int32) {
	if m.addcrypto_network_type != nil {
		*m.addcrypto_network_type += i
	} else {
		m.addcrypto_network_type = &i
	}
}

// AddedCryptoNetworkType returns the value that was added to the "crypto_network_type" field in this mutation.
func (m *PaymentCryptoDetailMutation) AddedCryptoNetworkType() (r int32, exists bool) {
	v := m.addcrypto_network_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetCryptoNetworkType resets all changes to the "crypto_network_type" field.
func (m *PaymentCryptoDetailMutation) ResetCryptoNetworkType() {
	m.crypto_network_type = nil
	m.addcrypto_network_type = nil
}

// SetCryptoWalletName sets the "crypto_wallet_name" field.
func (m *PaymentCryptoDetailMutation) SetCryptoWalletName(i int32) {
	m.crypto_wallet_name = &i
	m.addcrypto_wallet_name = nil
}

// CryptoWalletName returns the value of the "crypto_wallet_name" field in the mutation.
func (m *PaymentCryptoDetailMutation) CryptoWalletName() (r int32, exists bool) {
	v := m.crypto_wallet_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCryptoWalletName returns the old "crypto_wallet_name" field's value of the PaymentCryptoDetail entity.
// If the PaymentCryptoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCryptoDetailMutation) OldCryptoWalletName(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCryptoWalletName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCryptoWalletName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCryptoWalletName: %w", err)
	}
	return oldValue.CryptoWalletName, nil
}

// AddCryptoWalletName adds i to the "crypto_wallet_name" field.
func (m *PaymentCryptoDetailMutation) AddCryptoWalletName(i int32) {
	if m.addcrypto_wallet_name != nil {
		*m.addcrypto_wallet_name += i
	} else {
		m.addcrypto_wallet_name = &i
	}
}

// AddedCryptoWalletName returns the value that was added to the "crypto_wallet_name" field in this mutation.
func (m *PaymentCryptoDetailMutation) AddedCryptoWalletName() (r int32, exists bool) {
	v := m.addcrypto_wallet_name
	if v == nil {
		return
	}
	return *v, true
}

// ResetCryptoWalletName resets all changes to the "crypto_wallet_name" field.
func (m *PaymentCryptoDetailMutation) ResetCryptoWalletName() {
	m.crypto_wallet_name = nil
	m.addcrypto_wallet_name = nil
}

// SetReceiverAddress sets the "receiver_address" field.
func (m *PaymentCryptoDetailMutation) SetReceiverAddress(s string) {
	m.receiver_address = &s
}

// ReceiverAddress returns the value of the "receiver_address" field in the mutation.
func (m *PaymentCryptoDetailMutation) ReceiverAddress() (r string, exists bool) {
	v := m.receiver_address
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverAddress returns the old "receiver_address" field's value of the PaymentCryptoDetail entity.
// If the PaymentCryptoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCryptoDetailMutation) OldReceiverAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReceiverAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReceiverAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverAddress: %w", err)
	}
	return oldValue.ReceiverAddress, nil
}

// ResetReceiverAddress resets all changes to the "receiver_address" field.
func (m *PaymentCryptoDetailMutation) ResetReceiverAddress() {
	m.receiver_address = nil
}

// SetSenderAddress sets the "sender_address" field.
func (m *PaymentCryptoDetailMutation) SetSenderAddress(s string) {
	m.sender_address = &s
}

// SenderAddress returns the value of the "sender_address" field in the mutation.
func (m *PaymentCryptoDetailMutation) SenderAddress() (r string, exists bool) {
	v := m.sender_address
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderAddress returns the old "sender_address" field's value of the PaymentCryptoDetail entity.
// If the PaymentCryptoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCryptoDetailMutation) OldSenderAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSenderAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSenderAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderAddress: %w", err)
	}
	return oldValue.SenderAddress, nil
}

// ClearSenderAddress clears the value of the "sender_address" field.
func (m *PaymentCryptoDetailMutation) ClearSenderAddress() {
	m.sender_address = nil
	m.clearedFields[paymentcryptodetail.FieldSenderAddress] = struct{}{}
}

// SenderAddressCleared returns if the "sender_address" field was cleared in this mutation.
func (m *PaymentCryptoDetailMutation) SenderAddressCleared() bool {
	_, ok := m.clearedFields[paymentcryptodetail.FieldSenderAddress]
	return ok
}

// ResetSenderAddress resets all changes to the "sender_address" field.
func (m *PaymentCryptoDetailMutation) ResetSenderAddress() {
	m.sender_address = nil
	delete(m.clearedFields, paymentcryptodetail.FieldSenderAddress)
}

// SetAmount sets the "amount" field.
func (m *PaymentCryptoDetailMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentCryptoDetailMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the PaymentCryptoDetail entity.
// If the PaymentCryptoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCryptoDetailMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *PaymentCryptoDetailMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentCryptoDetailMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *PaymentCryptoDetailMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[paymentcryptodetail.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *PaymentCryptoDetailMutation) AmountCleared() bool {
	_, ok := m.clearedFields[paymentcryptodetail.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentCryptoDetailMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, paymentcryptodetail.FieldAmount)
}

// SetReceivedAmount sets the "received_amount" field.
func (m *PaymentCryptoDetailMutation) SetReceivedAmount(f float64) {
	m.received_amount = &f
	m.addreceived_amount = nil
}

// ReceivedAmount returns the value of the "received_amount" field in the mutation.
func (m *PaymentCryptoDetailMutation) ReceivedAmount() (r float64, exists bool) {
	v := m.received_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivedAmount returns the old "received_amount" field's value of the PaymentCryptoDetail entity.
// If the PaymentCryptoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCryptoDetailMutation) OldReceivedAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReceivedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReceivedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivedAmount: %w", err)
	}
	return oldValue.ReceivedAmount, nil
}

// AddReceivedAmount adds f to the "received_amount" field.
func (m *PaymentCryptoDetailMutation) AddReceivedAmount(f float64) {
	if m.addreceived_amount != nil {
		*m.addreceived_amount += f
	} else {
		m.addreceived_amount = &f
	}
}

// AddedReceivedAmount returns the value that was added to the "received_amount" field in this mutation.
func (m *PaymentCryptoDetailMutation) AddedReceivedAmount() (r float64, exists bool) {
	v := m.addreceived_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearReceivedAmount clears the value of the "received_amount" field.
func (m *PaymentCryptoDetailMutation) ClearReceivedAmount() {
	m.received_amount = nil
	m.addreceived_amount = nil
	m.clearedFields[paymentcryptodetail.FieldReceivedAmount] = struct{}{}
}

// ReceivedAmountCleared returns if the "received_amount" field was cleared in this mutation.
func (m *PaymentCryptoDetailMutation) ReceivedAmountCleared() bool {
	_, ok := m.clearedFields[paymentcryptodetail.FieldReceivedAmount]
	return ok
}

// ResetReceivedAmount resets all changes to the "received_amount" field.
func (m *PaymentCryptoDetailMutation) ResetReceivedAmount() {
	m.received_amount = nil
	m.addreceived_amount = nil
	delete(m.clearedFields, paymentcryptodetail.FieldReceivedAmount)
}

// SetTxHash sets the "tx_hash" field.
func (m *PaymentCryptoDetailMutation) SetTxHash(s string) {
	m.tx_hash = &s
}

// TxHash returns the value of the "tx_hash" field in the mutation.
func (m *PaymentCryptoDetailMutation) TxHash() (r string, exists bool) {
	v := m.tx_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTxHash returns the old "tx_hash" field's value of the PaymentCryptoDetail entity.
// If the PaymentCryptoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCryptoDetailMutation) OldTxHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTxHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTxHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxHash: %w", err)
	}
	return oldValue.TxHash, nil
}

// ClearTxHash clears the value of the "tx_hash" field.
func (m *PaymentCryptoDetailMutation) ClearTxHash() {
	m.tx_hash = nil
	m.clearedFields[paymentcryptodetail.FieldTxHash] = struct{}{}
}

// TxHashCleared returns if the "tx_hash" field was cleared in this mutation.
func (m *PaymentCryptoDetailMutation) TxHashCleared() bool {
	_, ok := m.clearedFields[paymentcryptodetail.FieldTxHash]
	return ok
}

// ResetTxHash resets all changes to the "tx_hash" field.
func (m *PaymentCryptoDetailMutation) ResetTxHash() {
	m.tx_hash = nil
	delete(m.clearedFields, paymentcryptodetail.FieldTxHash)
}

// SetTxID sets the "tx_id" field.
func (m *PaymentCryptoDetailMutation) SetTxID(s string) {
	m.tx_id = &s
}

// TxID returns the value of the "tx_id" field in the mutation.
func (m *PaymentCryptoDetailMutation) TxID() (r string, exists bool) {
	v := m.tx_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTxID returns the old "tx_id" field's value of the PaymentCryptoDetail entity.
// If the PaymentCryptoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCryptoDetailMutation) OldTxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxID: %w", err)
	}
	return oldValue.TxID, nil
}

// ClearTxID clears the value of the "tx_id" field.
func (m *PaymentCryptoDetailMutation) ClearTxID() {
	m.tx_id = nil
	m.clearedFields[paymentcryptodetail.FieldTxID] = struct{}{}
}

// TxIDCleared returns if the "tx_id" field was cleared in this mutation.
func (m *PaymentCryptoDetailMutation) TxIDCleared() bool {
	_, ok := m.clearedFields[paymentcryptodetail.FieldTxID]
	return ok
}

// ResetTxID resets all changes to the "tx_id" field.
func (m *PaymentCryptoDetailMutation) ResetTxID() {
	m.tx_id = nil
	delete(m.clearedFields, paymentcryptodetail.FieldTxID)
}

// SetFee sets the "fee" field.
func (m *PaymentCryptoDetailMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *PaymentCryptoDetailMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the PaymentCryptoDetail entity.
// If the PaymentCryptoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCryptoDetailMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *PaymentCryptoDetailMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *PaymentCryptoDetailMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *PaymentCryptoDetailMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[paymentcryptodetail.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *PaymentCryptoDetailMutation) FeeCleared() bool {
	_, ok := m.clearedFields[paymentcryptodetail.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *PaymentCryptoDetailMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, paymentcryptodetail.FieldFee)
}

// SetImageURL sets the "image_url" field.
func (m *PaymentCryptoDetailMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *PaymentCryptoDetailMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the PaymentCryptoDetail entity.
// If the PaymentCryptoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentCryptoDetailMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *PaymentCryptoDetailMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[paymentcryptodetail.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *PaymentCryptoDetailMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[paymentcryptodetail.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *PaymentCryptoDetailMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, paymentcryptodetail.FieldImageURL)
}

// SetPaymentID sets the "payment" edge to the Payment entity by id.
func (m *PaymentCryptoDetailMutation) SetPaymentID(id int64) {
	m.payment = &id
}

// ClearPayment clears the "payment" edge to the Payment entity.
func (m *PaymentCryptoDetailMutation) ClearPayment() {
	m.clearedpayment = true
}

// PaymentCleared reports if the "payment" edge to the Payment entity was cleared.
func (m *PaymentCryptoDetailMutation) PaymentCleared() bool {
	return m.clearedpayment
}

// PaymentID returns the "payment" edge ID in the mutation.
func (m *PaymentCryptoDetailMutation) PaymentID() (id int64, exists bool) {
	if m.payment != nil {
		return *m.payment, true
	}
	return
}

// PaymentIDs returns the "payment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentID instead. It exists only for internal usage by the builders.
func (m *PaymentCryptoDetailMutation) PaymentIDs() (ids []int64) {
	if id := m.payment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPayment resets all changes to the "payment" edge.
func (m *PaymentCryptoDetailMutation) ResetPayment() {
	m.payment = nil
	m.clearedpayment = false
}

// Where appends a list predicates to the PaymentCryptoDetailMutation builder.
func (m *PaymentCryptoDetailMutation) Where(ps ...predicate.PaymentCryptoDetail) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PaymentCryptoDetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PaymentCryptoDetail).
func (m *PaymentCryptoDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentCryptoDetailMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, paymentcryptodetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, paymentcryptodetail.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, paymentcryptodetail.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, paymentcryptodetail.FieldUpdatedBy)
	}
	if m.crypto_type != nil {
		fields = append(fields, paymentcryptodetail.FieldCryptoType)
	}
	if m.crypto_network_type != nil {
		fields = append(fields, paymentcryptodetail.FieldCryptoNetworkType)
	}
	if m.crypto_wallet_name != nil {
		fields = append(fields, paymentcryptodetail.FieldCryptoWalletName)
	}
	if m.receiver_address != nil {
		fields = append(fields, paymentcryptodetail.FieldReceiverAddress)
	}
	if m.sender_address != nil {
		fields = append(fields, paymentcryptodetail.FieldSenderAddress)
	}
	if m.amount != nil {
		fields = append(fields, paymentcryptodetail.FieldAmount)
	}
	if m.received_amount != nil {
		fields = append(fields, paymentcryptodetail.FieldReceivedAmount)
	}
	if m.tx_hash != nil {
		fields = append(fields, paymentcryptodetail.FieldTxHash)
	}
	if m.tx_id != nil {
		fields = append(fields, paymentcryptodetail.FieldTxID)
	}
	if m.fee != nil {
		fields = append(fields, paymentcryptodetail.FieldFee)
	}
	if m.image_url != nil {
		fields = append(fields, paymentcryptodetail.FieldImageURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentCryptoDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentcryptodetail.FieldCreatedAt:
		return m.CreatedAt()
	case paymentcryptodetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case paymentcryptodetail.FieldCreatedBy:
		return m.CreatedBy()
	case paymentcryptodetail.FieldUpdatedBy:
		return m.UpdatedBy()
	case paymentcryptodetail.FieldCryptoType:
		return m.CryptoType()
	case paymentcryptodetail.FieldCryptoNetworkType:
		return m.CryptoNetworkType()
	case paymentcryptodetail.FieldCryptoWalletName:
		return m.CryptoWalletName()
	case paymentcryptodetail.FieldReceiverAddress:
		return m.ReceiverAddress()
	case paymentcryptodetail.FieldSenderAddress:
		return m.SenderAddress()
	case paymentcryptodetail.FieldAmount:
		return m.Amount()
	case paymentcryptodetail.FieldReceivedAmount:
		return m.ReceivedAmount()
	case paymentcryptodetail.FieldTxHash:
		return m.TxHash()
	case paymentcryptodetail.FieldTxID:
		return m.TxID()
	case paymentcryptodetail.FieldFee:
		return m.Fee()
	case paymentcryptodetail.FieldImageURL:
		return m.ImageURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentCryptoDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentcryptodetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case paymentcryptodetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case paymentcryptodetail.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case paymentcryptodetail.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case paymentcryptodetail.FieldCryptoType:
		return m.OldCryptoType(ctx)
	case paymentcryptodetail.FieldCryptoNetworkType:
		return m.OldCryptoNetworkType(ctx)
	case paymentcryptodetail.FieldCryptoWalletName:
		return m.OldCryptoWalletName(ctx)
	case paymentcryptodetail.FieldReceiverAddress:
		return m.OldReceiverAddress(ctx)
	case paymentcryptodetail.FieldSenderAddress:
		return m.OldSenderAddress(ctx)
	case paymentcryptodetail.FieldAmount:
		return m.OldAmount(ctx)
	case paymentcryptodetail.FieldReceivedAmount:
		return m.OldReceivedAmount(ctx)
	case paymentcryptodetail.FieldTxHash:
		return m.OldTxHash(ctx)
	case paymentcryptodetail.FieldTxID:
		return m.OldTxID(ctx)
	case paymentcryptodetail.FieldFee:
		return m.OldFee(ctx)
	case paymentcryptodetail.FieldImageURL:
		return m.OldImageURL(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentCryptoDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentCryptoDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentcryptodetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case paymentcryptodetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case paymentcryptodetail.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case paymentcryptodetail.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case paymentcryptodetail.FieldCryptoType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCryptoType(v)
		return nil
	case paymentcryptodetail.FieldCryptoNetworkType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCryptoNetworkType(v)
		return nil
	case paymentcryptodetail.FieldCryptoWalletName:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCryptoWalletName(v)
		return nil
	case paymentcryptodetail.FieldReceiverAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverAddress(v)
		return nil
	case paymentcryptodetail.FieldSenderAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderAddress(v)
		return nil
	case paymentcryptodetail.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case paymentcryptodetail.FieldReceivedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivedAmount(v)
		return nil
	case paymentcryptodetail.FieldTxHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxHash(v)
		return nil
	case paymentcryptodetail.FieldTxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxID(v)
		return nil
	case paymentcryptodetail.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case paymentcryptodetail.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentCryptoDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentCryptoDetailMutation) AddedFields() []string {
	var fields []string
	if m.addcrypto_type != nil {
		fields = append(fields, paymentcryptodetail.FieldCryptoType)
	}
	if m.addcrypto_network_type != nil {
		fields = append(fields, paymentcryptodetail.FieldCryptoNetworkType)
	}
	if m.addcrypto_wallet_name != nil {
		fields = append(fields, paymentcryptodetail.FieldCryptoWalletName)
	}
	if m.addamount != nil {
		fields = append(fields, paymentcryptodetail.FieldAmount)
	}
	if m.addreceived_amount != nil {
		fields = append(fields, paymentcryptodetail.FieldReceivedAmount)
	}
	if m.addfee != nil {
		fields = append(fields, paymentcryptodetail.FieldFee)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentCryptoDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymentcryptodetail.FieldCryptoType:
		return m.AddedCryptoType()
	case paymentcryptodetail.FieldCryptoNetworkType:
		return m.AddedCryptoNetworkType()
	case paymentcryptodetail.FieldCryptoWalletName:
		return m.AddedCryptoWalletName()
	case paymentcryptodetail.FieldAmount:
		return m.AddedAmount()
	case paymentcryptodetail.FieldReceivedAmount:
		return m.AddedReceivedAmount()
	case paymentcryptodetail.FieldFee:
		return m.AddedFee()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentCryptoDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymentcryptodetail.FieldCryptoType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCryptoType(v)
		return nil
	case paymentcryptodetail.FieldCryptoNetworkType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCryptoNetworkType(v)
		return nil
	case paymentcryptodetail.FieldCryptoWalletName:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCryptoWalletName(v)
		return nil
	case paymentcryptodetail.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case paymentcryptodetail.FieldReceivedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReceivedAmount(v)
		return nil
	case paymentcryptodetail.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentCryptoDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentCryptoDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymentcryptodetail.FieldSenderAddress) {
		fields = append(fields, paymentcryptodetail.FieldSenderAddress)
	}
	if m.FieldCleared(paymentcryptodetail.FieldAmount) {
		fields = append(fields, paymentcryptodetail.FieldAmount)
	}
	if m.FieldCleared(paymentcryptodetail.FieldReceivedAmount) {
		fields = append(fields, paymentcryptodetail.FieldReceivedAmount)
	}
	if m.FieldCleared(paymentcryptodetail.FieldTxHash) {
		fields = append(fields, paymentcryptodetail.FieldTxHash)
	}
	if m.FieldCleared(paymentcryptodetail.FieldTxID) {
		fields = append(fields, paymentcryptodetail.FieldTxID)
	}
	if m.FieldCleared(paymentcryptodetail.FieldFee) {
		fields = append(fields, paymentcryptodetail.FieldFee)
	}
	if m.FieldCleared(paymentcryptodetail.FieldImageURL) {
		fields = append(fields, paymentcryptodetail.FieldImageURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentCryptoDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentCryptoDetailMutation) ClearField(name string) error {
	switch name {
	case paymentcryptodetail.FieldSenderAddress:
		m.ClearSenderAddress()
		return nil
	case paymentcryptodetail.FieldAmount:
		m.ClearAmount()
		return nil
	case paymentcryptodetail.FieldReceivedAmount:
		m.ClearReceivedAmount()
		return nil
	case paymentcryptodetail.FieldTxHash:
		m.ClearTxHash()
		return nil
	case paymentcryptodetail.FieldTxID:
		m.ClearTxID()
		return nil
	case paymentcryptodetail.FieldFee:
		m.ClearFee()
		return nil
	case paymentcryptodetail.FieldImageURL:
		m.ClearImageURL()
		return nil
	}
	return fmt.Errorf("unknown PaymentCryptoDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentCryptoDetailMutation) ResetField(name string) error {
	switch name {
	case paymentcryptodetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case paymentcryptodetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case paymentcryptodetail.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case paymentcryptodetail.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case paymentcryptodetail.FieldCryptoType:
		m.ResetCryptoType()
		return nil
	case paymentcryptodetail.FieldCryptoNetworkType:
		m.ResetCryptoNetworkType()
		return nil
	case paymentcryptodetail.FieldCryptoWalletName:
		m.ResetCryptoWalletName()
		return nil
	case paymentcryptodetail.FieldReceiverAddress:
		m.ResetReceiverAddress()
		return nil
	case paymentcryptodetail.FieldSenderAddress:
		m.ResetSenderAddress()
		return nil
	case paymentcryptodetail.FieldAmount:
		m.ResetAmount()
		return nil
	case paymentcryptodetail.FieldReceivedAmount:
		m.ResetReceivedAmount()
		return nil
	case paymentcryptodetail.FieldTxHash:
		m.ResetTxHash()
		return nil
	case paymentcryptodetail.FieldTxID:
		m.ResetTxID()
		return nil
	case paymentcryptodetail.FieldFee:
		m.ResetFee()
		return nil
	case paymentcryptodetail.FieldImageURL:
		m.ResetImageURL()
		return nil
	}
	return fmt.Errorf("unknown PaymentCryptoDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentCryptoDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.payment != nil {
		edges = append(edges, paymentcryptodetail.EdgePayment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentCryptoDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymentcryptodetail.EdgePayment:
		if id := m.payment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentCryptoDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentCryptoDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentCryptoDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpayment {
		edges = append(edges, paymentcryptodetail.EdgePayment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentCryptoDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case paymentcryptodetail.EdgePayment:
		return m.clearedpayment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentCryptoDetailMutation) ClearEdge(name string) error {
	switch name {
	case paymentcryptodetail.EdgePayment:
		m.ClearPayment()
		return nil
	}
	return fmt.Errorf("unknown PaymentCryptoDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentCryptoDetailMutation) ResetEdge(name string) error {
	switch name {
	case paymentcryptodetail.EdgePayment:
		m.ResetPayment()
		return nil
	}
	return fmt.Errorf("unknown PaymentCryptoDetail edge %s", name)
}

// PaymentEWalletDetailMutation represents an operation that mutates the PaymentEWalletDetail nodes in the graph.
type PaymentEWalletDetailMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int64
	created_at                         *time.Time
	updated_at                         *time.Time
	created_by                         *string
	updated_by                         *string
	payment_code                       *string
	merchant_user_id                   *int64
	addmerchant_user_id                *int64
	e_wallet_name                      *int32
	adde_wallet_name                   *int32
	merchant_user_account_phone_number *string
	merchant_user_account_name         *string
	system_account_phone_number        *string
	system_account_name                *string
	amount                             *uint64
	addamount                          *uint64
	fee                                *uint64
	addfee                             *uint64
	note                               *string
	image_url                          *string
	tx_id                              *string
	clearedFields                      map[string]struct{}
	payment                            *int64
	clearedpayment                     bool
	done                               bool
	oldValue                           func(context.Context) (*PaymentEWalletDetail, error)
	predicates                         []predicate.PaymentEWalletDetail
}

var _ ent.Mutation = (*PaymentEWalletDetailMutation)(nil)

// paymentewalletdetailOption allows management of the mutation configuration using functional options.
type paymentewalletdetailOption func(*PaymentEWalletDetailMutation)

// newPaymentEWalletDetailMutation creates new mutation for the PaymentEWalletDetail entity.
func newPaymentEWalletDetailMutation(c config, op Op, opts ...paymentewalletdetailOption) *PaymentEWalletDetailMutation {
	m := &PaymentEWalletDetailMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentEWalletDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentEWalletDetailID sets the ID field of the mutation.
func withPaymentEWalletDetailID(id int64) paymentewalletdetailOption {
	return func(m *PaymentEWalletDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentEWalletDetail
		)
		m.oldValue = func(ctx context.Context) (*PaymentEWalletDetail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentEWalletDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentEWalletDetail sets the old PaymentEWalletDetail of the mutation.
func withPaymentEWalletDetail(node *PaymentEWalletDetail) paymentewalletdetailOption {
	return func(m *PaymentEWalletDetailMutation) {
		m.oldValue = func(context.Context) (*PaymentEWalletDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentEWalletDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentEWalletDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentEWalletDetail entities.
func (m *PaymentEWalletDetailMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentEWalletDetailMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentEWalletDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentEWalletDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentEWalletDetail entity.
// If the PaymentEWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentEWalletDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentEWalletDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentEWalletDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentEWalletDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PaymentEWalletDetail entity.
// If the PaymentEWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentEWalletDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentEWalletDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PaymentEWalletDetailMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PaymentEWalletDetailMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PaymentEWalletDetail entity.
// If the PaymentEWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentEWalletDetailMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PaymentEWalletDetailMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PaymentEWalletDetailMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PaymentEWalletDetailMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PaymentEWalletDetail entity.
// If the PaymentEWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentEWalletDetailMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PaymentEWalletDetailMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetPaymentCode sets the "payment_code" field.
func (m *PaymentEWalletDetailMutation) SetPaymentCode(s string) {
	m.payment_code = &s
}

// PaymentCode returns the value of the "payment_code" field in the mutation.
func (m *PaymentEWalletDetailMutation) PaymentCode() (r string, exists bool) {
	v := m.payment_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentCode returns the old "payment_code" field's value of the PaymentEWalletDetail entity.
// If the PaymentEWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentEWalletDetailMutation) OldPaymentCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentCode: %w", err)
	}
	return oldValue.PaymentCode, nil
}

// ClearPaymentCode clears the value of the "payment_code" field.
func (m *PaymentEWalletDetailMutation) ClearPaymentCode() {
	m.payment_code = nil
	m.clearedFields[paymentewalletdetail.FieldPaymentCode] = struct{}{}
}

// PaymentCodeCleared returns if the "payment_code" field was cleared in this mutation.
func (m *PaymentEWalletDetailMutation) PaymentCodeCleared() bool {
	_, ok := m.clearedFields[paymentewalletdetail.FieldPaymentCode]
	return ok
}

// ResetPaymentCode resets all changes to the "payment_code" field.
func (m *PaymentEWalletDetailMutation) ResetPaymentCode() {
	m.payment_code = nil
	delete(m.clearedFields, paymentewalletdetail.FieldPaymentCode)
}

// SetMerchantUserID sets the "merchant_user_id" field.
func (m *PaymentEWalletDetailMutation) SetMerchantUserID(i int64) {
	m.merchant_user_id = &i
	m.addmerchant_user_id = nil
}

// MerchantUserID returns the value of the "merchant_user_id" field in the mutation.
func (m *PaymentEWalletDetailMutation) MerchantUserID() (r int64, exists bool) {
	v := m.merchant_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantUserID returns the old "merchant_user_id" field's value of the PaymentEWalletDetail entity.
// If the PaymentEWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentEWalletDetailMutation) OldMerchantUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantUserID: %w", err)
	}
	return oldValue.MerchantUserID, nil
}

// AddMerchantUserID adds i to the "merchant_user_id" field.
func (m *PaymentEWalletDetailMutation) AddMerchantUserID(i int64) {
	if m.addmerchant_user_id != nil {
		*m.addmerchant_user_id += i
	} else {
		m.addmerchant_user_id = &i
	}
}

// AddedMerchantUserID returns the value that was added to the "merchant_user_id" field in this mutation.
func (m *PaymentEWalletDetailMutation) AddedMerchantUserID() (r int64, exists bool) {
	v := m.addmerchant_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMerchantUserID clears the value of the "merchant_user_id" field.
func (m *PaymentEWalletDetailMutation) ClearMerchantUserID() {
	m.merchant_user_id = nil
	m.addmerchant_user_id = nil
	m.clearedFields[paymentewalletdetail.FieldMerchantUserID] = struct{}{}
}

// MerchantUserIDCleared returns if the "merchant_user_id" field was cleared in this mutation.
func (m *PaymentEWalletDetailMutation) MerchantUserIDCleared() bool {
	_, ok := m.clearedFields[paymentewalletdetail.FieldMerchantUserID]
	return ok
}

// ResetMerchantUserID resets all changes to the "merchant_user_id" field.
func (m *PaymentEWalletDetailMutation) ResetMerchantUserID() {
	m.merchant_user_id = nil
	m.addmerchant_user_id = nil
	delete(m.clearedFields, paymentewalletdetail.FieldMerchantUserID)
}

// SetEWalletName sets the "e_wallet_name" field.
func (m *PaymentEWalletDetailMutation) SetEWalletName(i int32) {
	m.e_wallet_name = &i
	m.adde_wallet_name = nil
}

// EWalletName returns the value of the "e_wallet_name" field in the mutation.
func (m *PaymentEWalletDetailMutation) EWalletName() (r int32, exists bool) {
	v := m.e_wallet_name
	if v == nil {
		return
	}
	return *v, true
}

// OldEWalletName returns the old "e_wallet_name" field's value of the PaymentEWalletDetail entity.
// If the PaymentEWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentEWalletDetailMutation) OldEWalletName(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEWalletName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEWalletName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEWalletName: %w", err)
	}
	return oldValue.EWalletName, nil
}

// AddEWalletName adds i to the "e_wallet_name" field.
func (m *PaymentEWalletDetailMutation) AddEWalletName(i int32) {
	if m.adde_wallet_name != nil {
		*m.adde_wallet_name += i
	} else {
		m.adde_wallet_name = &i
	}
}

// AddedEWalletName returns the value that was added to the "e_wallet_name" field in this mutation.
func (m *PaymentEWalletDetailMutation) AddedEWalletName() (r int32, exists bool) {
	v := m.adde_wallet_name
	if v == nil {
		return
	}
	return *v, true
}

// ClearEWalletName clears the value of the "e_wallet_name" field.
func (m *PaymentEWalletDetailMutation) ClearEWalletName() {
	m.e_wallet_name = nil
	m.adde_wallet_name = nil
	m.clearedFields[paymentewalletdetail.FieldEWalletName] = struct{}{}
}

// EWalletNameCleared returns if the "e_wallet_name" field was cleared in this mutation.
func (m *PaymentEWalletDetailMutation) EWalletNameCleared() bool {
	_, ok := m.clearedFields[paymentewalletdetail.FieldEWalletName]
	return ok
}

// ResetEWalletName resets all changes to the "e_wallet_name" field.
func (m *PaymentEWalletDetailMutation) ResetEWalletName() {
	m.e_wallet_name = nil
	m.adde_wallet_name = nil
	delete(m.clearedFields, paymentewalletdetail.FieldEWalletName)
}

// SetMerchantUserAccountPhoneNumber sets the "merchant_user_account_phone_number" field.
func (m *PaymentEWalletDetailMutation) SetMerchantUserAccountPhoneNumber(s string) {
	m.merchant_user_account_phone_number = &s
}

// MerchantUserAccountPhoneNumber returns the value of the "merchant_user_account_phone_number" field in the mutation.
func (m *PaymentEWalletDetailMutation) MerchantUserAccountPhoneNumber() (r string, exists bool) {
	v := m.merchant_user_account_phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantUserAccountPhoneNumber returns the old "merchant_user_account_phone_number" field's value of the PaymentEWalletDetail entity.
// If the PaymentEWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentEWalletDetailMutation) OldMerchantUserAccountPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantUserAccountPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantUserAccountPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantUserAccountPhoneNumber: %w", err)
	}
	return oldValue.MerchantUserAccountPhoneNumber, nil
}

// ClearMerchantUserAccountPhoneNumber clears the value of the "merchant_user_account_phone_number" field.
func (m *PaymentEWalletDetailMutation) ClearMerchantUserAccountPhoneNumber() {
	m.merchant_user_account_phone_number = nil
	m.clearedFields[paymentewalletdetail.FieldMerchantUserAccountPhoneNumber] = struct{}{}
}

// MerchantUserAccountPhoneNumberCleared returns if the "merchant_user_account_phone_number" field was cleared in this mutation.
func (m *PaymentEWalletDetailMutation) MerchantUserAccountPhoneNumberCleared() bool {
	_, ok := m.clearedFields[paymentewalletdetail.FieldMerchantUserAccountPhoneNumber]
	return ok
}

// ResetMerchantUserAccountPhoneNumber resets all changes to the "merchant_user_account_phone_number" field.
func (m *PaymentEWalletDetailMutation) ResetMerchantUserAccountPhoneNumber() {
	m.merchant_user_account_phone_number = nil
	delete(m.clearedFields, paymentewalletdetail.FieldMerchantUserAccountPhoneNumber)
}

// SetMerchantUserAccountName sets the "merchant_user_account_name" field.
func (m *PaymentEWalletDetailMutation) SetMerchantUserAccountName(s string) {
	m.merchant_user_account_name = &s
}

// MerchantUserAccountName returns the value of the "merchant_user_account_name" field in the mutation.
func (m *PaymentEWalletDetailMutation) MerchantUserAccountName() (r string, exists bool) {
	v := m.merchant_user_account_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantUserAccountName returns the old "merchant_user_account_name" field's value of the PaymentEWalletDetail entity.
// If the PaymentEWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentEWalletDetailMutation) OldMerchantUserAccountName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantUserAccountName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantUserAccountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantUserAccountName: %w", err)
	}
	return oldValue.MerchantUserAccountName, nil
}

// ClearMerchantUserAccountName clears the value of the "merchant_user_account_name" field.
func (m *PaymentEWalletDetailMutation) ClearMerchantUserAccountName() {
	m.merchant_user_account_name = nil
	m.clearedFields[paymentewalletdetail.FieldMerchantUserAccountName] = struct{}{}
}

// MerchantUserAccountNameCleared returns if the "merchant_user_account_name" field was cleared in this mutation.
func (m *PaymentEWalletDetailMutation) MerchantUserAccountNameCleared() bool {
	_, ok := m.clearedFields[paymentewalletdetail.FieldMerchantUserAccountName]
	return ok
}

// ResetMerchantUserAccountName resets all changes to the "merchant_user_account_name" field.
func (m *PaymentEWalletDetailMutation) ResetMerchantUserAccountName() {
	m.merchant_user_account_name = nil
	delete(m.clearedFields, paymentewalletdetail.FieldMerchantUserAccountName)
}

// SetSystemAccountPhoneNumber sets the "system_account_phone_number" field.
func (m *PaymentEWalletDetailMutation) SetSystemAccountPhoneNumber(s string) {
	m.system_account_phone_number = &s
}

// SystemAccountPhoneNumber returns the value of the "system_account_phone_number" field in the mutation.
func (m *PaymentEWalletDetailMutation) SystemAccountPhoneNumber() (r string, exists bool) {
	v := m.system_account_phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemAccountPhoneNumber returns the old "system_account_phone_number" field's value of the PaymentEWalletDetail entity.
// If the PaymentEWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentEWalletDetailMutation) OldSystemAccountPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSystemAccountPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSystemAccountPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemAccountPhoneNumber: %w", err)
	}
	return oldValue.SystemAccountPhoneNumber, nil
}

// ClearSystemAccountPhoneNumber clears the value of the "system_account_phone_number" field.
func (m *PaymentEWalletDetailMutation) ClearSystemAccountPhoneNumber() {
	m.system_account_phone_number = nil
	m.clearedFields[paymentewalletdetail.FieldSystemAccountPhoneNumber] = struct{}{}
}

// SystemAccountPhoneNumberCleared returns if the "system_account_phone_number" field was cleared in this mutation.
func (m *PaymentEWalletDetailMutation) SystemAccountPhoneNumberCleared() bool {
	_, ok := m.clearedFields[paymentewalletdetail.FieldSystemAccountPhoneNumber]
	return ok
}

// ResetSystemAccountPhoneNumber resets all changes to the "system_account_phone_number" field.
func (m *PaymentEWalletDetailMutation) ResetSystemAccountPhoneNumber() {
	m.system_account_phone_number = nil
	delete(m.clearedFields, paymentewalletdetail.FieldSystemAccountPhoneNumber)
}

// SetSystemAccountName sets the "system_account_name" field.
func (m *PaymentEWalletDetailMutation) SetSystemAccountName(s string) {
	m.system_account_name = &s
}

// SystemAccountName returns the value of the "system_account_name" field in the mutation.
func (m *PaymentEWalletDetailMutation) SystemAccountName() (r string, exists bool) {
	v := m.system_account_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemAccountName returns the old "system_account_name" field's value of the PaymentEWalletDetail entity.
// If the PaymentEWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentEWalletDetailMutation) OldSystemAccountName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSystemAccountName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSystemAccountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemAccountName: %w", err)
	}
	return oldValue.SystemAccountName, nil
}

// ClearSystemAccountName clears the value of the "system_account_name" field.
func (m *PaymentEWalletDetailMutation) ClearSystemAccountName() {
	m.system_account_name = nil
	m.clearedFields[paymentewalletdetail.FieldSystemAccountName] = struct{}{}
}

// SystemAccountNameCleared returns if the "system_account_name" field was cleared in this mutation.
func (m *PaymentEWalletDetailMutation) SystemAccountNameCleared() bool {
	_, ok := m.clearedFields[paymentewalletdetail.FieldSystemAccountName]
	return ok
}

// ResetSystemAccountName resets all changes to the "system_account_name" field.
func (m *PaymentEWalletDetailMutation) ResetSystemAccountName() {
	m.system_account_name = nil
	delete(m.clearedFields, paymentewalletdetail.FieldSystemAccountName)
}

// SetAmount sets the "amount" field.
func (m *PaymentEWalletDetailMutation) SetAmount(u uint64) {
	m.amount = &u
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentEWalletDetailMutation) Amount() (r uint64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the PaymentEWalletDetail entity.
// If the PaymentEWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentEWalletDetailMutation) OldAmount(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds u to the "amount" field.
func (m *PaymentEWalletDetailMutation) AddAmount(u uint64) {
	if m.addamount != nil {
		*m.addamount += u
	} else {
		m.addamount = &u
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentEWalletDetailMutation) AddedAmount() (r uint64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *PaymentEWalletDetailMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[paymentewalletdetail.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *PaymentEWalletDetailMutation) AmountCleared() bool {
	_, ok := m.clearedFields[paymentewalletdetail.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentEWalletDetailMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, paymentewalletdetail.FieldAmount)
}

// SetFee sets the "fee" field.
func (m *PaymentEWalletDetailMutation) SetFee(u uint64) {
	m.fee = &u
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *PaymentEWalletDetailMutation) Fee() (r uint64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the PaymentEWalletDetail entity.
// If the PaymentEWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentEWalletDetailMutation) OldFee(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds u to the "fee" field.
func (m *PaymentEWalletDetailMutation) AddFee(u uint64) {
	if m.addfee != nil {
		*m.addfee += u
	} else {
		m.addfee = &u
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *PaymentEWalletDetailMutation) AddedFee() (r uint64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *PaymentEWalletDetailMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[paymentewalletdetail.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *PaymentEWalletDetailMutation) FeeCleared() bool {
	_, ok := m.clearedFields[paymentewalletdetail.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *PaymentEWalletDetailMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, paymentewalletdetail.FieldFee)
}

// SetNote sets the "note" field.
func (m *PaymentEWalletDetailMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *PaymentEWalletDetailMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the PaymentEWalletDetail entity.
// If the PaymentEWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentEWalletDetailMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *PaymentEWalletDetailMutation) ClearNote() {
	m.note = nil
	m.clearedFields[paymentewalletdetail.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *PaymentEWalletDetailMutation) NoteCleared() bool {
	_, ok := m.clearedFields[paymentewalletdetail.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *PaymentEWalletDetailMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, paymentewalletdetail.FieldNote)
}

// SetImageURL sets the "image_url" field.
func (m *PaymentEWalletDetailMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *PaymentEWalletDetailMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the PaymentEWalletDetail entity.
// If the PaymentEWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentEWalletDetailMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *PaymentEWalletDetailMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[paymentewalletdetail.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *PaymentEWalletDetailMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[paymentewalletdetail.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *PaymentEWalletDetailMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, paymentewalletdetail.FieldImageURL)
}

// SetTxID sets the "tx_id" field.
func (m *PaymentEWalletDetailMutation) SetTxID(s string) {
	m.tx_id = &s
}

// TxID returns the value of the "tx_id" field in the mutation.
func (m *PaymentEWalletDetailMutation) TxID() (r string, exists bool) {
	v := m.tx_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTxID returns the old "tx_id" field's value of the PaymentEWalletDetail entity.
// If the PaymentEWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentEWalletDetailMutation) OldTxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxID: %w", err)
	}
	return oldValue.TxID, nil
}

// ClearTxID clears the value of the "tx_id" field.
func (m *PaymentEWalletDetailMutation) ClearTxID() {
	m.tx_id = nil
	m.clearedFields[paymentewalletdetail.FieldTxID] = struct{}{}
}

// TxIDCleared returns if the "tx_id" field was cleared in this mutation.
func (m *PaymentEWalletDetailMutation) TxIDCleared() bool {
	_, ok := m.clearedFields[paymentewalletdetail.FieldTxID]
	return ok
}

// ResetTxID resets all changes to the "tx_id" field.
func (m *PaymentEWalletDetailMutation) ResetTxID() {
	m.tx_id = nil
	delete(m.clearedFields, paymentewalletdetail.FieldTxID)
}

// SetPaymentID sets the "payment" edge to the Payment entity by id.
func (m *PaymentEWalletDetailMutation) SetPaymentID(id int64) {
	m.payment = &id
}

// ClearPayment clears the "payment" edge to the Payment entity.
func (m *PaymentEWalletDetailMutation) ClearPayment() {
	m.clearedpayment = true
}

// PaymentCleared reports if the "payment" edge to the Payment entity was cleared.
func (m *PaymentEWalletDetailMutation) PaymentCleared() bool {
	return m.clearedpayment
}

// PaymentID returns the "payment" edge ID in the mutation.
func (m *PaymentEWalletDetailMutation) PaymentID() (id int64, exists bool) {
	if m.payment != nil {
		return *m.payment, true
	}
	return
}

// PaymentIDs returns the "payment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentID instead. It exists only for internal usage by the builders.
func (m *PaymentEWalletDetailMutation) PaymentIDs() (ids []int64) {
	if id := m.payment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPayment resets all changes to the "payment" edge.
func (m *PaymentEWalletDetailMutation) ResetPayment() {
	m.payment = nil
	m.clearedpayment = false
}

// Where appends a list predicates to the PaymentEWalletDetailMutation builder.
func (m *PaymentEWalletDetailMutation) Where(ps ...predicate.PaymentEWalletDetail) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PaymentEWalletDetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PaymentEWalletDetail).
func (m *PaymentEWalletDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentEWalletDetailMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, paymentewalletdetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, paymentewalletdetail.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, paymentewalletdetail.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, paymentewalletdetail.FieldUpdatedBy)
	}
	if m.payment_code != nil {
		fields = append(fields, paymentewalletdetail.FieldPaymentCode)
	}
	if m.merchant_user_id != nil {
		fields = append(fields, paymentewalletdetail.FieldMerchantUserID)
	}
	if m.e_wallet_name != nil {
		fields = append(fields, paymentewalletdetail.FieldEWalletName)
	}
	if m.merchant_user_account_phone_number != nil {
		fields = append(fields, paymentewalletdetail.FieldMerchantUserAccountPhoneNumber)
	}
	if m.merchant_user_account_name != nil {
		fields = append(fields, paymentewalletdetail.FieldMerchantUserAccountName)
	}
	if m.system_account_phone_number != nil {
		fields = append(fields, paymentewalletdetail.FieldSystemAccountPhoneNumber)
	}
	if m.system_account_name != nil {
		fields = append(fields, paymentewalletdetail.FieldSystemAccountName)
	}
	if m.amount != nil {
		fields = append(fields, paymentewalletdetail.FieldAmount)
	}
	if m.fee != nil {
		fields = append(fields, paymentewalletdetail.FieldFee)
	}
	if m.note != nil {
		fields = append(fields, paymentewalletdetail.FieldNote)
	}
	if m.image_url != nil {
		fields = append(fields, paymentewalletdetail.FieldImageURL)
	}
	if m.tx_id != nil {
		fields = append(fields, paymentewalletdetail.FieldTxID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentEWalletDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentewalletdetail.FieldCreatedAt:
		return m.CreatedAt()
	case paymentewalletdetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case paymentewalletdetail.FieldCreatedBy:
		return m.CreatedBy()
	case paymentewalletdetail.FieldUpdatedBy:
		return m.UpdatedBy()
	case paymentewalletdetail.FieldPaymentCode:
		return m.PaymentCode()
	case paymentewalletdetail.FieldMerchantUserID:
		return m.MerchantUserID()
	case paymentewalletdetail.FieldEWalletName:
		return m.EWalletName()
	case paymentewalletdetail.FieldMerchantUserAccountPhoneNumber:
		return m.MerchantUserAccountPhoneNumber()
	case paymentewalletdetail.FieldMerchantUserAccountName:
		return m.MerchantUserAccountName()
	case paymentewalletdetail.FieldSystemAccountPhoneNumber:
		return m.SystemAccountPhoneNumber()
	case paymentewalletdetail.FieldSystemAccountName:
		return m.SystemAccountName()
	case paymentewalletdetail.FieldAmount:
		return m.Amount()
	case paymentewalletdetail.FieldFee:
		return m.Fee()
	case paymentewalletdetail.FieldNote:
		return m.Note()
	case paymentewalletdetail.FieldImageURL:
		return m.ImageURL()
	case paymentewalletdetail.FieldTxID:
		return m.TxID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentEWalletDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentewalletdetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case paymentewalletdetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case paymentewalletdetail.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case paymentewalletdetail.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case paymentewalletdetail.FieldPaymentCode:
		return m.OldPaymentCode(ctx)
	case paymentewalletdetail.FieldMerchantUserID:
		return m.OldMerchantUserID(ctx)
	case paymentewalletdetail.FieldEWalletName:
		return m.OldEWalletName(ctx)
	case paymentewalletdetail.FieldMerchantUserAccountPhoneNumber:
		return m.OldMerchantUserAccountPhoneNumber(ctx)
	case paymentewalletdetail.FieldMerchantUserAccountName:
		return m.OldMerchantUserAccountName(ctx)
	case paymentewalletdetail.FieldSystemAccountPhoneNumber:
		return m.OldSystemAccountPhoneNumber(ctx)
	case paymentewalletdetail.FieldSystemAccountName:
		return m.OldSystemAccountName(ctx)
	case paymentewalletdetail.FieldAmount:
		return m.OldAmount(ctx)
	case paymentewalletdetail.FieldFee:
		return m.OldFee(ctx)
	case paymentewalletdetail.FieldNote:
		return m.OldNote(ctx)
	case paymentewalletdetail.FieldImageURL:
		return m.OldImageURL(ctx)
	case paymentewalletdetail.FieldTxID:
		return m.OldTxID(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentEWalletDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentEWalletDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentewalletdetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case paymentewalletdetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case paymentewalletdetail.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case paymentewalletdetail.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case paymentewalletdetail.FieldPaymentCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentCode(v)
		return nil
	case paymentewalletdetail.FieldMerchantUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantUserID(v)
		return nil
	case paymentewalletdetail.FieldEWalletName:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEWalletName(v)
		return nil
	case paymentewalletdetail.FieldMerchantUserAccountPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantUserAccountPhoneNumber(v)
		return nil
	case paymentewalletdetail.FieldMerchantUserAccountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantUserAccountName(v)
		return nil
	case paymentewalletdetail.FieldSystemAccountPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemAccountPhoneNumber(v)
		return nil
	case paymentewalletdetail.FieldSystemAccountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemAccountName(v)
		return nil
	case paymentewalletdetail.FieldAmount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case paymentewalletdetail.FieldFee:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case paymentewalletdetail.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case paymentewalletdetail.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case paymentewalletdetail.FieldTxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxID(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentEWalletDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentEWalletDetailMutation) AddedFields() []string {
	var fields []string
	if m.addmerchant_user_id != nil {
		fields = append(fields, paymentewalletdetail.FieldMerchantUserID)
	}
	if m.adde_wallet_name != nil {
		fields = append(fields, paymentewalletdetail.FieldEWalletName)
	}
	if m.addamount != nil {
		fields = append(fields, paymentewalletdetail.FieldAmount)
	}
	if m.addfee != nil {
		fields = append(fields, paymentewalletdetail.FieldFee)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentEWalletDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymentewalletdetail.FieldMerchantUserID:
		return m.AddedMerchantUserID()
	case paymentewalletdetail.FieldEWalletName:
		return m.AddedEWalletName()
	case paymentewalletdetail.FieldAmount:
		return m.AddedAmount()
	case paymentewalletdetail.FieldFee:
		return m.AddedFee()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentEWalletDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymentewalletdetail.FieldMerchantUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMerchantUserID(v)
		return nil
	case paymentewalletdetail.FieldEWalletName:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEWalletName(v)
		return nil
	case paymentewalletdetail.FieldAmount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case paymentewalletdetail.FieldFee:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentEWalletDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentEWalletDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymentewalletdetail.FieldPaymentCode) {
		fields = append(fields, paymentewalletdetail.FieldPaymentCode)
	}
	if m.FieldCleared(paymentewalletdetail.FieldMerchantUserID) {
		fields = append(fields, paymentewalletdetail.FieldMerchantUserID)
	}
	if m.FieldCleared(paymentewalletdetail.FieldEWalletName) {
		fields = append(fields, paymentewalletdetail.FieldEWalletName)
	}
	if m.FieldCleared(paymentewalletdetail.FieldMerchantUserAccountPhoneNumber) {
		fields = append(fields, paymentewalletdetail.FieldMerchantUserAccountPhoneNumber)
	}
	if m.FieldCleared(paymentewalletdetail.FieldMerchantUserAccountName) {
		fields = append(fields, paymentewalletdetail.FieldMerchantUserAccountName)
	}
	if m.FieldCleared(paymentewalletdetail.FieldSystemAccountPhoneNumber) {
		fields = append(fields, paymentewalletdetail.FieldSystemAccountPhoneNumber)
	}
	if m.FieldCleared(paymentewalletdetail.FieldSystemAccountName) {
		fields = append(fields, paymentewalletdetail.FieldSystemAccountName)
	}
	if m.FieldCleared(paymentewalletdetail.FieldAmount) {
		fields = append(fields, paymentewalletdetail.FieldAmount)
	}
	if m.FieldCleared(paymentewalletdetail.FieldFee) {
		fields = append(fields, paymentewalletdetail.FieldFee)
	}
	if m.FieldCleared(paymentewalletdetail.FieldNote) {
		fields = append(fields, paymentewalletdetail.FieldNote)
	}
	if m.FieldCleared(paymentewalletdetail.FieldImageURL) {
		fields = append(fields, paymentewalletdetail.FieldImageURL)
	}
	if m.FieldCleared(paymentewalletdetail.FieldTxID) {
		fields = append(fields, paymentewalletdetail.FieldTxID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentEWalletDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentEWalletDetailMutation) ClearField(name string) error {
	switch name {
	case paymentewalletdetail.FieldPaymentCode:
		m.ClearPaymentCode()
		return nil
	case paymentewalletdetail.FieldMerchantUserID:
		m.ClearMerchantUserID()
		return nil
	case paymentewalletdetail.FieldEWalletName:
		m.ClearEWalletName()
		return nil
	case paymentewalletdetail.FieldMerchantUserAccountPhoneNumber:
		m.ClearMerchantUserAccountPhoneNumber()
		return nil
	case paymentewalletdetail.FieldMerchantUserAccountName:
		m.ClearMerchantUserAccountName()
		return nil
	case paymentewalletdetail.FieldSystemAccountPhoneNumber:
		m.ClearSystemAccountPhoneNumber()
		return nil
	case paymentewalletdetail.FieldSystemAccountName:
		m.ClearSystemAccountName()
		return nil
	case paymentewalletdetail.FieldAmount:
		m.ClearAmount()
		return nil
	case paymentewalletdetail.FieldFee:
		m.ClearFee()
		return nil
	case paymentewalletdetail.FieldNote:
		m.ClearNote()
		return nil
	case paymentewalletdetail.FieldImageURL:
		m.ClearImageURL()
		return nil
	case paymentewalletdetail.FieldTxID:
		m.ClearTxID()
		return nil
	}
	return fmt.Errorf("unknown PaymentEWalletDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentEWalletDetailMutation) ResetField(name string) error {
	switch name {
	case paymentewalletdetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case paymentewalletdetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case paymentewalletdetail.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case paymentewalletdetail.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case paymentewalletdetail.FieldPaymentCode:
		m.ResetPaymentCode()
		return nil
	case paymentewalletdetail.FieldMerchantUserID:
		m.ResetMerchantUserID()
		return nil
	case paymentewalletdetail.FieldEWalletName:
		m.ResetEWalletName()
		return nil
	case paymentewalletdetail.FieldMerchantUserAccountPhoneNumber:
		m.ResetMerchantUserAccountPhoneNumber()
		return nil
	case paymentewalletdetail.FieldMerchantUserAccountName:
		m.ResetMerchantUserAccountName()
		return nil
	case paymentewalletdetail.FieldSystemAccountPhoneNumber:
		m.ResetSystemAccountPhoneNumber()
		return nil
	case paymentewalletdetail.FieldSystemAccountName:
		m.ResetSystemAccountName()
		return nil
	case paymentewalletdetail.FieldAmount:
		m.ResetAmount()
		return nil
	case paymentewalletdetail.FieldFee:
		m.ResetFee()
		return nil
	case paymentewalletdetail.FieldNote:
		m.ResetNote()
		return nil
	case paymentewalletdetail.FieldImageURL:
		m.ResetImageURL()
		return nil
	case paymentewalletdetail.FieldTxID:
		m.ResetTxID()
		return nil
	}
	return fmt.Errorf("unknown PaymentEWalletDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentEWalletDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.payment != nil {
		edges = append(edges, paymentewalletdetail.EdgePayment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentEWalletDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymentewalletdetail.EdgePayment:
		if id := m.payment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentEWalletDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentEWalletDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentEWalletDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpayment {
		edges = append(edges, paymentewalletdetail.EdgePayment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentEWalletDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case paymentewalletdetail.EdgePayment:
		return m.clearedpayment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentEWalletDetailMutation) ClearEdge(name string) error {
	switch name {
	case paymentewalletdetail.EdgePayment:
		m.ClearPayment()
		return nil
	}
	return fmt.Errorf("unknown PaymentEWalletDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentEWalletDetailMutation) ResetEdge(name string) error {
	switch name {
	case paymentewalletdetail.EdgePayment:
		m.ResetPayment()
		return nil
	}
	return fmt.Errorf("unknown PaymentEWalletDetail edge %s", name)
}

// PaymentTelcoDetailMutation represents an operation that mutates the PaymentTelcoDetail nodes in the graph.
type PaymentTelcoDetailMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	updated_at        *time.Time
	created_by        *string
	updated_by        *string
	telco_name        *int32
	addtelco_name     *int32
	serial_number     *string
	card_id           *string
	charged_amount    *uint64
	addcharged_amount *uint64
	amount            *uint64
	addamount         *uint64
	clearedFields     map[string]struct{}
	payment           *int64
	clearedpayment    bool
	done              bool
	oldValue          func(context.Context) (*PaymentTelcoDetail, error)
	predicates        []predicate.PaymentTelcoDetail
}

var _ ent.Mutation = (*PaymentTelcoDetailMutation)(nil)

// paymenttelcodetailOption allows management of the mutation configuration using functional options.
type paymenttelcodetailOption func(*PaymentTelcoDetailMutation)

// newPaymentTelcoDetailMutation creates new mutation for the PaymentTelcoDetail entity.
func newPaymentTelcoDetailMutation(c config, op Op, opts ...paymenttelcodetailOption) *PaymentTelcoDetailMutation {
	m := &PaymentTelcoDetailMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentTelcoDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentTelcoDetailID sets the ID field of the mutation.
func withPaymentTelcoDetailID(id int64) paymenttelcodetailOption {
	return func(m *PaymentTelcoDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentTelcoDetail
		)
		m.oldValue = func(ctx context.Context) (*PaymentTelcoDetail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentTelcoDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentTelcoDetail sets the old PaymentTelcoDetail of the mutation.
func withPaymentTelcoDetail(node *PaymentTelcoDetail) paymenttelcodetailOption {
	return func(m *PaymentTelcoDetailMutation) {
		m.oldValue = func(context.Context) (*PaymentTelcoDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentTelcoDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentTelcoDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentTelcoDetail entities.
func (m *PaymentTelcoDetailMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentTelcoDetailMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentTelcoDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentTelcoDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentTelcoDetail entity.
// If the PaymentTelcoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTelcoDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentTelcoDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentTelcoDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentTelcoDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PaymentTelcoDetail entity.
// If the PaymentTelcoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTelcoDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentTelcoDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PaymentTelcoDetailMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PaymentTelcoDetailMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PaymentTelcoDetail entity.
// If the PaymentTelcoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTelcoDetailMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PaymentTelcoDetailMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PaymentTelcoDetailMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PaymentTelcoDetailMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PaymentTelcoDetail entity.
// If the PaymentTelcoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTelcoDetailMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PaymentTelcoDetailMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetTelcoName sets the "telco_name" field.
func (m *PaymentTelcoDetailMutation) SetTelcoName(i int32) {
	m.telco_name = &i
	m.addtelco_name = nil
}

// TelcoName returns the value of the "telco_name" field in the mutation.
func (m *PaymentTelcoDetailMutation) TelcoName() (r int32, exists bool) {
	v := m.telco_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTelcoName returns the old "telco_name" field's value of the PaymentTelcoDetail entity.
// If the PaymentTelcoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTelcoDetailMutation) OldTelcoName(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTelcoName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTelcoName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelcoName: %w", err)
	}
	return oldValue.TelcoName, nil
}

// AddTelcoName adds i to the "telco_name" field.
func (m *PaymentTelcoDetailMutation) AddTelcoName(i int32) {
	if m.addtelco_name != nil {
		*m.addtelco_name += i
	} else {
		m.addtelco_name = &i
	}
}

// AddedTelcoName returns the value that was added to the "telco_name" field in this mutation.
func (m *PaymentTelcoDetailMutation) AddedTelcoName() (r int32, exists bool) {
	v := m.addtelco_name
	if v == nil {
		return
	}
	return *v, true
}

// ResetTelcoName resets all changes to the "telco_name" field.
func (m *PaymentTelcoDetailMutation) ResetTelcoName() {
	m.telco_name = nil
	m.addtelco_name = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *PaymentTelcoDetailMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *PaymentTelcoDetailMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the PaymentTelcoDetail entity.
// If the PaymentTelcoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTelcoDetailMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *PaymentTelcoDetailMutation) ResetSerialNumber() {
	m.serial_number = nil
}

// SetCardID sets the "card_id" field.
func (m *PaymentTelcoDetailMutation) SetCardID(s string) {
	m.card_id = &s
}

// CardID returns the value of the "card_id" field in the mutation.
func (m *PaymentTelcoDetailMutation) CardID() (r string, exists bool) {
	v := m.card_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCardID returns the old "card_id" field's value of the PaymentTelcoDetail entity.
// If the PaymentTelcoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTelcoDetailMutation) OldCardID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCardID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCardID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardID: %w", err)
	}
	return oldValue.CardID, nil
}

// ResetCardID resets all changes to the "card_id" field.
func (m *PaymentTelcoDetailMutation) ResetCardID() {
	m.card_id = nil
}

// SetChargedAmount sets the "charged_amount" field.
func (m *PaymentTelcoDetailMutation) SetChargedAmount(u uint64) {
	m.charged_amount = &u
	m.addcharged_amount = nil
}

// ChargedAmount returns the value of the "charged_amount" field in the mutation.
func (m *PaymentTelcoDetailMutation) ChargedAmount() (r uint64, exists bool) {
	v := m.charged_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldChargedAmount returns the old "charged_amount" field's value of the PaymentTelcoDetail entity.
// If the PaymentTelcoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTelcoDetailMutation) OldChargedAmount(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldChargedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldChargedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargedAmount: %w", err)
	}
	return oldValue.ChargedAmount, nil
}

// AddChargedAmount adds u to the "charged_amount" field.
func (m *PaymentTelcoDetailMutation) AddChargedAmount(u uint64) {
	if m.addcharged_amount != nil {
		*m.addcharged_amount += u
	} else {
		m.addcharged_amount = &u
	}
}

// AddedChargedAmount returns the value that was added to the "charged_amount" field in this mutation.
func (m *PaymentTelcoDetailMutation) AddedChargedAmount() (r uint64, exists bool) {
	v := m.addcharged_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetChargedAmount resets all changes to the "charged_amount" field.
func (m *PaymentTelcoDetailMutation) ResetChargedAmount() {
	m.charged_amount = nil
	m.addcharged_amount = nil
}

// SetAmount sets the "amount" field.
func (m *PaymentTelcoDetailMutation) SetAmount(u uint64) {
	m.amount = &u
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentTelcoDetailMutation) Amount() (r uint64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the PaymentTelcoDetail entity.
// If the PaymentTelcoDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTelcoDetailMutation) OldAmount(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds u to the "amount" field.
func (m *PaymentTelcoDetailMutation) AddAmount(u uint64) {
	if m.addamount != nil {
		*m.addamount += u
	} else {
		m.addamount = &u
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentTelcoDetailMutation) AddedAmount() (r uint64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentTelcoDetailMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPaymentID sets the "payment" edge to the Payment entity by id.
func (m *PaymentTelcoDetailMutation) SetPaymentID(id int64) {
	m.payment = &id
}

// ClearPayment clears the "payment" edge to the Payment entity.
func (m *PaymentTelcoDetailMutation) ClearPayment() {
	m.clearedpayment = true
}

// PaymentCleared reports if the "payment" edge to the Payment entity was cleared.
func (m *PaymentTelcoDetailMutation) PaymentCleared() bool {
	return m.clearedpayment
}

// PaymentID returns the "payment" edge ID in the mutation.
func (m *PaymentTelcoDetailMutation) PaymentID() (id int64, exists bool) {
	if m.payment != nil {
		return *m.payment, true
	}
	return
}

// PaymentIDs returns the "payment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentID instead. It exists only for internal usage by the builders.
func (m *PaymentTelcoDetailMutation) PaymentIDs() (ids []int64) {
	if id := m.payment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPayment resets all changes to the "payment" edge.
func (m *PaymentTelcoDetailMutation) ResetPayment() {
	m.payment = nil
	m.clearedpayment = false
}

// Where appends a list predicates to the PaymentTelcoDetailMutation builder.
func (m *PaymentTelcoDetailMutation) Where(ps ...predicate.PaymentTelcoDetail) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PaymentTelcoDetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PaymentTelcoDetail).
func (m *PaymentTelcoDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentTelcoDetailMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, paymenttelcodetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, paymenttelcodetail.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, paymenttelcodetail.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, paymenttelcodetail.FieldUpdatedBy)
	}
	if m.telco_name != nil {
		fields = append(fields, paymenttelcodetail.FieldTelcoName)
	}
	if m.serial_number != nil {
		fields = append(fields, paymenttelcodetail.FieldSerialNumber)
	}
	if m.card_id != nil {
		fields = append(fields, paymenttelcodetail.FieldCardID)
	}
	if m.charged_amount != nil {
		fields = append(fields, paymenttelcodetail.FieldChargedAmount)
	}
	if m.amount != nil {
		fields = append(fields, paymenttelcodetail.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentTelcoDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymenttelcodetail.FieldCreatedAt:
		return m.CreatedAt()
	case paymenttelcodetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case paymenttelcodetail.FieldCreatedBy:
		return m.CreatedBy()
	case paymenttelcodetail.FieldUpdatedBy:
		return m.UpdatedBy()
	case paymenttelcodetail.FieldTelcoName:
		return m.TelcoName()
	case paymenttelcodetail.FieldSerialNumber:
		return m.SerialNumber()
	case paymenttelcodetail.FieldCardID:
		return m.CardID()
	case paymenttelcodetail.FieldChargedAmount:
		return m.ChargedAmount()
	case paymenttelcodetail.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentTelcoDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymenttelcodetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case paymenttelcodetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case paymenttelcodetail.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case paymenttelcodetail.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case paymenttelcodetail.FieldTelcoName:
		return m.OldTelcoName(ctx)
	case paymenttelcodetail.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case paymenttelcodetail.FieldCardID:
		return m.OldCardID(ctx)
	case paymenttelcodetail.FieldChargedAmount:
		return m.OldChargedAmount(ctx)
	case paymenttelcodetail.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentTelcoDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentTelcoDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymenttelcodetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case paymenttelcodetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case paymenttelcodetail.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case paymenttelcodetail.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case paymenttelcodetail.FieldTelcoName:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelcoName(v)
		return nil
	case paymenttelcodetail.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case paymenttelcodetail.FieldCardID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardID(v)
		return nil
	case paymenttelcodetail.FieldChargedAmount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargedAmount(v)
		return nil
	case paymenttelcodetail.FieldAmount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentTelcoDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentTelcoDetailMutation) AddedFields() []string {
	var fields []string
	if m.addtelco_name != nil {
		fields = append(fields, paymenttelcodetail.FieldTelcoName)
	}
	if m.addcharged_amount != nil {
		fields = append(fields, paymenttelcodetail.FieldChargedAmount)
	}
	if m.addamount != nil {
		fields = append(fields, paymenttelcodetail.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentTelcoDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymenttelcodetail.FieldTelcoName:
		return m.AddedTelcoName()
	case paymenttelcodetail.FieldChargedAmount:
		return m.AddedChargedAmount()
	case paymenttelcodetail.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentTelcoDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymenttelcodetail.FieldTelcoName:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTelcoName(v)
		return nil
	case paymenttelcodetail.FieldChargedAmount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChargedAmount(v)
		return nil
	case paymenttelcodetail.FieldAmount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentTelcoDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentTelcoDetailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentTelcoDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentTelcoDetailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PaymentTelcoDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentTelcoDetailMutation) ResetField(name string) error {
	switch name {
	case paymenttelcodetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case paymenttelcodetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case paymenttelcodetail.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case paymenttelcodetail.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case paymenttelcodetail.FieldTelcoName:
		m.ResetTelcoName()
		return nil
	case paymenttelcodetail.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case paymenttelcodetail.FieldCardID:
		m.ResetCardID()
		return nil
	case paymenttelcodetail.FieldChargedAmount:
		m.ResetChargedAmount()
		return nil
	case paymenttelcodetail.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown PaymentTelcoDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentTelcoDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.payment != nil {
		edges = append(edges, paymenttelcodetail.EdgePayment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentTelcoDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymenttelcodetail.EdgePayment:
		if id := m.payment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentTelcoDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentTelcoDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentTelcoDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpayment {
		edges = append(edges, paymenttelcodetail.EdgePayment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentTelcoDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case paymenttelcodetail.EdgePayment:
		return m.clearedpayment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentTelcoDetailMutation) ClearEdge(name string) error {
	switch name {
	case paymenttelcodetail.EdgePayment:
		m.ClearPayment()
		return nil
	}
	return fmt.Errorf("unknown PaymentTelcoDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentTelcoDetailMutation) ResetEdge(name string) error {
	switch name {
	case paymenttelcodetail.EdgePayment:
		m.ResetPayment()
		return nil
	}
	return fmt.Errorf("unknown PaymentTelcoDetail edge %s", name)
}

// RevisionMutation represents an operation that mutates the Revision nodes in the graph.
type RevisionMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	created_by     *string
	updated_by     *string
	status         *int32
	addstatus      *int32
	note           *string
	clearedFields  map[string]struct{}
	payment        *int64
	clearedpayment bool
	done           bool
	oldValue       func(context.Context) (*Revision, error)
	predicates     []predicate.Revision
}

var _ ent.Mutation = (*RevisionMutation)(nil)

// revisionOption allows management of the mutation configuration using functional options.
type revisionOption func(*RevisionMutation)

// newRevisionMutation creates new mutation for the Revision entity.
func newRevisionMutation(c config, op Op, opts ...revisionOption) *RevisionMutation {
	m := &RevisionMutation{
		config:        c,
		op:            op,
		typ:           TypeRevision,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRevisionID sets the ID field of the mutation.
func withRevisionID(id int64) revisionOption {
	return func(m *RevisionMutation) {
		var (
			err   error
			once  sync.Once
			value *Revision
		)
		m.oldValue = func(ctx context.Context) (*Revision, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Revision.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRevision sets the old Revision of the mutation.
func withRevision(node *Revision) revisionOption {
	return func(m *RevisionMutation) {
		m.oldValue = func(context.Context) (*Revision, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RevisionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RevisionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Revision entities.
func (m *RevisionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RevisionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *RevisionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RevisionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RevisionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RevisionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RevisionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RevisionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RevisionMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RevisionMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RevisionMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RevisionMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RevisionMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RevisionMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetStatus sets the "status" field.
func (m *RevisionMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RevisionMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *RevisionMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RevisionMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *RevisionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetNote sets the "note" field.
func (m *RevisionMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *RevisionMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote resets all changes to the "note" field.
func (m *RevisionMutation) ResetNote() {
	m.note = nil
}

// SetPaymentID sets the "payment" edge to the Payment entity by id.
func (m *RevisionMutation) SetPaymentID(id int64) {
	m.payment = &id
}

// ClearPayment clears the "payment" edge to the Payment entity.
func (m *RevisionMutation) ClearPayment() {
	m.clearedpayment = true
}

// PaymentCleared reports if the "payment" edge to the Payment entity was cleared.
func (m *RevisionMutation) PaymentCleared() bool {
	return m.clearedpayment
}

// PaymentID returns the "payment" edge ID in the mutation.
func (m *RevisionMutation) PaymentID() (id int64, exists bool) {
	if m.payment != nil {
		return *m.payment, true
	}
	return
}

// PaymentIDs returns the "payment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentID instead. It exists only for internal usage by the builders.
func (m *RevisionMutation) PaymentIDs() (ids []int64) {
	if id := m.payment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPayment resets all changes to the "payment" edge.
func (m *RevisionMutation) ResetPayment() {
	m.payment = nil
	m.clearedpayment = false
}

// Where appends a list predicates to the RevisionMutation builder.
func (m *RevisionMutation) Where(ps ...predicate.Revision) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RevisionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Revision).
func (m *RevisionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RevisionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, revision.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, revision.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, revision.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, revision.FieldUpdatedBy)
	}
	if m.status != nil {
		fields = append(fields, revision.FieldStatus)
	}
	if m.note != nil {
		fields = append(fields, revision.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RevisionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case revision.FieldCreatedAt:
		return m.CreatedAt()
	case revision.FieldUpdatedAt:
		return m.UpdatedAt()
	case revision.FieldCreatedBy:
		return m.CreatedBy()
	case revision.FieldUpdatedBy:
		return m.UpdatedBy()
	case revision.FieldStatus:
		return m.Status()
	case revision.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RevisionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case revision.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case revision.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case revision.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case revision.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case revision.FieldStatus:
		return m.OldStatus(ctx)
	case revision.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown Revision field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevisionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case revision.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case revision.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case revision.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case revision.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case revision.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case revision.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown Revision field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RevisionMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, revision.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RevisionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case revision.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevisionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case revision.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Revision numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RevisionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RevisionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RevisionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Revision nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RevisionMutation) ResetField(name string) error {
	switch name {
	case revision.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case revision.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case revision.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case revision.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case revision.FieldStatus:
		m.ResetStatus()
		return nil
	case revision.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown Revision field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RevisionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.payment != nil {
		edges = append(edges, revision.EdgePayment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RevisionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case revision.EdgePayment:
		if id := m.payment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RevisionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RevisionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RevisionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpayment {
		edges = append(edges, revision.EdgePayment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RevisionMutation) EdgeCleared(name string) bool {
	switch name {
	case revision.EdgePayment:
		return m.clearedpayment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RevisionMutation) ClearEdge(name string) error {
	switch name {
	case revision.EdgePayment:
		m.ClearPayment()
		return nil
	}
	return fmt.Errorf("unknown Revision unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RevisionMutation) ResetEdge(name string) error {
	switch name {
	case revision.EdgePayment:
		m.ResetPayment()
		return nil
	}
	return fmt.Errorf("unknown Revision edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	_type         *string
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id int64) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Setting entities.
func (m *SettingMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *SettingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SettingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SettingMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *SettingMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SettingMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SettingMutation) ResetType() {
	m._type = nil
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, setting.FieldName)
	}
	if m._type != nil {
		fields = append(fields, setting.FieldType)
	}
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldName:
		return m.Name()
	case setting.FieldType:
		return m.GetType()
	case setting.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldName:
		return m.OldName(ctx)
	case setting.FieldType:
		return m.OldType(ctx)
	case setting.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case setting.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case setting.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldName:
		m.ResetName()
		return nil
	case setting.FieldType:
		m.ResetType()
		return nil
	case setting.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// SystemBankAccountMutation represents an operation that mutates the SystemBankAccount nodes in the graph.
type SystemBankAccountMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	merchant_id            *int64
	addmerchant_id         *int64
	status                 *int32
	addstatus              *int32
	bank_name              *int32
	addbank_name           *int32
	account_number         *string
	account_name           *string
	branch                 *string
	balance                *uint64
	addbalance             *uint64
	last_updated_balance   *time.Time
	daily_balance_limit    *uint64
	adddaily_balance_limit *uint64
	daily_used_amount      *int64
	adddaily_used_amount   *int64
	daily_balance          *uint64
	adddaily_balance       *uint64
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*SystemBankAccount, error)
	predicates             []predicate.SystemBankAccount
}

var _ ent.Mutation = (*SystemBankAccountMutation)(nil)

// systembankaccountOption allows management of the mutation configuration using functional options.
type systembankaccountOption func(*SystemBankAccountMutation)

// newSystemBankAccountMutation creates new mutation for the SystemBankAccount entity.
func newSystemBankAccountMutation(c config, op Op, opts ...systembankaccountOption) *SystemBankAccountMutation {
	m := &SystemBankAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemBankAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemBankAccountID sets the ID field of the mutation.
func withSystemBankAccountID(id int64) systembankaccountOption {
	return func(m *SystemBankAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemBankAccount
		)
		m.oldValue = func(ctx context.Context) (*SystemBankAccount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemBankAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemBankAccount sets the old SystemBankAccount of the mutation.
func withSystemBankAccount(node *SystemBankAccount) systembankaccountOption {
	return func(m *SystemBankAccountMutation) {
		m.oldValue = func(context.Context) (*SystemBankAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemBankAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemBankAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemBankAccount entities.
func (m *SystemBankAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemBankAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemBankAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemBankAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemBankAccount entity.
// If the SystemBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemBankAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemBankAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemBankAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemBankAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SystemBankAccount entity.
// If the SystemBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemBankAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemBankAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *SystemBankAccountMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SystemBankAccountMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the SystemBankAccount entity.
// If the SystemBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemBankAccountMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SystemBankAccountMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SystemBankAccountMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SystemBankAccountMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the SystemBankAccount entity.
// If the SystemBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemBankAccountMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SystemBankAccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *SystemBankAccountMutation) SetMerchantID(i int64) {
	m.merchant_id = &i
	m.addmerchant_id = nil
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *SystemBankAccountMutation) MerchantID() (r int64, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the SystemBankAccount entity.
// If the SystemBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemBankAccountMutation) OldMerchantID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// AddMerchantID adds i to the "merchant_id" field.
func (m *SystemBankAccountMutation) AddMerchantID(i int64) {
	if m.addmerchant_id != nil {
		*m.addmerchant_id += i
	} else {
		m.addmerchant_id = &i
	}
}

// AddedMerchantID returns the value that was added to the "merchant_id" field in this mutation.
func (m *SystemBankAccountMutation) AddedMerchantID() (r int64, exists bool) {
	v := m.addmerchant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *SystemBankAccountMutation) ResetMerchantID() {
	m.merchant_id = nil
	m.addmerchant_id = nil
}

// SetStatus sets the "status" field.
func (m *SystemBankAccountMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SystemBankAccountMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SystemBankAccount entity.
// If the SystemBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemBankAccountMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SystemBankAccountMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SystemBankAccountMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *SystemBankAccountMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetBankName sets the "bank_name" field.
func (m *SystemBankAccountMutation) SetBankName(i int32) {
	m.bank_name = &i
	m.addbank_name = nil
}

// BankName returns the value of the "bank_name" field in the mutation.
func (m *SystemBankAccountMutation) BankName() (r int32, exists bool) {
	v := m.bank_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBankName returns the old "bank_name" field's value of the SystemBankAccount entity.
// If the SystemBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemBankAccountMutation) OldBankName(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBankName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBankName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankName: %w", err)
	}
	return oldValue.BankName, nil
}

// AddBankName adds i to the "bank_name" field.
func (m *SystemBankAccountMutation) AddBankName(i int32) {
	if m.addbank_name != nil {
		*m.addbank_name += i
	} else {
		m.addbank_name = &i
	}
}

// AddedBankName returns the value that was added to the "bank_name" field in this mutation.
func (m *SystemBankAccountMutation) AddedBankName() (r int32, exists bool) {
	v := m.addbank_name
	if v == nil {
		return
	}
	return *v, true
}

// ResetBankName resets all changes to the "bank_name" field.
func (m *SystemBankAccountMutation) ResetBankName() {
	m.bank_name = nil
	m.addbank_name = nil
}

// SetAccountNumber sets the "account_number" field.
func (m *SystemBankAccountMutation) SetAccountNumber(s string) {
	m.account_number = &s
}

// AccountNumber returns the value of the "account_number" field in the mutation.
func (m *SystemBankAccountMutation) AccountNumber() (r string, exists bool) {
	v := m.account_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountNumber returns the old "account_number" field's value of the SystemBankAccount entity.
// If the SystemBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemBankAccountMutation) OldAccountNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccountNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccountNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountNumber: %w", err)
	}
	return oldValue.AccountNumber, nil
}

// ResetAccountNumber resets all changes to the "account_number" field.
func (m *SystemBankAccountMutation) ResetAccountNumber() {
	m.account_number = nil
}

// SetAccountName sets the "account_name" field.
func (m *SystemBankAccountMutation) SetAccountName(s string) {
	m.account_name = &s
}

// AccountName returns the value of the "account_name" field in the mutation.
func (m *SystemBankAccountMutation) AccountName() (r string, exists bool) {
	v := m.account_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountName returns the old "account_name" field's value of the SystemBankAccount entity.
// If the SystemBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemBankAccountMutation) OldAccountName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccountName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountName: %w", err)
	}
	return oldValue.AccountName, nil
}

// ResetAccountName resets all changes to the "account_name" field.
func (m *SystemBankAccountMutation) ResetAccountName() {
	m.account_name = nil
}

// SetBranch sets the "branch" field.
func (m *SystemBankAccountMutation) SetBranch(s string) {
	m.branch = &s
}

// Branch returns the value of the "branch" field in the mutation.
func (m *SystemBankAccountMutation) Branch() (r string, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranch returns the old "branch" field's value of the SystemBankAccount entity.
// If the SystemBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemBankAccountMutation) OldBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranch: %w", err)
	}
	return oldValue.Branch, nil
}

// ResetBranch resets all changes to the "branch" field.
func (m *SystemBankAccountMutation) ResetBranch() {
	m.branch = nil
}

// SetBalance sets the "balance" field.
func (m *SystemBankAccountMutation) SetBalance(u uint64) {
	m.balance = &u
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *SystemBankAccountMutation) Balance() (r uint64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the SystemBankAccount entity.
// If the SystemBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemBankAccountMutation) OldBalance(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds u to the "balance" field.
func (m *SystemBankAccountMutation) AddBalance(u uint64) {
	if m.addbalance != nil {
		*m.addbalance += u
	} else {
		m.addbalance = &u
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *SystemBankAccountMutation) AddedBalance() (r uint64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *SystemBankAccountMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetLastUpdatedBalance sets the "last_updated_balance" field.
func (m *SystemBankAccountMutation) SetLastUpdatedBalance(t time.Time) {
	m.last_updated_balance = &t
}

// LastUpdatedBalance returns the value of the "last_updated_balance" field in the mutation.
func (m *SystemBankAccountMutation) LastUpdatedBalance() (r time.Time, exists bool) {
	v := m.last_updated_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdatedBalance returns the old "last_updated_balance" field's value of the SystemBankAccount entity.
// If the SystemBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemBankAccountMutation) OldLastUpdatedBalance(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastUpdatedBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastUpdatedBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdatedBalance: %w", err)
	}
	return oldValue.LastUpdatedBalance, nil
}

// ClearLastUpdatedBalance clears the value of the "last_updated_balance" field.
func (m *SystemBankAccountMutation) ClearLastUpdatedBalance() {
	m.last_updated_balance = nil
	m.clearedFields[systembankaccount.FieldLastUpdatedBalance] = struct{}{}
}

// LastUpdatedBalanceCleared returns if the "last_updated_balance" field was cleared in this mutation.
func (m *SystemBankAccountMutation) LastUpdatedBalanceCleared() bool {
	_, ok := m.clearedFields[systembankaccount.FieldLastUpdatedBalance]
	return ok
}

// ResetLastUpdatedBalance resets all changes to the "last_updated_balance" field.
func (m *SystemBankAccountMutation) ResetLastUpdatedBalance() {
	m.last_updated_balance = nil
	delete(m.clearedFields, systembankaccount.FieldLastUpdatedBalance)
}

// SetDailyBalanceLimit sets the "daily_balance_limit" field.
func (m *SystemBankAccountMutation) SetDailyBalanceLimit(u uint64) {
	m.daily_balance_limit = &u
	m.adddaily_balance_limit = nil
}

// DailyBalanceLimit returns the value of the "daily_balance_limit" field in the mutation.
func (m *SystemBankAccountMutation) DailyBalanceLimit() (r uint64, exists bool) {
	v := m.daily_balance_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyBalanceLimit returns the old "daily_balance_limit" field's value of the SystemBankAccount entity.
// If the SystemBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemBankAccountMutation) OldDailyBalanceLimit(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDailyBalanceLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDailyBalanceLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyBalanceLimit: %w", err)
	}
	return oldValue.DailyBalanceLimit, nil
}

// AddDailyBalanceLimit adds u to the "daily_balance_limit" field.
func (m *SystemBankAccountMutation) AddDailyBalanceLimit(u uint64) {
	if m.adddaily_balance_limit != nil {
		*m.adddaily_balance_limit += u
	} else {
		m.adddaily_balance_limit = &u
	}
}

// AddedDailyBalanceLimit returns the value that was added to the "daily_balance_limit" field in this mutation.
func (m *SystemBankAccountMutation) AddedDailyBalanceLimit() (r uint64, exists bool) {
	v := m.adddaily_balance_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetDailyBalanceLimit resets all changes to the "daily_balance_limit" field.
func (m *SystemBankAccountMutation) ResetDailyBalanceLimit() {
	m.daily_balance_limit = nil
	m.adddaily_balance_limit = nil
}

// SetDailyUsedAmount sets the "daily_used_amount" field.
func (m *SystemBankAccountMutation) SetDailyUsedAmount(i int64) {
	m.daily_used_amount = &i
	m.adddaily_used_amount = nil
}

// DailyUsedAmount returns the value of the "daily_used_amount" field in the mutation.
func (m *SystemBankAccountMutation) DailyUsedAmount() (r int64, exists bool) {
	v := m.daily_used_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyUsedAmount returns the old "daily_used_amount" field's value of the SystemBankAccount entity.
// If the SystemBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemBankAccountMutation) OldDailyUsedAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDailyUsedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDailyUsedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyUsedAmount: %w", err)
	}
	return oldValue.DailyUsedAmount, nil
}

// AddDailyUsedAmount adds i to the "daily_used_amount" field.
func (m *SystemBankAccountMutation) AddDailyUsedAmount(i int64) {
	if m.adddaily_used_amount != nil {
		*m.adddaily_used_amount += i
	} else {
		m.adddaily_used_amount = &i
	}
}

// AddedDailyUsedAmount returns the value that was added to the "daily_used_amount" field in this mutation.
func (m *SystemBankAccountMutation) AddedDailyUsedAmount() (r int64, exists bool) {
	v := m.adddaily_used_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetDailyUsedAmount resets all changes to the "daily_used_amount" field.
func (m *SystemBankAccountMutation) ResetDailyUsedAmount() {
	m.daily_used_amount = nil
	m.adddaily_used_amount = nil
}

// SetDailyBalance sets the "daily_balance" field.
func (m *SystemBankAccountMutation) SetDailyBalance(u uint64) {
	m.daily_balance = &u
	m.adddaily_balance = nil
}

// DailyBalance returns the value of the "daily_balance" field in the mutation.
func (m *SystemBankAccountMutation) DailyBalance() (r uint64, exists bool) {
	v := m.daily_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyBalance returns the old "daily_balance" field's value of the SystemBankAccount entity.
// If the SystemBankAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemBankAccountMutation) OldDailyBalance(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDailyBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDailyBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyBalance: %w", err)
	}
	return oldValue.DailyBalance, nil
}

// AddDailyBalance adds u to the "daily_balance" field.
func (m *SystemBankAccountMutation) AddDailyBalance(u uint64) {
	if m.adddaily_balance != nil {
		*m.adddaily_balance += u
	} else {
		m.adddaily_balance = &u
	}
}

// AddedDailyBalance returns the value that was added to the "daily_balance" field in this mutation.
func (m *SystemBankAccountMutation) AddedDailyBalance() (r uint64, exists bool) {
	v := m.adddaily_balance
	if v == nil {
		return
	}
	return *v, true
}

// ResetDailyBalance resets all changes to the "daily_balance" field.
func (m *SystemBankAccountMutation) ResetDailyBalance() {
	m.daily_balance = nil
	m.adddaily_balance = nil
}

// Where appends a list predicates to the SystemBankAccountMutation builder.
func (m *SystemBankAccountMutation) Where(ps ...predicate.SystemBankAccount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SystemBankAccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SystemBankAccount).
func (m *SystemBankAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemBankAccountMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, systembankaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, systembankaccount.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, systembankaccount.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, systembankaccount.FieldUpdatedBy)
	}
	if m.merchant_id != nil {
		fields = append(fields, systembankaccount.FieldMerchantID)
	}
	if m.status != nil {
		fields = append(fields, systembankaccount.FieldStatus)
	}
	if m.bank_name != nil {
		fields = append(fields, systembankaccount.FieldBankName)
	}
	if m.account_number != nil {
		fields = append(fields, systembankaccount.FieldAccountNumber)
	}
	if m.account_name != nil {
		fields = append(fields, systembankaccount.FieldAccountName)
	}
	if m.branch != nil {
		fields = append(fields, systembankaccount.FieldBranch)
	}
	if m.balance != nil {
		fields = append(fields, systembankaccount.FieldBalance)
	}
	if m.last_updated_balance != nil {
		fields = append(fields, systembankaccount.FieldLastUpdatedBalance)
	}
	if m.daily_balance_limit != nil {
		fields = append(fields, systembankaccount.FieldDailyBalanceLimit)
	}
	if m.daily_used_amount != nil {
		fields = append(fields, systembankaccount.FieldDailyUsedAmount)
	}
	if m.daily_balance != nil {
		fields = append(fields, systembankaccount.FieldDailyBalance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemBankAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systembankaccount.FieldCreatedAt:
		return m.CreatedAt()
	case systembankaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case systembankaccount.FieldCreatedBy:
		return m.CreatedBy()
	case systembankaccount.FieldUpdatedBy:
		return m.UpdatedBy()
	case systembankaccount.FieldMerchantID:
		return m.MerchantID()
	case systembankaccount.FieldStatus:
		return m.Status()
	case systembankaccount.FieldBankName:
		return m.BankName()
	case systembankaccount.FieldAccountNumber:
		return m.AccountNumber()
	case systembankaccount.FieldAccountName:
		return m.AccountName()
	case systembankaccount.FieldBranch:
		return m.Branch()
	case systembankaccount.FieldBalance:
		return m.Balance()
	case systembankaccount.FieldLastUpdatedBalance:
		return m.LastUpdatedBalance()
	case systembankaccount.FieldDailyBalanceLimit:
		return m.DailyBalanceLimit()
	case systembankaccount.FieldDailyUsedAmount:
		return m.DailyUsedAmount()
	case systembankaccount.FieldDailyBalance:
		return m.DailyBalance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemBankAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systembankaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case systembankaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case systembankaccount.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case systembankaccount.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case systembankaccount.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case systembankaccount.FieldStatus:
		return m.OldStatus(ctx)
	case systembankaccount.FieldBankName:
		return m.OldBankName(ctx)
	case systembankaccount.FieldAccountNumber:
		return m.OldAccountNumber(ctx)
	case systembankaccount.FieldAccountName:
		return m.OldAccountName(ctx)
	case systembankaccount.FieldBranch:
		return m.OldBranch(ctx)
	case systembankaccount.FieldBalance:
		return m.OldBalance(ctx)
	case systembankaccount.FieldLastUpdatedBalance:
		return m.OldLastUpdatedBalance(ctx)
	case systembankaccount.FieldDailyBalanceLimit:
		return m.OldDailyBalanceLimit(ctx)
	case systembankaccount.FieldDailyUsedAmount:
		return m.OldDailyUsedAmount(ctx)
	case systembankaccount.FieldDailyBalance:
		return m.OldDailyBalance(ctx)
	}
	return nil, fmt.Errorf("unknown SystemBankAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemBankAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systembankaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case systembankaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case systembankaccount.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case systembankaccount.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case systembankaccount.FieldMerchantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case systembankaccount.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case systembankaccount.FieldBankName:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankName(v)
		return nil
	case systembankaccount.FieldAccountNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountNumber(v)
		return nil
	case systembankaccount.FieldAccountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountName(v)
		return nil
	case systembankaccount.FieldBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranch(v)
		return nil
	case systembankaccount.FieldBalance:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case systembankaccount.FieldLastUpdatedBalance:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdatedBalance(v)
		return nil
	case systembankaccount.FieldDailyBalanceLimit:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyBalanceLimit(v)
		return nil
	case systembankaccount.FieldDailyUsedAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyUsedAmount(v)
		return nil
	case systembankaccount.FieldDailyBalance:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyBalance(v)
		return nil
	}
	return fmt.Errorf("unknown SystemBankAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemBankAccountMutation) AddedFields() []string {
	var fields []string
	if m.addmerchant_id != nil {
		fields = append(fields, systembankaccount.FieldMerchantID)
	}
	if m.addstatus != nil {
		fields = append(fields, systembankaccount.FieldStatus)
	}
	if m.addbank_name != nil {
		fields = append(fields, systembankaccount.FieldBankName)
	}
	if m.addbalance != nil {
		fields = append(fields, systembankaccount.FieldBalance)
	}
	if m.adddaily_balance_limit != nil {
		fields = append(fields, systembankaccount.FieldDailyBalanceLimit)
	}
	if m.adddaily_used_amount != nil {
		fields = append(fields, systembankaccount.FieldDailyUsedAmount)
	}
	if m.adddaily_balance != nil {
		fields = append(fields, systembankaccount.FieldDailyBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemBankAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case systembankaccount.FieldMerchantID:
		return m.AddedMerchantID()
	case systembankaccount.FieldStatus:
		return m.AddedStatus()
	case systembankaccount.FieldBankName:
		return m.AddedBankName()
	case systembankaccount.FieldBalance:
		return m.AddedBalance()
	case systembankaccount.FieldDailyBalanceLimit:
		return m.AddedDailyBalanceLimit()
	case systembankaccount.FieldDailyUsedAmount:
		return m.AddedDailyUsedAmount()
	case systembankaccount.FieldDailyBalance:
		return m.AddedDailyBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemBankAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case systembankaccount.FieldMerchantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMerchantID(v)
		return nil
	case systembankaccount.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case systembankaccount.FieldBankName:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBankName(v)
		return nil
	case systembankaccount.FieldBalance:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case systembankaccount.FieldDailyBalanceLimit:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyBalanceLimit(v)
		return nil
	case systembankaccount.FieldDailyUsedAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyUsedAmount(v)
		return nil
	case systembankaccount.FieldDailyBalance:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyBalance(v)
		return nil
	}
	return fmt.Errorf("unknown SystemBankAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemBankAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systembankaccount.FieldLastUpdatedBalance) {
		fields = append(fields, systembankaccount.FieldLastUpdatedBalance)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemBankAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemBankAccountMutation) ClearField(name string) error {
	switch name {
	case systembankaccount.FieldLastUpdatedBalance:
		m.ClearLastUpdatedBalance()
		return nil
	}
	return fmt.Errorf("unknown SystemBankAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemBankAccountMutation) ResetField(name string) error {
	switch name {
	case systembankaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case systembankaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case systembankaccount.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case systembankaccount.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case systembankaccount.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case systembankaccount.FieldStatus:
		m.ResetStatus()
		return nil
	case systembankaccount.FieldBankName:
		m.ResetBankName()
		return nil
	case systembankaccount.FieldAccountNumber:
		m.ResetAccountNumber()
		return nil
	case systembankaccount.FieldAccountName:
		m.ResetAccountName()
		return nil
	case systembankaccount.FieldBranch:
		m.ResetBranch()
		return nil
	case systembankaccount.FieldBalance:
		m.ResetBalance()
		return nil
	case systembankaccount.FieldLastUpdatedBalance:
		m.ResetLastUpdatedBalance()
		return nil
	case systembankaccount.FieldDailyBalanceLimit:
		m.ResetDailyBalanceLimit()
		return nil
	case systembankaccount.FieldDailyUsedAmount:
		m.ResetDailyUsedAmount()
		return nil
	case systembankaccount.FieldDailyBalance:
		m.ResetDailyBalance()
		return nil
	}
	return fmt.Errorf("unknown SystemBankAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemBankAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemBankAccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemBankAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemBankAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemBankAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemBankAccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemBankAccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SystemBankAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemBankAccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SystemBankAccount edge %s", name)
}

// SystemCryptoHotWalletMutation represents an operation that mutates the SystemCryptoHotWallet nodes in the graph.
type SystemCryptoHotWalletMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	merchant_id            *int64
	addmerchant_id         *int64
	crypto_type            *int32
	addcrypto_type         *int32
	crypto_network_type    *int32
	addcrypto_network_type *int32
	address                *string
	total_balance          *float64
	addtotal_balance       *float64
	balance                *float64
	addbalance             *float64
	status                 *int32
	addstatus              *int32
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*SystemCryptoHotWallet, error)
	predicates             []predicate.SystemCryptoHotWallet
}

var _ ent.Mutation = (*SystemCryptoHotWalletMutation)(nil)

// systemcryptohotwalletOption allows management of the mutation configuration using functional options.
type systemcryptohotwalletOption func(*SystemCryptoHotWalletMutation)

// newSystemCryptoHotWalletMutation creates new mutation for the SystemCryptoHotWallet entity.
func newSystemCryptoHotWalletMutation(c config, op Op, opts ...systemcryptohotwalletOption) *SystemCryptoHotWalletMutation {
	m := &SystemCryptoHotWalletMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemCryptoHotWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemCryptoHotWalletID sets the ID field of the mutation.
func withSystemCryptoHotWalletID(id int64) systemcryptohotwalletOption {
	return func(m *SystemCryptoHotWalletMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemCryptoHotWallet
		)
		m.oldValue = func(ctx context.Context) (*SystemCryptoHotWallet, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemCryptoHotWallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemCryptoHotWallet sets the old SystemCryptoHotWallet of the mutation.
func withSystemCryptoHotWallet(node *SystemCryptoHotWallet) systemcryptohotwalletOption {
	return func(m *SystemCryptoHotWalletMutation) {
		m.oldValue = func(context.Context) (*SystemCryptoHotWallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemCryptoHotWalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemCryptoHotWalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemCryptoHotWallet entities.
func (m *SystemCryptoHotWalletMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemCryptoHotWalletMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemCryptoHotWalletMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemCryptoHotWalletMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemCryptoHotWallet entity.
// If the SystemCryptoHotWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemCryptoHotWalletMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemCryptoHotWalletMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemCryptoHotWalletMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemCryptoHotWalletMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SystemCryptoHotWallet entity.
// If the SystemCryptoHotWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemCryptoHotWalletMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemCryptoHotWalletMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *SystemCryptoHotWalletMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SystemCryptoHotWalletMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the SystemCryptoHotWallet entity.
// If the SystemCryptoHotWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemCryptoHotWalletMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SystemCryptoHotWalletMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SystemCryptoHotWalletMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SystemCryptoHotWalletMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the SystemCryptoHotWallet entity.
// If the SystemCryptoHotWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemCryptoHotWalletMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SystemCryptoHotWalletMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *SystemCryptoHotWalletMutation) SetMerchantID(i int64) {
	m.merchant_id = &i
	m.addmerchant_id = nil
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *SystemCryptoHotWalletMutation) MerchantID() (r int64, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the SystemCryptoHotWallet entity.
// If the SystemCryptoHotWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemCryptoHotWalletMutation) OldMerchantID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// AddMerchantID adds i to the "merchant_id" field.
func (m *SystemCryptoHotWalletMutation) AddMerchantID(i int64) {
	if m.addmerchant_id != nil {
		*m.addmerchant_id += i
	} else {
		m.addmerchant_id = &i
	}
}

// AddedMerchantID returns the value that was added to the "merchant_id" field in this mutation.
func (m *SystemCryptoHotWalletMutation) AddedMerchantID() (r int64, exists bool) {
	v := m.addmerchant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *SystemCryptoHotWalletMutation) ResetMerchantID() {
	m.merchant_id = nil
	m.addmerchant_id = nil
}

// SetCryptoType sets the "crypto_type" field.
func (m *SystemCryptoHotWalletMutation) SetCryptoType(i int32) {
	m.crypto_type = &i
	m.addcrypto_type = nil
}

// CryptoType returns the value of the "crypto_type" field in the mutation.
func (m *SystemCryptoHotWalletMutation) CryptoType() (r int32, exists bool) {
	v := m.crypto_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCryptoType returns the old "crypto_type" field's value of the SystemCryptoHotWallet entity.
// If the SystemCryptoHotWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemCryptoHotWalletMutation) OldCryptoType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCryptoType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCryptoType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCryptoType: %w", err)
	}
	return oldValue.CryptoType, nil
}

// AddCryptoType adds i to the "crypto_type" field.
func (m *SystemCryptoHotWalletMutation) AddCryptoType(i int32) {
	if m.addcrypto_type != nil {
		*m.addcrypto_type += i
	} else {
		m.addcrypto_type = &i
	}
}

// AddedCryptoType returns the value that was added to the "crypto_type" field in this mutation.
func (m *SystemCryptoHotWalletMutation) AddedCryptoType() (r int32, exists bool) {
	v := m.addcrypto_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetCryptoType resets all changes to the "crypto_type" field.
func (m *SystemCryptoHotWalletMutation) ResetCryptoType() {
	m.crypto_type = nil
	m.addcrypto_type = nil
}

// SetCryptoNetworkType sets the "crypto_network_type" field.
func (m *SystemCryptoHotWalletMutation) SetCryptoNetworkType(i int32) {
	m.crypto_network_type = &i
	m.addcrypto_network_type = nil
}

// CryptoNetworkType returns the value of the "crypto_network_type" field in the mutation.
func (m *SystemCryptoHotWalletMutation) CryptoNetworkType() (r int32, exists bool) {
	v := m.crypto_network_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCryptoNetworkType returns the old "crypto_network_type" field's value of the SystemCryptoHotWallet entity.
// If the SystemCryptoHotWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemCryptoHotWalletMutation) OldCryptoNetworkType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCryptoNetworkType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCryptoNetworkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCryptoNetworkType: %w", err)
	}
	return oldValue.CryptoNetworkType, nil
}

// AddCryptoNetworkType adds i to the "crypto_network_type" field.
func (m *SystemCryptoHotWalletMutation) AddCryptoNetworkType(i int32) {
	if m.addcrypto_network_type != nil {
		*m.addcrypto_network_type += i
	} else {
		m.addcrypto_network_type = &i
	}
}

// AddedCryptoNetworkType returns the value that was added to the "crypto_network_type" field in this mutation.
func (m *SystemCryptoHotWalletMutation) AddedCryptoNetworkType() (r int32, exists bool) {
	v := m.addcrypto_network_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetCryptoNetworkType resets all changes to the "crypto_network_type" field.
func (m *SystemCryptoHotWalletMutation) ResetCryptoNetworkType() {
	m.crypto_network_type = nil
	m.addcrypto_network_type = nil
}

// SetAddress sets the "address" field.
func (m *SystemCryptoHotWalletMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *SystemCryptoHotWalletMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the SystemCryptoHotWallet entity.
// If the SystemCryptoHotWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemCryptoHotWalletMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *SystemCryptoHotWalletMutation) ResetAddress() {
	m.address = nil
}

// SetTotalBalance sets the "total_balance" field.
func (m *SystemCryptoHotWalletMutation) SetTotalBalance(f float64) {
	m.total_balance = &f
	m.addtotal_balance = nil
}

// TotalBalance returns the value of the "total_balance" field in the mutation.
func (m *SystemCryptoHotWalletMutation) TotalBalance() (r float64, exists bool) {
	v := m.total_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalBalance returns the old "total_balance" field's value of the SystemCryptoHotWallet entity.
// If the SystemCryptoHotWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemCryptoHotWalletMutation) OldTotalBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalBalance: %w", err)
	}
	return oldValue.TotalBalance, nil
}

// AddTotalBalance adds f to the "total_balance" field.
func (m *SystemCryptoHotWalletMutation) AddTotalBalance(f float64) {
	if m.addtotal_balance != nil {
		*m.addtotal_balance += f
	} else {
		m.addtotal_balance = &f
	}
}

// AddedTotalBalance returns the value that was added to the "total_balance" field in this mutation.
func (m *SystemCryptoHotWalletMutation) AddedTotalBalance() (r float64, exists bool) {
	v := m.addtotal_balance
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalBalance resets all changes to the "total_balance" field.
func (m *SystemCryptoHotWalletMutation) ResetTotalBalance() {
	m.total_balance = nil
	m.addtotal_balance = nil
}

// SetBalance sets the "balance" field.
func (m *SystemCryptoHotWalletMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *SystemCryptoHotWalletMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the SystemCryptoHotWallet entity.
// If the SystemCryptoHotWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemCryptoHotWalletMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *SystemCryptoHotWalletMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *SystemCryptoHotWalletMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *SystemCryptoHotWalletMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetStatus sets the "status" field.
func (m *SystemCryptoHotWalletMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SystemCryptoHotWalletMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SystemCryptoHotWallet entity.
// If the SystemCryptoHotWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemCryptoHotWalletMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SystemCryptoHotWalletMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SystemCryptoHotWalletMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *SystemCryptoHotWalletMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Where appends a list predicates to the SystemCryptoHotWalletMutation builder.
func (m *SystemCryptoHotWalletMutation) Where(ps ...predicate.SystemCryptoHotWallet) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SystemCryptoHotWalletMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SystemCryptoHotWallet).
func (m *SystemCryptoHotWalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemCryptoHotWalletMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, systemcryptohotwallet.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, systemcryptohotwallet.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, systemcryptohotwallet.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, systemcryptohotwallet.FieldUpdatedBy)
	}
	if m.merchant_id != nil {
		fields = append(fields, systemcryptohotwallet.FieldMerchantID)
	}
	if m.crypto_type != nil {
		fields = append(fields, systemcryptohotwallet.FieldCryptoType)
	}
	if m.crypto_network_type != nil {
		fields = append(fields, systemcryptohotwallet.FieldCryptoNetworkType)
	}
	if m.address != nil {
		fields = append(fields, systemcryptohotwallet.FieldAddress)
	}
	if m.total_balance != nil {
		fields = append(fields, systemcryptohotwallet.FieldTotalBalance)
	}
	if m.balance != nil {
		fields = append(fields, systemcryptohotwallet.FieldBalance)
	}
	if m.status != nil {
		fields = append(fields, systemcryptohotwallet.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemCryptoHotWalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemcryptohotwallet.FieldCreatedAt:
		return m.CreatedAt()
	case systemcryptohotwallet.FieldUpdatedAt:
		return m.UpdatedAt()
	case systemcryptohotwallet.FieldCreatedBy:
		return m.CreatedBy()
	case systemcryptohotwallet.FieldUpdatedBy:
		return m.UpdatedBy()
	case systemcryptohotwallet.FieldMerchantID:
		return m.MerchantID()
	case systemcryptohotwallet.FieldCryptoType:
		return m.CryptoType()
	case systemcryptohotwallet.FieldCryptoNetworkType:
		return m.CryptoNetworkType()
	case systemcryptohotwallet.FieldAddress:
		return m.Address()
	case systemcryptohotwallet.FieldTotalBalance:
		return m.TotalBalance()
	case systemcryptohotwallet.FieldBalance:
		return m.Balance()
	case systemcryptohotwallet.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemCryptoHotWalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemcryptohotwallet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case systemcryptohotwallet.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case systemcryptohotwallet.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case systemcryptohotwallet.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case systemcryptohotwallet.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case systemcryptohotwallet.FieldCryptoType:
		return m.OldCryptoType(ctx)
	case systemcryptohotwallet.FieldCryptoNetworkType:
		return m.OldCryptoNetworkType(ctx)
	case systemcryptohotwallet.FieldAddress:
		return m.OldAddress(ctx)
	case systemcryptohotwallet.FieldTotalBalance:
		return m.OldTotalBalance(ctx)
	case systemcryptohotwallet.FieldBalance:
		return m.OldBalance(ctx)
	case systemcryptohotwallet.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown SystemCryptoHotWallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemCryptoHotWalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemcryptohotwallet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case systemcryptohotwallet.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case systemcryptohotwallet.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case systemcryptohotwallet.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case systemcryptohotwallet.FieldMerchantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case systemcryptohotwallet.FieldCryptoType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCryptoType(v)
		return nil
	case systemcryptohotwallet.FieldCryptoNetworkType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCryptoNetworkType(v)
		return nil
	case systemcryptohotwallet.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case systemcryptohotwallet.FieldTotalBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalBalance(v)
		return nil
	case systemcryptohotwallet.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case systemcryptohotwallet.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown SystemCryptoHotWallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemCryptoHotWalletMutation) AddedFields() []string {
	var fields []string
	if m.addmerchant_id != nil {
		fields = append(fields, systemcryptohotwallet.FieldMerchantID)
	}
	if m.addcrypto_type != nil {
		fields = append(fields, systemcryptohotwallet.FieldCryptoType)
	}
	if m.addcrypto_network_type != nil {
		fields = append(fields, systemcryptohotwallet.FieldCryptoNetworkType)
	}
	if m.addtotal_balance != nil {
		fields = append(fields, systemcryptohotwallet.FieldTotalBalance)
	}
	if m.addbalance != nil {
		fields = append(fields, systemcryptohotwallet.FieldBalance)
	}
	if m.addstatus != nil {
		fields = append(fields, systemcryptohotwallet.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemCryptoHotWalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case systemcryptohotwallet.FieldMerchantID:
		return m.AddedMerchantID()
	case systemcryptohotwallet.FieldCryptoType:
		return m.AddedCryptoType()
	case systemcryptohotwallet.FieldCryptoNetworkType:
		return m.AddedCryptoNetworkType()
	case systemcryptohotwallet.FieldTotalBalance:
		return m.AddedTotalBalance()
	case systemcryptohotwallet.FieldBalance:
		return m.AddedBalance()
	case systemcryptohotwallet.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemCryptoHotWalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case systemcryptohotwallet.FieldMerchantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMerchantID(v)
		return nil
	case systemcryptohotwallet.FieldCryptoType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCryptoType(v)
		return nil
	case systemcryptohotwallet.FieldCryptoNetworkType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCryptoNetworkType(v)
		return nil
	case systemcryptohotwallet.FieldTotalBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalBalance(v)
		return nil
	case systemcryptohotwallet.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case systemcryptohotwallet.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown SystemCryptoHotWallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemCryptoHotWalletMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemCryptoHotWalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemCryptoHotWalletMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SystemCryptoHotWallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemCryptoHotWalletMutation) ResetField(name string) error {
	switch name {
	case systemcryptohotwallet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case systemcryptohotwallet.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case systemcryptohotwallet.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case systemcryptohotwallet.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case systemcryptohotwallet.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case systemcryptohotwallet.FieldCryptoType:
		m.ResetCryptoType()
		return nil
	case systemcryptohotwallet.FieldCryptoNetworkType:
		m.ResetCryptoNetworkType()
		return nil
	case systemcryptohotwallet.FieldAddress:
		m.ResetAddress()
		return nil
	case systemcryptohotwallet.FieldTotalBalance:
		m.ResetTotalBalance()
		return nil
	case systemcryptohotwallet.FieldBalance:
		m.ResetBalance()
		return nil
	case systemcryptohotwallet.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown SystemCryptoHotWallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemCryptoHotWalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemCryptoHotWalletMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemCryptoHotWalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemCryptoHotWalletMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemCryptoHotWalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemCryptoHotWalletMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemCryptoHotWalletMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SystemCryptoHotWallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemCryptoHotWalletMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SystemCryptoHotWallet edge %s", name)
}

// SystemEWalletMutation represents an operation that mutates the SystemEWallet nodes in the graph.
type SystemEWalletMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	e_wallet_name          *int32
	adde_wallet_name       *int32
	status                 *int32
	addstatus              *int32
	merchant_id            *int64
	addmerchant_id         *int64
	account_phone_number   *string
	account_name           *string
	balance                *uint64
	addbalance             *uint64
	daily_balance          *uint64
	adddaily_balance       *uint64
	daily_balance_limit    *uint64
	adddaily_balance_limit *uint64
	daily_used_amount      *int64
	adddaily_used_amount   *int64
	last_updated_balance   *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*SystemEWallet, error)
	predicates             []predicate.SystemEWallet
}

var _ ent.Mutation = (*SystemEWalletMutation)(nil)

// systemewalletOption allows management of the mutation configuration using functional options.
type systemewalletOption func(*SystemEWalletMutation)

// newSystemEWalletMutation creates new mutation for the SystemEWallet entity.
func newSystemEWalletMutation(c config, op Op, opts ...systemewalletOption) *SystemEWalletMutation {
	m := &SystemEWalletMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemEWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemEWalletID sets the ID field of the mutation.
func withSystemEWalletID(id int64) systemewalletOption {
	return func(m *SystemEWalletMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemEWallet
		)
		m.oldValue = func(ctx context.Context) (*SystemEWallet, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemEWallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemEWallet sets the old SystemEWallet of the mutation.
func withSystemEWallet(node *SystemEWallet) systemewalletOption {
	return func(m *SystemEWalletMutation) {
		m.oldValue = func(context.Context) (*SystemEWallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemEWalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemEWalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemEWallet entities.
func (m *SystemEWalletMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemEWalletMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemEWalletMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemEWalletMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemEWallet entity.
// If the SystemEWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEWalletMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemEWalletMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemEWalletMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemEWalletMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SystemEWallet entity.
// If the SystemEWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEWalletMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemEWalletMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *SystemEWalletMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SystemEWalletMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the SystemEWallet entity.
// If the SystemEWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEWalletMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SystemEWalletMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SystemEWalletMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SystemEWalletMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the SystemEWallet entity.
// If the SystemEWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEWalletMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SystemEWalletMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetEWalletName sets the "e_wallet_name" field.
func (m *SystemEWalletMutation) SetEWalletName(i int32) {
	m.e_wallet_name = &i
	m.adde_wallet_name = nil
}

// EWalletName returns the value of the "e_wallet_name" field in the mutation.
func (m *SystemEWalletMutation) EWalletName() (r int32, exists bool) {
	v := m.e_wallet_name
	if v == nil {
		return
	}
	return *v, true
}

// OldEWalletName returns the old "e_wallet_name" field's value of the SystemEWallet entity.
// If the SystemEWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEWalletMutation) OldEWalletName(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEWalletName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEWalletName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEWalletName: %w", err)
	}
	return oldValue.EWalletName, nil
}

// AddEWalletName adds i to the "e_wallet_name" field.
func (m *SystemEWalletMutation) AddEWalletName(i int32) {
	if m.adde_wallet_name != nil {
		*m.adde_wallet_name += i
	} else {
		m.adde_wallet_name = &i
	}
}

// AddedEWalletName returns the value that was added to the "e_wallet_name" field in this mutation.
func (m *SystemEWalletMutation) AddedEWalletName() (r int32, exists bool) {
	v := m.adde_wallet_name
	if v == nil {
		return
	}
	return *v, true
}

// ResetEWalletName resets all changes to the "e_wallet_name" field.
func (m *SystemEWalletMutation) ResetEWalletName() {
	m.e_wallet_name = nil
	m.adde_wallet_name = nil
}

// SetStatus sets the "status" field.
func (m *SystemEWalletMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SystemEWalletMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SystemEWallet entity.
// If the SystemEWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEWalletMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SystemEWalletMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SystemEWalletMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *SystemEWalletMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *SystemEWalletMutation) SetMerchantID(i int64) {
	m.merchant_id = &i
	m.addmerchant_id = nil
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *SystemEWalletMutation) MerchantID() (r int64, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the SystemEWallet entity.
// If the SystemEWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEWalletMutation) OldMerchantID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// AddMerchantID adds i to the "merchant_id" field.
func (m *SystemEWalletMutation) AddMerchantID(i int64) {
	if m.addmerchant_id != nil {
		*m.addmerchant_id += i
	} else {
		m.addmerchant_id = &i
	}
}

// AddedMerchantID returns the value that was added to the "merchant_id" field in this mutation.
func (m *SystemEWalletMutation) AddedMerchantID() (r int64, exists bool) {
	v := m.addmerchant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *SystemEWalletMutation) ResetMerchantID() {
	m.merchant_id = nil
	m.addmerchant_id = nil
}

// SetAccountPhoneNumber sets the "account_phone_number" field.
func (m *SystemEWalletMutation) SetAccountPhoneNumber(s string) {
	m.account_phone_number = &s
}

// AccountPhoneNumber returns the value of the "account_phone_number" field in the mutation.
func (m *SystemEWalletMutation) AccountPhoneNumber() (r string, exists bool) {
	v := m.account_phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountPhoneNumber returns the old "account_phone_number" field's value of the SystemEWallet entity.
// If the SystemEWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEWalletMutation) OldAccountPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccountPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccountPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountPhoneNumber: %w", err)
	}
	return oldValue.AccountPhoneNumber, nil
}

// ResetAccountPhoneNumber resets all changes to the "account_phone_number" field.
func (m *SystemEWalletMutation) ResetAccountPhoneNumber() {
	m.account_phone_number = nil
}

// SetAccountName sets the "account_name" field.
func (m *SystemEWalletMutation) SetAccountName(s string) {
	m.account_name = &s
}

// AccountName returns the value of the "account_name" field in the mutation.
func (m *SystemEWalletMutation) AccountName() (r string, exists bool) {
	v := m.account_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountName returns the old "account_name" field's value of the SystemEWallet entity.
// If the SystemEWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEWalletMutation) OldAccountName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccountName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountName: %w", err)
	}
	return oldValue.AccountName, nil
}

// ResetAccountName resets all changes to the "account_name" field.
func (m *SystemEWalletMutation) ResetAccountName() {
	m.account_name = nil
}

// SetBalance sets the "balance" field.
func (m *SystemEWalletMutation) SetBalance(u uint64) {
	m.balance = &u
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *SystemEWalletMutation) Balance() (r uint64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the SystemEWallet entity.
// If the SystemEWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEWalletMutation) OldBalance(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds u to the "balance" field.
func (m *SystemEWalletMutation) AddBalance(u uint64) {
	if m.addbalance != nil {
		*m.addbalance += u
	} else {
		m.addbalance = &u
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *SystemEWalletMutation) AddedBalance() (r uint64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *SystemEWalletMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetDailyBalance sets the "daily_balance" field.
func (m *SystemEWalletMutation) SetDailyBalance(u uint64) {
	m.daily_balance = &u
	m.adddaily_balance = nil
}

// DailyBalance returns the value of the "daily_balance" field in the mutation.
func (m *SystemEWalletMutation) DailyBalance() (r uint64, exists bool) {
	v := m.daily_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyBalance returns the old "daily_balance" field's value of the SystemEWallet entity.
// If the SystemEWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEWalletMutation) OldDailyBalance(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDailyBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDailyBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyBalance: %w", err)
	}
	return oldValue.DailyBalance, nil
}

// AddDailyBalance adds u to the "daily_balance" field.
func (m *SystemEWalletMutation) AddDailyBalance(u uint64) {
	if m.adddaily_balance != nil {
		*m.adddaily_balance += u
	} else {
		m.adddaily_balance = &u
	}
}

// AddedDailyBalance returns the value that was added to the "daily_balance" field in this mutation.
func (m *SystemEWalletMutation) AddedDailyBalance() (r uint64, exists bool) {
	v := m.adddaily_balance
	if v == nil {
		return
	}
	return *v, true
}

// ResetDailyBalance resets all changes to the "daily_balance" field.
func (m *SystemEWalletMutation) ResetDailyBalance() {
	m.daily_balance = nil
	m.adddaily_balance = nil
}

// SetDailyBalanceLimit sets the "daily_balance_limit" field.
func (m *SystemEWalletMutation) SetDailyBalanceLimit(u uint64) {
	m.daily_balance_limit = &u
	m.adddaily_balance_limit = nil
}

// DailyBalanceLimit returns the value of the "daily_balance_limit" field in the mutation.
func (m *SystemEWalletMutation) DailyBalanceLimit() (r uint64, exists bool) {
	v := m.daily_balance_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyBalanceLimit returns the old "daily_balance_limit" field's value of the SystemEWallet entity.
// If the SystemEWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEWalletMutation) OldDailyBalanceLimit(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDailyBalanceLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDailyBalanceLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyBalanceLimit: %w", err)
	}
	return oldValue.DailyBalanceLimit, nil
}

// AddDailyBalanceLimit adds u to the "daily_balance_limit" field.
func (m *SystemEWalletMutation) AddDailyBalanceLimit(u uint64) {
	if m.adddaily_balance_limit != nil {
		*m.adddaily_balance_limit += u
	} else {
		m.adddaily_balance_limit = &u
	}
}

// AddedDailyBalanceLimit returns the value that was added to the "daily_balance_limit" field in this mutation.
func (m *SystemEWalletMutation) AddedDailyBalanceLimit() (r uint64, exists bool) {
	v := m.adddaily_balance_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetDailyBalanceLimit resets all changes to the "daily_balance_limit" field.
func (m *SystemEWalletMutation) ResetDailyBalanceLimit() {
	m.daily_balance_limit = nil
	m.adddaily_balance_limit = nil
}

// SetDailyUsedAmount sets the "daily_used_amount" field.
func (m *SystemEWalletMutation) SetDailyUsedAmount(i int64) {
	m.daily_used_amount = &i
	m.adddaily_used_amount = nil
}

// DailyUsedAmount returns the value of the "daily_used_amount" field in the mutation.
func (m *SystemEWalletMutation) DailyUsedAmount() (r int64, exists bool) {
	v := m.daily_used_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyUsedAmount returns the old "daily_used_amount" field's value of the SystemEWallet entity.
// If the SystemEWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEWalletMutation) OldDailyUsedAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDailyUsedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDailyUsedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyUsedAmount: %w", err)
	}
	return oldValue.DailyUsedAmount, nil
}

// AddDailyUsedAmount adds i to the "daily_used_amount" field.
func (m *SystemEWalletMutation) AddDailyUsedAmount(i int64) {
	if m.adddaily_used_amount != nil {
		*m.adddaily_used_amount += i
	} else {
		m.adddaily_used_amount = &i
	}
}

// AddedDailyUsedAmount returns the value that was added to the "daily_used_amount" field in this mutation.
func (m *SystemEWalletMutation) AddedDailyUsedAmount() (r int64, exists bool) {
	v := m.adddaily_used_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetDailyUsedAmount resets all changes to the "daily_used_amount" field.
func (m *SystemEWalletMutation) ResetDailyUsedAmount() {
	m.daily_used_amount = nil
	m.adddaily_used_amount = nil
}

// SetLastUpdatedBalance sets the "last_updated_balance" field.
func (m *SystemEWalletMutation) SetLastUpdatedBalance(t time.Time) {
	m.last_updated_balance = &t
}

// LastUpdatedBalance returns the value of the "last_updated_balance" field in the mutation.
func (m *SystemEWalletMutation) LastUpdatedBalance() (r time.Time, exists bool) {
	v := m.last_updated_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdatedBalance returns the old "last_updated_balance" field's value of the SystemEWallet entity.
// If the SystemEWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEWalletMutation) OldLastUpdatedBalance(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastUpdatedBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastUpdatedBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdatedBalance: %w", err)
	}
	return oldValue.LastUpdatedBalance, nil
}

// ClearLastUpdatedBalance clears the value of the "last_updated_balance" field.
func (m *SystemEWalletMutation) ClearLastUpdatedBalance() {
	m.last_updated_balance = nil
	m.clearedFields[systemewallet.FieldLastUpdatedBalance] = struct{}{}
}

// LastUpdatedBalanceCleared returns if the "last_updated_balance" field was cleared in this mutation.
func (m *SystemEWalletMutation) LastUpdatedBalanceCleared() bool {
	_, ok := m.clearedFields[systemewallet.FieldLastUpdatedBalance]
	return ok
}

// ResetLastUpdatedBalance resets all changes to the "last_updated_balance" field.
func (m *SystemEWalletMutation) ResetLastUpdatedBalance() {
	m.last_updated_balance = nil
	delete(m.clearedFields, systemewallet.FieldLastUpdatedBalance)
}

// Where appends a list predicates to the SystemEWalletMutation builder.
func (m *SystemEWalletMutation) Where(ps ...predicate.SystemEWallet) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SystemEWalletMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SystemEWallet).
func (m *SystemEWalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemEWalletMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, systemewallet.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, systemewallet.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, systemewallet.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, systemewallet.FieldUpdatedBy)
	}
	if m.e_wallet_name != nil {
		fields = append(fields, systemewallet.FieldEWalletName)
	}
	if m.status != nil {
		fields = append(fields, systemewallet.FieldStatus)
	}
	if m.merchant_id != nil {
		fields = append(fields, systemewallet.FieldMerchantID)
	}
	if m.account_phone_number != nil {
		fields = append(fields, systemewallet.FieldAccountPhoneNumber)
	}
	if m.account_name != nil {
		fields = append(fields, systemewallet.FieldAccountName)
	}
	if m.balance != nil {
		fields = append(fields, systemewallet.FieldBalance)
	}
	if m.daily_balance != nil {
		fields = append(fields, systemewallet.FieldDailyBalance)
	}
	if m.daily_balance_limit != nil {
		fields = append(fields, systemewallet.FieldDailyBalanceLimit)
	}
	if m.daily_used_amount != nil {
		fields = append(fields, systemewallet.FieldDailyUsedAmount)
	}
	if m.last_updated_balance != nil {
		fields = append(fields, systemewallet.FieldLastUpdatedBalance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemEWalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemewallet.FieldCreatedAt:
		return m.CreatedAt()
	case systemewallet.FieldUpdatedAt:
		return m.UpdatedAt()
	case systemewallet.FieldCreatedBy:
		return m.CreatedBy()
	case systemewallet.FieldUpdatedBy:
		return m.UpdatedBy()
	case systemewallet.FieldEWalletName:
		return m.EWalletName()
	case systemewallet.FieldStatus:
		return m.Status()
	case systemewallet.FieldMerchantID:
		return m.MerchantID()
	case systemewallet.FieldAccountPhoneNumber:
		return m.AccountPhoneNumber()
	case systemewallet.FieldAccountName:
		return m.AccountName()
	case systemewallet.FieldBalance:
		return m.Balance()
	case systemewallet.FieldDailyBalance:
		return m.DailyBalance()
	case systemewallet.FieldDailyBalanceLimit:
		return m.DailyBalanceLimit()
	case systemewallet.FieldDailyUsedAmount:
		return m.DailyUsedAmount()
	case systemewallet.FieldLastUpdatedBalance:
		return m.LastUpdatedBalance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemEWalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemewallet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case systemewallet.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case systemewallet.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case systemewallet.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case systemewallet.FieldEWalletName:
		return m.OldEWalletName(ctx)
	case systemewallet.FieldStatus:
		return m.OldStatus(ctx)
	case systemewallet.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case systemewallet.FieldAccountPhoneNumber:
		return m.OldAccountPhoneNumber(ctx)
	case systemewallet.FieldAccountName:
		return m.OldAccountName(ctx)
	case systemewallet.FieldBalance:
		return m.OldBalance(ctx)
	case systemewallet.FieldDailyBalance:
		return m.OldDailyBalance(ctx)
	case systemewallet.FieldDailyBalanceLimit:
		return m.OldDailyBalanceLimit(ctx)
	case systemewallet.FieldDailyUsedAmount:
		return m.OldDailyUsedAmount(ctx)
	case systemewallet.FieldLastUpdatedBalance:
		return m.OldLastUpdatedBalance(ctx)
	}
	return nil, fmt.Errorf("unknown SystemEWallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemEWalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemewallet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case systemewallet.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case systemewallet.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case systemewallet.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case systemewallet.FieldEWalletName:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEWalletName(v)
		return nil
	case systemewallet.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case systemewallet.FieldMerchantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case systemewallet.FieldAccountPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountPhoneNumber(v)
		return nil
	case systemewallet.FieldAccountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountName(v)
		return nil
	case systemewallet.FieldBalance:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case systemewallet.FieldDailyBalance:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyBalance(v)
		return nil
	case systemewallet.FieldDailyBalanceLimit:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyBalanceLimit(v)
		return nil
	case systemewallet.FieldDailyUsedAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyUsedAmount(v)
		return nil
	case systemewallet.FieldLastUpdatedBalance:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdatedBalance(v)
		return nil
	}
	return fmt.Errorf("unknown SystemEWallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemEWalletMutation) AddedFields() []string {
	var fields []string
	if m.adde_wallet_name != nil {
		fields = append(fields, systemewallet.FieldEWalletName)
	}
	if m.addstatus != nil {
		fields = append(fields, systemewallet.FieldStatus)
	}
	if m.addmerchant_id != nil {
		fields = append(fields, systemewallet.FieldMerchantID)
	}
	if m.addbalance != nil {
		fields = append(fields, systemewallet.FieldBalance)
	}
	if m.adddaily_balance != nil {
		fields = append(fields, systemewallet.FieldDailyBalance)
	}
	if m.adddaily_balance_limit != nil {
		fields = append(fields, systemewallet.FieldDailyBalanceLimit)
	}
	if m.adddaily_used_amount != nil {
		fields = append(fields, systemewallet.FieldDailyUsedAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemEWalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case systemewallet.FieldEWalletName:
		return m.AddedEWalletName()
	case systemewallet.FieldStatus:
		return m.AddedStatus()
	case systemewallet.FieldMerchantID:
		return m.AddedMerchantID()
	case systemewallet.FieldBalance:
		return m.AddedBalance()
	case systemewallet.FieldDailyBalance:
		return m.AddedDailyBalance()
	case systemewallet.FieldDailyBalanceLimit:
		return m.AddedDailyBalanceLimit()
	case systemewallet.FieldDailyUsedAmount:
		return m.AddedDailyUsedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemEWalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case systemewallet.FieldEWalletName:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEWalletName(v)
		return nil
	case systemewallet.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case systemewallet.FieldMerchantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMerchantID(v)
		return nil
	case systemewallet.FieldBalance:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case systemewallet.FieldDailyBalance:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyBalance(v)
		return nil
	case systemewallet.FieldDailyBalanceLimit:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyBalanceLimit(v)
		return nil
	case systemewallet.FieldDailyUsedAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyUsedAmount(v)
		return nil
	}
	return fmt.Errorf("unknown SystemEWallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemEWalletMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemewallet.FieldLastUpdatedBalance) {
		fields = append(fields, systemewallet.FieldLastUpdatedBalance)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemEWalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemEWalletMutation) ClearField(name string) error {
	switch name {
	case systemewallet.FieldLastUpdatedBalance:
		m.ClearLastUpdatedBalance()
		return nil
	}
	return fmt.Errorf("unknown SystemEWallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemEWalletMutation) ResetField(name string) error {
	switch name {
	case systemewallet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case systemewallet.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case systemewallet.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case systemewallet.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case systemewallet.FieldEWalletName:
		m.ResetEWalletName()
		return nil
	case systemewallet.FieldStatus:
		m.ResetStatus()
		return nil
	case systemewallet.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case systemewallet.FieldAccountPhoneNumber:
		m.ResetAccountPhoneNumber()
		return nil
	case systemewallet.FieldAccountName:
		m.ResetAccountName()
		return nil
	case systemewallet.FieldBalance:
		m.ResetBalance()
		return nil
	case systemewallet.FieldDailyBalance:
		m.ResetDailyBalance()
		return nil
	case systemewallet.FieldDailyBalanceLimit:
		m.ResetDailyBalanceLimit()
		return nil
	case systemewallet.FieldDailyUsedAmount:
		m.ResetDailyUsedAmount()
		return nil
	case systemewallet.FieldLastUpdatedBalance:
		m.ResetLastUpdatedBalance()
		return nil
	}
	return fmt.Errorf("unknown SystemEWallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemEWalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemEWalletMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemEWalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemEWalletMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemEWalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemEWalletMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemEWalletMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SystemEWallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemEWalletMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SystemEWallet edge %s", name)
}
