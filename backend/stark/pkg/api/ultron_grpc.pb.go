// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package stark

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// UltronClient is the client API for Ultron service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UltronClient interface {
	// MEX call to MCU
	CreateCryptoWithdraw(ctx context.Context, in *CreateCryptoWithdrawRequest, opts ...grpc.CallOption) (*CreateCryptoWithdrawReply, error)
	// MEX call to MCU
	CancelCryptoWithdraw(ctx context.Context, in *CancelCryptoWithdrawRequest, opts ...grpc.CallOption) (*CancelCryptoWithdrawReply, error)
	// Teller approve it
	ApproveCryptoWithdraw(ctx context.Context, in *ApproveCryptoWithdrawRequest, opts ...grpc.CallOption) (*ApproveCryptoWithdrawReply, error)
	// Teller approve it
	SubmitCryptoWithdraw(ctx context.Context, in *SubmitCryptoWithdrawRequest, opts ...grpc.CallOption) (*SubmitCryptoWithdrawReply, error)
	// Teller reject it
	RejectCryptoWithdraw(ctx context.Context, in *RejectCryptoWithdrawRequest, opts ...grpc.CallOption) (*RejectCryptoWithdrawReply, error)
	// CreateCryptoTopUp will be done by callback from UMO
	// MEX call to cancel topup if teller hasn't handled it
	CancelCryptoTopUp(ctx context.Context, in *CancelCryptoTopUpRequest, opts ...grpc.CallOption) (*CancelCryptoTopUpReply, error)
	// Teller approve it
	ApproveCryptoTopUp(ctx context.Context, in *ApproveCryptoTopUpRequest, opts ...grpc.CallOption) (*ApproveCryptoTopUpReply, error)
	// Teller inject itc
	RejectCryptoTopUp(ctx context.Context, in *RejectCryptoTopUpRequest, opts ...grpc.CallOption) (*RejectCryptoTopUpReply, error)
	// MEX call to MCU
	GetCryptoWallet(ctx context.Context, in *GetCryptoWalletRequest, opts ...grpc.CallOption) (*GetCryptoWalletReply, error)
	// Admin APIs
	ValidateCryptoWallets(ctx context.Context, in *ValidateCryptoWalletsRequest, opts ...grpc.CallOption) (*ValidateCryptoWalletsReply, error)
	ImportCryptoWallets(ctx context.Context, in *ImportCryptoWalletsRequest, opts ...grpc.CallOption) (*ImportCryptoWalletsReply, error)
	ListCryptoWallets(ctx context.Context, in *ListCryptoWalletsRequest, opts ...grpc.CallOption) (*ListCryptoWalletsReply, error)
	ValidateCryptoHotWallets(ctx context.Context, in *ValidateCryptoHotWalletsRequest, opts ...grpc.CallOption) (*ValidateCryptoHotWalletsReply, error)
	ImportCryptoHotWallets(ctx context.Context, in *ImportCryptoHotWalletsRequest, opts ...grpc.CallOption) (*ImportCryptoHotWalletsReply, error)
	ListCryptoHotWallets(ctx context.Context, in *ListCryptoHotWalletsRequest, opts ...grpc.CallOption) (*ListCryptoHotWalletsReply, error)
	// Utility API to call for process payment
	GetSystemCryptoHotWallets(ctx context.Context, in *GetSystemCryptoHotWalletsRequest, opts ...grpc.CallOption) (*GetSystemCryptoHotWalletsReply, error)
	LoadCryptoWallets(ctx context.Context, in *LoadCryptoWalletsRequest, opts ...grpc.CallOption) (*LoadCryptoWalletsReply, error)
	UpdateAutoTransferCryptoWithdraw(ctx context.Context, in *UpdateAutoTransferCryptoWithdrawRequest, opts ...grpc.CallOption) (*UpdateAutoTransferCryptoWithdrawReply, error)
	GetCryptoSettings(ctx context.Context, in *GetCryptoSettingsRequest, opts ...grpc.CallOption) (*GetCryptoSettingsReply, error)
	// Callback from UMO
	CallbackTransaction(ctx context.Context, in *CallbackTransactionRequest, opts ...grpc.CallOption) (*CallbackTransactionReply, error)
}

type ultronClient struct {
	cc grpc.ClientConnInterface
}

func NewUltronClient(cc grpc.ClientConnInterface) UltronClient {
	return &ultronClient{cc}
}

func (c *ultronClient) CreateCryptoWithdraw(ctx context.Context, in *CreateCryptoWithdrawRequest, opts ...grpc.CallOption) (*CreateCryptoWithdrawReply, error) {
	out := new(CreateCryptoWithdrawReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/CreateCryptoWithdraw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) CancelCryptoWithdraw(ctx context.Context, in *CancelCryptoWithdrawRequest, opts ...grpc.CallOption) (*CancelCryptoWithdrawReply, error) {
	out := new(CancelCryptoWithdrawReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/CancelCryptoWithdraw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) ApproveCryptoWithdraw(ctx context.Context, in *ApproveCryptoWithdrawRequest, opts ...grpc.CallOption) (*ApproveCryptoWithdrawReply, error) {
	out := new(ApproveCryptoWithdrawReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/ApproveCryptoWithdraw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) SubmitCryptoWithdraw(ctx context.Context, in *SubmitCryptoWithdrawRequest, opts ...grpc.CallOption) (*SubmitCryptoWithdrawReply, error) {
	out := new(SubmitCryptoWithdrawReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/SubmitCryptoWithdraw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) RejectCryptoWithdraw(ctx context.Context, in *RejectCryptoWithdrawRequest, opts ...grpc.CallOption) (*RejectCryptoWithdrawReply, error) {
	out := new(RejectCryptoWithdrawReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/RejectCryptoWithdraw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) CancelCryptoTopUp(ctx context.Context, in *CancelCryptoTopUpRequest, opts ...grpc.CallOption) (*CancelCryptoTopUpReply, error) {
	out := new(CancelCryptoTopUpReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/CancelCryptoTopUp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) ApproveCryptoTopUp(ctx context.Context, in *ApproveCryptoTopUpRequest, opts ...grpc.CallOption) (*ApproveCryptoTopUpReply, error) {
	out := new(ApproveCryptoTopUpReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/ApproveCryptoTopUp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) RejectCryptoTopUp(ctx context.Context, in *RejectCryptoTopUpRequest, opts ...grpc.CallOption) (*RejectCryptoTopUpReply, error) {
	out := new(RejectCryptoTopUpReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/RejectCryptoTopUp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) GetCryptoWallet(ctx context.Context, in *GetCryptoWalletRequest, opts ...grpc.CallOption) (*GetCryptoWalletReply, error) {
	out := new(GetCryptoWalletReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/GetCryptoWallet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) ValidateCryptoWallets(ctx context.Context, in *ValidateCryptoWalletsRequest, opts ...grpc.CallOption) (*ValidateCryptoWalletsReply, error) {
	out := new(ValidateCryptoWalletsReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/ValidateCryptoWallets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) ImportCryptoWallets(ctx context.Context, in *ImportCryptoWalletsRequest, opts ...grpc.CallOption) (*ImportCryptoWalletsReply, error) {
	out := new(ImportCryptoWalletsReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/ImportCryptoWallets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) ListCryptoWallets(ctx context.Context, in *ListCryptoWalletsRequest, opts ...grpc.CallOption) (*ListCryptoWalletsReply, error) {
	out := new(ListCryptoWalletsReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/ListCryptoWallets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) ValidateCryptoHotWallets(ctx context.Context, in *ValidateCryptoHotWalletsRequest, opts ...grpc.CallOption) (*ValidateCryptoHotWalletsReply, error) {
	out := new(ValidateCryptoHotWalletsReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/ValidateCryptoHotWallets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) ImportCryptoHotWallets(ctx context.Context, in *ImportCryptoHotWalletsRequest, opts ...grpc.CallOption) (*ImportCryptoHotWalletsReply, error) {
	out := new(ImportCryptoHotWalletsReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/ImportCryptoHotWallets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) ListCryptoHotWallets(ctx context.Context, in *ListCryptoHotWalletsRequest, opts ...grpc.CallOption) (*ListCryptoHotWalletsReply, error) {
	out := new(ListCryptoHotWalletsReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/ListCryptoHotWallets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) GetSystemCryptoHotWallets(ctx context.Context, in *GetSystemCryptoHotWalletsRequest, opts ...grpc.CallOption) (*GetSystemCryptoHotWalletsReply, error) {
	out := new(GetSystemCryptoHotWalletsReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/GetSystemCryptoHotWallets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) LoadCryptoWallets(ctx context.Context, in *LoadCryptoWalletsRequest, opts ...grpc.CallOption) (*LoadCryptoWalletsReply, error) {
	out := new(LoadCryptoWalletsReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/LoadCryptoWallets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) UpdateAutoTransferCryptoWithdraw(ctx context.Context, in *UpdateAutoTransferCryptoWithdrawRequest, opts ...grpc.CallOption) (*UpdateAutoTransferCryptoWithdrawReply, error) {
	out := new(UpdateAutoTransferCryptoWithdrawReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/UpdateAutoTransferCryptoWithdraw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) GetCryptoSettings(ctx context.Context, in *GetCryptoSettingsRequest, opts ...grpc.CallOption) (*GetCryptoSettingsReply, error) {
	out := new(GetCryptoSettingsReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/GetCryptoSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ultronClient) CallbackTransaction(ctx context.Context, in *CallbackTransactionRequest, opts ...grpc.CallOption) (*CallbackTransactionReply, error) {
	out := new(CallbackTransactionReply)
	err := c.cc.Invoke(ctx, "/mcuc.stark.ultron.Ultron/CallbackTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UltronServer is the server API for Ultron service.
// All implementations must embed UnimplementedUltronServer
// for forward compatibility
type UltronServer interface {
	// MEX call to MCU
	CreateCryptoWithdraw(context.Context, *CreateCryptoWithdrawRequest) (*CreateCryptoWithdrawReply, error)
	// MEX call to MCU
	CancelCryptoWithdraw(context.Context, *CancelCryptoWithdrawRequest) (*CancelCryptoWithdrawReply, error)
	// Teller approve it
	ApproveCryptoWithdraw(context.Context, *ApproveCryptoWithdrawRequest) (*ApproveCryptoWithdrawReply, error)
	// Teller approve it
	SubmitCryptoWithdraw(context.Context, *SubmitCryptoWithdrawRequest) (*SubmitCryptoWithdrawReply, error)
	// Teller reject it
	RejectCryptoWithdraw(context.Context, *RejectCryptoWithdrawRequest) (*RejectCryptoWithdrawReply, error)
	// CreateCryptoTopUp will be done by callback from UMO
	// MEX call to cancel topup if teller hasn't handled it
	CancelCryptoTopUp(context.Context, *CancelCryptoTopUpRequest) (*CancelCryptoTopUpReply, error)
	// Teller approve it
	ApproveCryptoTopUp(context.Context, *ApproveCryptoTopUpRequest) (*ApproveCryptoTopUpReply, error)
	// Teller inject itc
	RejectCryptoTopUp(context.Context, *RejectCryptoTopUpRequest) (*RejectCryptoTopUpReply, error)
	// MEX call to MCU
	GetCryptoWallet(context.Context, *GetCryptoWalletRequest) (*GetCryptoWalletReply, error)
	// Admin APIs
	ValidateCryptoWallets(context.Context, *ValidateCryptoWalletsRequest) (*ValidateCryptoWalletsReply, error)
	ImportCryptoWallets(context.Context, *ImportCryptoWalletsRequest) (*ImportCryptoWalletsReply, error)
	ListCryptoWallets(context.Context, *ListCryptoWalletsRequest) (*ListCryptoWalletsReply, error)
	ValidateCryptoHotWallets(context.Context, *ValidateCryptoHotWalletsRequest) (*ValidateCryptoHotWalletsReply, error)
	ImportCryptoHotWallets(context.Context, *ImportCryptoHotWalletsRequest) (*ImportCryptoHotWalletsReply, error)
	ListCryptoHotWallets(context.Context, *ListCryptoHotWalletsRequest) (*ListCryptoHotWalletsReply, error)
	// Utility API to call for process payment
	GetSystemCryptoHotWallets(context.Context, *GetSystemCryptoHotWalletsRequest) (*GetSystemCryptoHotWalletsReply, error)
	LoadCryptoWallets(context.Context, *LoadCryptoWalletsRequest) (*LoadCryptoWalletsReply, error)
	UpdateAutoTransferCryptoWithdraw(context.Context, *UpdateAutoTransferCryptoWithdrawRequest) (*UpdateAutoTransferCryptoWithdrawReply, error)
	GetCryptoSettings(context.Context, *GetCryptoSettingsRequest) (*GetCryptoSettingsReply, error)
	// Callback from UMO
	CallbackTransaction(context.Context, *CallbackTransactionRequest) (*CallbackTransactionReply, error)
	mustEmbedUnimplementedUltronServer()
}

// UnimplementedUltronServer must be embedded to have forward compatible implementations.
type UnimplementedUltronServer struct {
}

func (*UnimplementedUltronServer) CreateCryptoWithdraw(context.Context, *CreateCryptoWithdrawRequest) (*CreateCryptoWithdrawReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCryptoWithdraw not implemented")
}
func (*UnimplementedUltronServer) CancelCryptoWithdraw(context.Context, *CancelCryptoWithdrawRequest) (*CancelCryptoWithdrawReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelCryptoWithdraw not implemented")
}
func (*UnimplementedUltronServer) ApproveCryptoWithdraw(context.Context, *ApproveCryptoWithdrawRequest) (*ApproveCryptoWithdrawReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApproveCryptoWithdraw not implemented")
}
func (*UnimplementedUltronServer) SubmitCryptoWithdraw(context.Context, *SubmitCryptoWithdrawRequest) (*SubmitCryptoWithdrawReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitCryptoWithdraw not implemented")
}
func (*UnimplementedUltronServer) RejectCryptoWithdraw(context.Context, *RejectCryptoWithdrawRequest) (*RejectCryptoWithdrawReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RejectCryptoWithdraw not implemented")
}
func (*UnimplementedUltronServer) CancelCryptoTopUp(context.Context, *CancelCryptoTopUpRequest) (*CancelCryptoTopUpReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelCryptoTopUp not implemented")
}
func (*UnimplementedUltronServer) ApproveCryptoTopUp(context.Context, *ApproveCryptoTopUpRequest) (*ApproveCryptoTopUpReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApproveCryptoTopUp not implemented")
}
func (*UnimplementedUltronServer) RejectCryptoTopUp(context.Context, *RejectCryptoTopUpRequest) (*RejectCryptoTopUpReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RejectCryptoTopUp not implemented")
}
func (*UnimplementedUltronServer) GetCryptoWallet(context.Context, *GetCryptoWalletRequest) (*GetCryptoWalletReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCryptoWallet not implemented")
}
func (*UnimplementedUltronServer) ValidateCryptoWallets(context.Context, *ValidateCryptoWalletsRequest) (*ValidateCryptoWalletsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateCryptoWallets not implemented")
}
func (*UnimplementedUltronServer) ImportCryptoWallets(context.Context, *ImportCryptoWalletsRequest) (*ImportCryptoWalletsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportCryptoWallets not implemented")
}
func (*UnimplementedUltronServer) ListCryptoWallets(context.Context, *ListCryptoWalletsRequest) (*ListCryptoWalletsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCryptoWallets not implemented")
}
func (*UnimplementedUltronServer) ValidateCryptoHotWallets(context.Context, *ValidateCryptoHotWalletsRequest) (*ValidateCryptoHotWalletsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateCryptoHotWallets not implemented")
}
func (*UnimplementedUltronServer) ImportCryptoHotWallets(context.Context, *ImportCryptoHotWalletsRequest) (*ImportCryptoHotWalletsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportCryptoHotWallets not implemented")
}
func (*UnimplementedUltronServer) ListCryptoHotWallets(context.Context, *ListCryptoHotWalletsRequest) (*ListCryptoHotWalletsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCryptoHotWallets not implemented")
}
func (*UnimplementedUltronServer) GetSystemCryptoHotWallets(context.Context, *GetSystemCryptoHotWalletsRequest) (*GetSystemCryptoHotWalletsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemCryptoHotWallets not implemented")
}
func (*UnimplementedUltronServer) LoadCryptoWallets(context.Context, *LoadCryptoWalletsRequest) (*LoadCryptoWalletsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadCryptoWallets not implemented")
}
func (*UnimplementedUltronServer) UpdateAutoTransferCryptoWithdraw(context.Context, *UpdateAutoTransferCryptoWithdrawRequest) (*UpdateAutoTransferCryptoWithdrawReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAutoTransferCryptoWithdraw not implemented")
}
func (*UnimplementedUltronServer) GetCryptoSettings(context.Context, *GetCryptoSettingsRequest) (*GetCryptoSettingsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCryptoSettings not implemented")
}
func (*UnimplementedUltronServer) CallbackTransaction(context.Context, *CallbackTransactionRequest) (*CallbackTransactionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallbackTransaction not implemented")
}
func (*UnimplementedUltronServer) mustEmbedUnimplementedUltronServer() {}

func RegisterUltronServer(s *grpc.Server, srv UltronServer) {
	s.RegisterService(&_Ultron_serviceDesc, srv)
}

func _Ultron_CreateCryptoWithdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCryptoWithdrawRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).CreateCryptoWithdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/CreateCryptoWithdraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).CreateCryptoWithdraw(ctx, req.(*CreateCryptoWithdrawRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_CancelCryptoWithdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelCryptoWithdrawRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).CancelCryptoWithdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/CancelCryptoWithdraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).CancelCryptoWithdraw(ctx, req.(*CancelCryptoWithdrawRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_ApproveCryptoWithdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveCryptoWithdrawRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).ApproveCryptoWithdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/ApproveCryptoWithdraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).ApproveCryptoWithdraw(ctx, req.(*ApproveCryptoWithdrawRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_SubmitCryptoWithdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitCryptoWithdrawRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).SubmitCryptoWithdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/SubmitCryptoWithdraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).SubmitCryptoWithdraw(ctx, req.(*SubmitCryptoWithdrawRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_RejectCryptoWithdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RejectCryptoWithdrawRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).RejectCryptoWithdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/RejectCryptoWithdraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).RejectCryptoWithdraw(ctx, req.(*RejectCryptoWithdrawRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_CancelCryptoTopUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelCryptoTopUpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).CancelCryptoTopUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/CancelCryptoTopUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).CancelCryptoTopUp(ctx, req.(*CancelCryptoTopUpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_ApproveCryptoTopUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveCryptoTopUpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).ApproveCryptoTopUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/ApproveCryptoTopUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).ApproveCryptoTopUp(ctx, req.(*ApproveCryptoTopUpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_RejectCryptoTopUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RejectCryptoTopUpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).RejectCryptoTopUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/RejectCryptoTopUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).RejectCryptoTopUp(ctx, req.(*RejectCryptoTopUpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_GetCryptoWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCryptoWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).GetCryptoWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/GetCryptoWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).GetCryptoWallet(ctx, req.(*GetCryptoWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_ValidateCryptoWallets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateCryptoWalletsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).ValidateCryptoWallets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/ValidateCryptoWallets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).ValidateCryptoWallets(ctx, req.(*ValidateCryptoWalletsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_ImportCryptoWallets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportCryptoWalletsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).ImportCryptoWallets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/ImportCryptoWallets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).ImportCryptoWallets(ctx, req.(*ImportCryptoWalletsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_ListCryptoWallets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCryptoWalletsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).ListCryptoWallets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/ListCryptoWallets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).ListCryptoWallets(ctx, req.(*ListCryptoWalletsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_ValidateCryptoHotWallets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateCryptoHotWalletsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).ValidateCryptoHotWallets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/ValidateCryptoHotWallets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).ValidateCryptoHotWallets(ctx, req.(*ValidateCryptoHotWalletsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_ImportCryptoHotWallets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportCryptoHotWalletsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).ImportCryptoHotWallets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/ImportCryptoHotWallets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).ImportCryptoHotWallets(ctx, req.(*ImportCryptoHotWalletsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_ListCryptoHotWallets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCryptoHotWalletsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).ListCryptoHotWallets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/ListCryptoHotWallets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).ListCryptoHotWallets(ctx, req.(*ListCryptoHotWalletsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_GetSystemCryptoHotWallets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSystemCryptoHotWalletsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).GetSystemCryptoHotWallets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/GetSystemCryptoHotWallets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).GetSystemCryptoHotWallets(ctx, req.(*GetSystemCryptoHotWalletsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_LoadCryptoWallets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadCryptoWalletsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).LoadCryptoWallets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/LoadCryptoWallets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).LoadCryptoWallets(ctx, req.(*LoadCryptoWalletsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_UpdateAutoTransferCryptoWithdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAutoTransferCryptoWithdrawRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).UpdateAutoTransferCryptoWithdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/UpdateAutoTransferCryptoWithdraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).UpdateAutoTransferCryptoWithdraw(ctx, req.(*UpdateAutoTransferCryptoWithdrawRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_GetCryptoSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCryptoSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).GetCryptoSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/GetCryptoSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).GetCryptoSettings(ctx, req.(*GetCryptoSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ultron_CallbackTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallbackTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UltronServer).CallbackTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mcuc.stark.ultron.Ultron/CallbackTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UltronServer).CallbackTransaction(ctx, req.(*CallbackTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Ultron_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mcuc.stark.ultron.Ultron",
	HandlerType: (*UltronServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCryptoWithdraw",
			Handler:    _Ultron_CreateCryptoWithdraw_Handler,
		},
		{
			MethodName: "CancelCryptoWithdraw",
			Handler:    _Ultron_CancelCryptoWithdraw_Handler,
		},
		{
			MethodName: "ApproveCryptoWithdraw",
			Handler:    _Ultron_ApproveCryptoWithdraw_Handler,
		},
		{
			MethodName: "SubmitCryptoWithdraw",
			Handler:    _Ultron_SubmitCryptoWithdraw_Handler,
		},
		{
			MethodName: "RejectCryptoWithdraw",
			Handler:    _Ultron_RejectCryptoWithdraw_Handler,
		},
		{
			MethodName: "CancelCryptoTopUp",
			Handler:    _Ultron_CancelCryptoTopUp_Handler,
		},
		{
			MethodName: "ApproveCryptoTopUp",
			Handler:    _Ultron_ApproveCryptoTopUp_Handler,
		},
		{
			MethodName: "RejectCryptoTopUp",
			Handler:    _Ultron_RejectCryptoTopUp_Handler,
		},
		{
			MethodName: "GetCryptoWallet",
			Handler:    _Ultron_GetCryptoWallet_Handler,
		},
		{
			MethodName: "ValidateCryptoWallets",
			Handler:    _Ultron_ValidateCryptoWallets_Handler,
		},
		{
			MethodName: "ImportCryptoWallets",
			Handler:    _Ultron_ImportCryptoWallets_Handler,
		},
		{
			MethodName: "ListCryptoWallets",
			Handler:    _Ultron_ListCryptoWallets_Handler,
		},
		{
			MethodName: "ValidateCryptoHotWallets",
			Handler:    _Ultron_ValidateCryptoHotWallets_Handler,
		},
		{
			MethodName: "ImportCryptoHotWallets",
			Handler:    _Ultron_ImportCryptoHotWallets_Handler,
		},
		{
			MethodName: "ListCryptoHotWallets",
			Handler:    _Ultron_ListCryptoHotWallets_Handler,
		},
		{
			MethodName: "GetSystemCryptoHotWallets",
			Handler:    _Ultron_GetSystemCryptoHotWallets_Handler,
		},
		{
			MethodName: "LoadCryptoWallets",
			Handler:    _Ultron_LoadCryptoWallets_Handler,
		},
		{
			MethodName: "UpdateAutoTransferCryptoWithdraw",
			Handler:    _Ultron_UpdateAutoTransferCryptoWithdraw_Handler,
		},
		{
			MethodName: "GetCryptoSettings",
			Handler:    _Ultron_GetCryptoSettings_Handler,
		},
		{
			MethodName: "CallbackTransaction",
			Handler:    _Ultron_CallbackTransaction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "stark/api/ultron.proto",
}
