// Code generated by mockery v2.3.0. DO NOT EDIT.

package mocks

import (
	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	stark "gitlab.com/mcuc/monorepo/backend/stark/pkg/api"
)

// PepperClient is an autogenerated mock type for the PepperClient type
type PepperClient struct {
	mock.Mock
}

// ApproveBankingTopUp provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) ApproveBankingTopUp(ctx context.Context, in *stark.ApproveBankingTopUpRequest, opts ...grpc.CallOption) (*stark.ApproveBankingTopUpReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.ApproveBankingTopUpReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.ApproveBankingTopUpRequest, ...grpc.CallOption) *stark.ApproveBankingTopUpReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.ApproveBankingTopUpReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.ApproveBankingTopUpRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApproveBankingWithdraw provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) ApproveBankingWithdraw(ctx context.Context, in *stark.ApproveBankingWithdrawRequest, opts ...grpc.CallOption) (*stark.ApproveBankingWithdrawReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.ApproveBankingWithdrawReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.ApproveBankingWithdrawRequest, ...grpc.CallOption) *stark.ApproveBankingWithdrawReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.ApproveBankingWithdrawReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.ApproveBankingWithdrawRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelBankingWithdraw provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) CancelBankingWithdraw(ctx context.Context, in *stark.CancelBankingWithdrawRequest, opts ...grpc.CallOption) (*stark.CancelBankingWithdrawReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.CancelBankingWithdrawReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.CancelBankingWithdrawRequest, ...grpc.CallOption) *stark.CancelBankingWithdrawReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.CancelBankingWithdrawReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.CancelBankingWithdrawRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBankingTopUp provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) CreateBankingTopUp(ctx context.Context, in *stark.CreateBankingTopUpRequest, opts ...grpc.CallOption) (*stark.CreateBankingTopUpReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.CreateBankingTopUpReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.CreateBankingTopUpRequest, ...grpc.CallOption) *stark.CreateBankingTopUpReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.CreateBankingTopUpReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.CreateBankingTopUpRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBankingWithdraw provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) CreateBankingWithdraw(ctx context.Context, in *stark.CreateBankingWithdrawRequest, opts ...grpc.CallOption) (*stark.CreateBankingWithdrawReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.CreateBankingWithdrawReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.CreateBankingWithdrawRequest, ...grpc.CallOption) *stark.CreateBankingWithdrawReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.CreateBankingWithdrawReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.CreateBankingWithdrawRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSystemBankAccount provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) CreateSystemBankAccount(ctx context.Context, in *stark.CreateSystemBankAccountRequest, opts ...grpc.CallOption) (*stark.CreateSystemBankAccountReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.CreateSystemBankAccountReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.CreateSystemBankAccountRequest, ...grpc.CallOption) *stark.CreateSystemBankAccountReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.CreateSystemBankAccountReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.CreateSystemBankAccountRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBankPaymentCode provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) GetBankPaymentCode(ctx context.Context, in *stark.GetBankPaymentCodeRequest, opts ...grpc.CallOption) (*stark.GetBankPaymentCodeReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.GetBankPaymentCodeReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.GetBankPaymentCodeRequest, ...grpc.CallOption) *stark.GetBankPaymentCodeReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.GetBankPaymentCodeReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.GetBankPaymentCodeRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIsMerchantUserBankAccountVerified provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) GetIsMerchantUserBankAccountVerified(ctx context.Context, in *stark.GetIsMerchantUserBankAccountVerifiedRequest, opts ...grpc.CallOption) (*stark.GetIsMerchantUserBankAccountVerifiedReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.GetIsMerchantUserBankAccountVerifiedReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.GetIsMerchantUserBankAccountVerifiedRequest, ...grpc.CallOption) *stark.GetIsMerchantUserBankAccountVerifiedReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.GetIsMerchantUserBankAccountVerifiedReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.GetIsMerchantUserBankAccountVerifiedRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportSystemBankAccount provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) ImportSystemBankAccount(ctx context.Context, in *stark.ImportSystemBankAccountRequest, opts ...grpc.CallOption) (*stark.ImportSystemBankAccountReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.ImportSystemBankAccountReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.ImportSystemBankAccountRequest, ...grpc.CallOption) *stark.ImportSystemBankAccountReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.ImportSystemBankAccountReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.ImportSystemBankAccountRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSystemBankAccountByPaymentInfo provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) ListSystemBankAccountByPaymentInfo(ctx context.Context, in *stark.ListSystemBankAccountByPaymentInfoRequest, opts ...grpc.CallOption) (*stark.ListSystemBankAccountByPaymentInfoReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.ListSystemBankAccountByPaymentInfoReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.ListSystemBankAccountByPaymentInfoRequest, ...grpc.CallOption) *stark.ListSystemBankAccountByPaymentInfoReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.ListSystemBankAccountByPaymentInfoReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.ListSystemBankAccountByPaymentInfoRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSystemBankAccounts provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) ListSystemBankAccounts(ctx context.Context, in *stark.ListSystemBankAccountsRequest, opts ...grpc.CallOption) (*stark.ListSystemBankAccountsReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.ListSystemBankAccountsReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.ListSystemBankAccountsRequest, ...grpc.CallOption) *stark.ListSystemBankAccountsReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.ListSystemBankAccountsReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.ListSystemBankAccountsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectBankingTopUp provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) RejectBankingTopUp(ctx context.Context, in *stark.RejectBankingTopUpRequest, opts ...grpc.CallOption) (*stark.RejectBankingTopUpReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.RejectBankingTopUpReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.RejectBankingTopUpRequest, ...grpc.CallOption) *stark.RejectBankingTopUpReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.RejectBankingTopUpReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.RejectBankingTopUpRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectBankingWithdraw provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) RejectBankingWithdraw(ctx context.Context, in *stark.RejectBankingWithdrawRequest, opts ...grpc.CallOption) (*stark.RejectBankingWithdrawReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.RejectBankingWithdrawReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.RejectBankingWithdrawRequest, ...grpc.CallOption) *stark.RejectBankingWithdrawReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.RejectBankingWithdrawReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.RejectBankingWithdrawRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitBankingWithdraw provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) SubmitBankingWithdraw(ctx context.Context, in *stark.SubmitBankingWithdrawRequest, opts ...grpc.CallOption) (*stark.SubmitBankingWithdrawReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.SubmitBankingWithdrawReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.SubmitBankingWithdrawRequest, ...grpc.CallOption) *stark.SubmitBankingWithdrawReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.SubmitBankingWithdrawReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.SubmitBankingWithdrawRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSystemBankAccountStatus provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) UpdateSystemBankAccountStatus(ctx context.Context, in *stark.UpdateSystemBankAccountStatusRequest, opts ...grpc.CallOption) (*stark.UpdateSystemBankAccountStatusReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.UpdateSystemBankAccountStatusReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.UpdateSystemBankAccountStatusRequest, ...grpc.CallOption) *stark.UpdateSystemBankAccountStatusReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.UpdateSystemBankAccountStatusReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.UpdateSystemBankAccountStatusRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidateImportSystemBankAccount provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) ValidateImportSystemBankAccount(ctx context.Context, in *stark.ValidateImportSystemBankAccountRequest, opts ...grpc.CallOption) (*stark.ValidateImportSystemBankAccountReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.ValidateImportSystemBankAccountReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.ValidateImportSystemBankAccountRequest, ...grpc.CallOption) *stark.ValidateImportSystemBankAccountReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.ValidateImportSystemBankAccountReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.ValidateImportSystemBankAccountRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyMerchantUserBankAccount provides a mock function with given fields: ctx, in, opts
func (_m *PepperClient) VerifyMerchantUserBankAccount(ctx context.Context, in *stark.VerifyMerchantUserBankAccountRequest, opts ...grpc.CallOption) (*stark.VerifyMerchantUserBankAccountReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.VerifyMerchantUserBankAccountReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.VerifyMerchantUserBankAccountRequest, ...grpc.CallOption) *stark.VerifyMerchantUserBankAccountReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.VerifyMerchantUserBankAccountReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.VerifyMerchantUserBankAccountRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
