// Code generated by mockery v2.3.0. DO NOT EDIT.

package mocks

import (
	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	stark "gitlab.com/mcuc/monorepo/backend/stark/pkg/api"
)

// UltronClient is an autogenerated mock type for the UltronClient type
type UltronClient struct {
	mock.Mock
}

// ApproveCryptoTopUp provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) ApproveCryptoTopUp(ctx context.Context, in *stark.ApproveCryptoTopUpRequest, opts ...grpc.CallOption) (*stark.ApproveCryptoTopUpReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.ApproveCryptoTopUpReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.ApproveCryptoTopUpRequest, ...grpc.CallOption) *stark.ApproveCryptoTopUpReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.ApproveCryptoTopUpReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.ApproveCryptoTopUpRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApproveCryptoWithdraw provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) ApproveCryptoWithdraw(ctx context.Context, in *stark.ApproveCryptoWithdrawRequest, opts ...grpc.CallOption) (*stark.ApproveCryptoWithdrawReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.ApproveCryptoWithdrawReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.ApproveCryptoWithdrawRequest, ...grpc.CallOption) *stark.ApproveCryptoWithdrawReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.ApproveCryptoWithdrawReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.ApproveCryptoWithdrawRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CallbackTransaction provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) CallbackTransaction(ctx context.Context, in *stark.CallbackTransactionRequest, opts ...grpc.CallOption) (*stark.CallbackTransactionReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.CallbackTransactionReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.CallbackTransactionRequest, ...grpc.CallOption) *stark.CallbackTransactionReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.CallbackTransactionReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.CallbackTransactionRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelCryptoTopUp provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) CancelCryptoTopUp(ctx context.Context, in *stark.CancelCryptoTopUpRequest, opts ...grpc.CallOption) (*stark.CancelCryptoTopUpReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.CancelCryptoTopUpReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.CancelCryptoTopUpRequest, ...grpc.CallOption) *stark.CancelCryptoTopUpReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.CancelCryptoTopUpReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.CancelCryptoTopUpRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CancelCryptoWithdraw provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) CancelCryptoWithdraw(ctx context.Context, in *stark.CancelCryptoWithdrawRequest, opts ...grpc.CallOption) (*stark.CancelCryptoWithdrawReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.CancelCryptoWithdrawReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.CancelCryptoWithdrawRequest, ...grpc.CallOption) *stark.CancelCryptoWithdrawReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.CancelCryptoWithdrawReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.CancelCryptoWithdrawRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateCryptoWithdraw provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) CreateCryptoWithdraw(ctx context.Context, in *stark.CreateCryptoWithdrawRequest, opts ...grpc.CallOption) (*stark.CreateCryptoWithdrawReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.CreateCryptoWithdrawReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.CreateCryptoWithdrawRequest, ...grpc.CallOption) *stark.CreateCryptoWithdrawReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.CreateCryptoWithdrawReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.CreateCryptoWithdrawRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCryptoSettings provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) GetCryptoSettings(ctx context.Context, in *stark.GetCryptoSettingsRequest, opts ...grpc.CallOption) (*stark.GetCryptoSettingsReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.GetCryptoSettingsReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.GetCryptoSettingsRequest, ...grpc.CallOption) *stark.GetCryptoSettingsReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.GetCryptoSettingsReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.GetCryptoSettingsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCryptoWallet provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) GetCryptoWallet(ctx context.Context, in *stark.GetCryptoWalletRequest, opts ...grpc.CallOption) (*stark.GetCryptoWalletReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.GetCryptoWalletReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.GetCryptoWalletRequest, ...grpc.CallOption) *stark.GetCryptoWalletReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.GetCryptoWalletReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.GetCryptoWalletRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSystemCryptoHotWallets provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) GetSystemCryptoHotWallets(ctx context.Context, in *stark.GetSystemCryptoHotWalletsRequest, opts ...grpc.CallOption) (*stark.GetSystemCryptoHotWalletsReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.GetSystemCryptoHotWalletsReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.GetSystemCryptoHotWalletsRequest, ...grpc.CallOption) *stark.GetSystemCryptoHotWalletsReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.GetSystemCryptoHotWalletsReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.GetSystemCryptoHotWalletsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportCryptoHotWallets provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) ImportCryptoHotWallets(ctx context.Context, in *stark.ImportCryptoHotWalletsRequest, opts ...grpc.CallOption) (*stark.ImportCryptoHotWalletsReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.ImportCryptoHotWalletsReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.ImportCryptoHotWalletsRequest, ...grpc.CallOption) *stark.ImportCryptoHotWalletsReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.ImportCryptoHotWalletsReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.ImportCryptoHotWalletsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportCryptoWallets provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) ImportCryptoWallets(ctx context.Context, in *stark.ImportCryptoWalletsRequest, opts ...grpc.CallOption) (*stark.ImportCryptoWalletsReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.ImportCryptoWalletsReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.ImportCryptoWalletsRequest, ...grpc.CallOption) *stark.ImportCryptoWalletsReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.ImportCryptoWalletsReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.ImportCryptoWalletsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCryptoHotWallets provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) ListCryptoHotWallets(ctx context.Context, in *stark.ListCryptoHotWalletsRequest, opts ...grpc.CallOption) (*stark.ListCryptoHotWalletsReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.ListCryptoHotWalletsReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.ListCryptoHotWalletsRequest, ...grpc.CallOption) *stark.ListCryptoHotWalletsReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.ListCryptoHotWalletsReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.ListCryptoHotWalletsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCryptoWallets provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) ListCryptoWallets(ctx context.Context, in *stark.ListCryptoWalletsRequest, opts ...grpc.CallOption) (*stark.ListCryptoWalletsReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.ListCryptoWalletsReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.ListCryptoWalletsRequest, ...grpc.CallOption) *stark.ListCryptoWalletsReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.ListCryptoWalletsReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.ListCryptoWalletsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoadCryptoWallets provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) LoadCryptoWallets(ctx context.Context, in *stark.LoadCryptoWalletsRequest, opts ...grpc.CallOption) (*stark.LoadCryptoWalletsReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.LoadCryptoWalletsReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.LoadCryptoWalletsRequest, ...grpc.CallOption) *stark.LoadCryptoWalletsReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.LoadCryptoWalletsReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.LoadCryptoWalletsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectCryptoTopUp provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) RejectCryptoTopUp(ctx context.Context, in *stark.RejectCryptoTopUpRequest, opts ...grpc.CallOption) (*stark.RejectCryptoTopUpReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.RejectCryptoTopUpReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.RejectCryptoTopUpRequest, ...grpc.CallOption) *stark.RejectCryptoTopUpReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.RejectCryptoTopUpReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.RejectCryptoTopUpRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RejectCryptoWithdraw provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) RejectCryptoWithdraw(ctx context.Context, in *stark.RejectCryptoWithdrawRequest, opts ...grpc.CallOption) (*stark.RejectCryptoWithdrawReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.RejectCryptoWithdrawReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.RejectCryptoWithdrawRequest, ...grpc.CallOption) *stark.RejectCryptoWithdrawReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.RejectCryptoWithdrawReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.RejectCryptoWithdrawRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitCryptoWithdraw provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) SubmitCryptoWithdraw(ctx context.Context, in *stark.SubmitCryptoWithdrawRequest, opts ...grpc.CallOption) (*stark.SubmitCryptoWithdrawReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.SubmitCryptoWithdrawReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.SubmitCryptoWithdrawRequest, ...grpc.CallOption) *stark.SubmitCryptoWithdrawReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.SubmitCryptoWithdrawReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.SubmitCryptoWithdrawRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAutoTransferCryptoWithdraw provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) UpdateAutoTransferCryptoWithdraw(ctx context.Context, in *stark.UpdateAutoTransferCryptoWithdrawRequest, opts ...grpc.CallOption) (*stark.UpdateAutoTransferCryptoWithdrawReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.UpdateAutoTransferCryptoWithdrawReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.UpdateAutoTransferCryptoWithdrawRequest, ...grpc.CallOption) *stark.UpdateAutoTransferCryptoWithdrawReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.UpdateAutoTransferCryptoWithdrawReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.UpdateAutoTransferCryptoWithdrawRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidateCryptoHotWallets provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) ValidateCryptoHotWallets(ctx context.Context, in *stark.ValidateCryptoHotWalletsRequest, opts ...grpc.CallOption) (*stark.ValidateCryptoHotWalletsReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.ValidateCryptoHotWalletsReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.ValidateCryptoHotWalletsRequest, ...grpc.CallOption) *stark.ValidateCryptoHotWalletsReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.ValidateCryptoHotWalletsReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.ValidateCryptoHotWalletsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidateCryptoWallets provides a mock function with given fields: ctx, in, opts
func (_m *UltronClient) ValidateCryptoWallets(ctx context.Context, in *stark.ValidateCryptoWalletsRequest, opts ...grpc.CallOption) (*stark.ValidateCryptoWalletsReply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *stark.ValidateCryptoWalletsReply
	if rf, ok := ret.Get(0).(func(context.Context, *stark.ValidateCryptoWalletsRequest, ...grpc.CallOption) *stark.ValidateCryptoWalletsReply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stark.ValidateCryptoWalletsReply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *stark.ValidateCryptoWalletsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
