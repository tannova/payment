// Code generated by night-kit. DO NOT EDIT.
// Version v0.5.47

package server

import (
	"context"
	"fmt"
	"net"
	"os"

	"github.com/DataDog/datadog-go/statsd"
	grpcmiddleware "github.com/grpc-ecosystem/go-grpc-middleware"
	grpczap "github.com/grpc-ecosystem/go-grpc-middleware/logging/zap"
	"github.com/grpc-ecosystem/go-grpc-middleware/logging/zap/ctxzap"
	grpcctxtags "github.com/grpc-ecosystem/go-grpc-middleware/tags"
	nightkit "gitlab.com/greyhole/night-kit/pkg/api"
	config "gitlab.com/greyhole/night-kit/pkg/config"
	"gitlab.com/greyhole/night-kit/pkg/logging"
	conf "gitlab.com/mcuc/monorepo/backend/natasha/pkg/config"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/health"
	healthv1 "google.golang.org/grpc/health/grpc_health_v1"
	"google.golang.org/grpc/metadata"
)

func Run(f *config.Flags) {
	cfg := loadConfig(f)
	service := newService(cfg)

	Serve(cfg, service)
}

func newService(cfg *conf.Config) nightkit.Service {
	statsd, err := statsd.New(os.Getenv("DOGSTATSD_HOST_IP") + ":8125")
	if err != nil {
		logging.NewTmpLogger().Error("fail to create datadog client", zap.Error(err))
	}
	statsd.Namespace = "gostatsd."

	err = logging.InitLogger(cfg.Logger)
	if err != nil {
		logging.NewTmpLogger().Error("fail to init logger", zap.Error(err))
	}

	logger := logging.Logger(nil)

	listener, err := net.Listen("tcp", fmt.Sprintf("%s:%d", cfg.Listener.GetTcp().Address, cfg.Listener.GetTcp().Port))
	if err != nil {
		logging.NewTmpLogger().Fatal("failed to new listener", zap.Error(err))
	}

	opts := []grpczap.Option{
		grpczap.WithMessageProducer(func(ctx context.Context, msg string, level zapcore.Level, code codes.Code, err error, duration zapcore.Field) {
			// re-extract logger from newCtx, as it may have extra fields that changed in the holder.
			ctxzap.Extract(ctx).Check(level, msg).Write(
				zap.Error(err),
				zap.String("grpc.code", code.String()),
				zap.String("x_request_id", GetRequestID(ctx)),
				duration,
			)
		}),
	}

	server := grpc.NewServer(
		grpc.UnaryInterceptor(
			grpcmiddleware.ChainUnaryServer(
				grpcctxtags.UnaryServerInterceptor(
					grpcctxtags.WithFieldExtractor(
						grpcctxtags.CodeGenRequestFieldExtractor,
					),
				),
				grpczap.UnaryServerInterceptor(logger, opts...),
			),
		),
	)

	healthServer := health.NewServer()
	healthServer.SetServingStatus("", healthv1.HealthCheckResponse_SERVING)
	healthv1.RegisterHealthServer(server, healthServer)

	s := nightkit.NewService(
		nightkit.Stats(
			statsd,
		),
		nightkit.Logger(logger),
		nightkit.Listener(listener),
		nightkit.Server(server),
		nightkit.HealthServer(healthServer),
	)

	return s
}

func GetRequestID(ctx context.Context) string {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return ""
	}
	mdUserID := md.Get("x-request-id")
	if len(mdUserID) < 1 {
		return ""
	}
	return mdUserID[0]
}

func loadConfig(f *config.Flags) *conf.Config {
	// Use a temporary logger to parse the configuration and output.
	tmpLogger := logging.NewTmpLogger().With(zap.String("filename", f.ConfigPath))

	var cfg conf.Config
	if err := config.ParseFile(f.ConfigPath, &cfg, f.Template); err != nil {
		tmpLogger.Fatal("parsing configuration failed", zap.Error(err))
	}

	if err := cfg.Validate(); err != nil {
		tmpLogger.Fatal("validating configuration failed", zap.Error(err))
	}

	if f.Validate {
		tmpLogger.Info("configuration validation was successful")
		os.Exit(0)
	}

	return &cfg
}
