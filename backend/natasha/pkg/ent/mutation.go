// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"gitlab.com/mcuc/monorepo/backend/natasha/pkg/ent/merchant"
	"gitlab.com/mcuc/monorepo/backend/natasha/pkg/ent/payment"
	"gitlab.com/mcuc/monorepo/backend/natasha/pkg/ent/predicate"
	"gitlab.com/mcuc/monorepo/backend/natasha/pkg/ent/voucher"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMerchant = "Merchant"
	TypePayment  = "Payment"
	TypeVoucher  = "Voucher"
)

// MerchantMutation represents an operation that mutates the Merchant nodes in the graph.
type MerchantMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	name              *string
	email_contact     *string
	logo_path         *string
	webhook_url       *string
	slack_webhook_url *string
	safety_limit      *uint64
	addsafety_limit   *uint64
	created_by        *string
	updated_by        *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Merchant, error)
	predicates        []predicate.Merchant
}

var _ ent.Mutation = (*MerchantMutation)(nil)

// merchantOption allows management of the mutation configuration using functional options.
type merchantOption func(*MerchantMutation)

// newMerchantMutation creates new mutation for the Merchant entity.
func newMerchantMutation(c config, op Op, opts ...merchantOption) *MerchantMutation {
	m := &MerchantMutation{
		config:        c,
		op:            op,
		typ:           TypeMerchant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMerchantID sets the ID field of the mutation.
func withMerchantID(id int64) merchantOption {
	return func(m *MerchantMutation) {
		var (
			err   error
			once  sync.Once
			value *Merchant
		)
		m.oldValue = func(ctx context.Context) (*Merchant, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Merchant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMerchant sets the old Merchant of the mutation.
func withMerchant(node *Merchant) merchantOption {
	return func(m *MerchantMutation) {
		m.oldValue = func(context.Context) (*Merchant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MerchantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MerchantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Merchant entities.
func (m *MerchantMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *MerchantMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *MerchantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MerchantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MerchantMutation) ResetName() {
	m.name = nil
}

// SetEmailContact sets the "email_contact" field.
func (m *MerchantMutation) SetEmailContact(s string) {
	m.email_contact = &s
}

// EmailContact returns the value of the "email_contact" field in the mutation.
func (m *MerchantMutation) EmailContact() (r string, exists bool) {
	v := m.email_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailContact returns the old "email_contact" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldEmailContact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmailContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmailContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailContact: %w", err)
	}
	return oldValue.EmailContact, nil
}

// ResetEmailContact resets all changes to the "email_contact" field.
func (m *MerchantMutation) ResetEmailContact() {
	m.email_contact = nil
}

// SetLogoPath sets the "logo_path" field.
func (m *MerchantMutation) SetLogoPath(s string) {
	m.logo_path = &s
}

// LogoPath returns the value of the "logo_path" field in the mutation.
func (m *MerchantMutation) LogoPath() (r string, exists bool) {
	v := m.logo_path
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoPath returns the old "logo_path" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldLogoPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLogoPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLogoPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoPath: %w", err)
	}
	return oldValue.LogoPath, nil
}

// ResetLogoPath resets all changes to the "logo_path" field.
func (m *MerchantMutation) ResetLogoPath() {
	m.logo_path = nil
}

// SetWebhookURL sets the "webhook_url" field.
func (m *MerchantMutation) SetWebhookURL(s string) {
	m.webhook_url = &s
}

// WebhookURL returns the value of the "webhook_url" field in the mutation.
func (m *MerchantMutation) WebhookURL() (r string, exists bool) {
	v := m.webhook_url
	if v == nil {
		return
	}
	return *v, true
}

// OldWebhookURL returns the old "webhook_url" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldWebhookURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWebhookURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWebhookURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebhookURL: %w", err)
	}
	return oldValue.WebhookURL, nil
}

// ResetWebhookURL resets all changes to the "webhook_url" field.
func (m *MerchantMutation) ResetWebhookURL() {
	m.webhook_url = nil
}

// SetSlackWebhookURL sets the "slack_webhook_url" field.
func (m *MerchantMutation) SetSlackWebhookURL(s string) {
	m.slack_webhook_url = &s
}

// SlackWebhookURL returns the value of the "slack_webhook_url" field in the mutation.
func (m *MerchantMutation) SlackWebhookURL() (r string, exists bool) {
	v := m.slack_webhook_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSlackWebhookURL returns the old "slack_webhook_url" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldSlackWebhookURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSlackWebhookURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSlackWebhookURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlackWebhookURL: %w", err)
	}
	return oldValue.SlackWebhookURL, nil
}

// ResetSlackWebhookURL resets all changes to the "slack_webhook_url" field.
func (m *MerchantMutation) ResetSlackWebhookURL() {
	m.slack_webhook_url = nil
}

// SetSafetyLimit sets the "safety_limit" field.
func (m *MerchantMutation) SetSafetyLimit(u uint64) {
	m.safety_limit = &u
	m.addsafety_limit = nil
}

// SafetyLimit returns the value of the "safety_limit" field in the mutation.
func (m *MerchantMutation) SafetyLimit() (r uint64, exists bool) {
	v := m.safety_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldSafetyLimit returns the old "safety_limit" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldSafetyLimit(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSafetyLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSafetyLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSafetyLimit: %w", err)
	}
	return oldValue.SafetyLimit, nil
}

// AddSafetyLimit adds u to the "safety_limit" field.
func (m *MerchantMutation) AddSafetyLimit(u uint64) {
	if m.addsafety_limit != nil {
		*m.addsafety_limit += u
	} else {
		m.addsafety_limit = &u
	}
}

// AddedSafetyLimit returns the value that was added to the "safety_limit" field in this mutation.
func (m *MerchantMutation) AddedSafetyLimit() (r uint64, exists bool) {
	v := m.addsafety_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetSafetyLimit resets all changes to the "safety_limit" field.
func (m *MerchantMutation) ResetSafetyLimit() {
	m.safety_limit = nil
	m.addsafety_limit = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *MerchantMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MerchantMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MerchantMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MerchantMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MerchantMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MerchantMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MerchantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MerchantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MerchantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MerchantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MerchantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MerchantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Op returns the operation name.
func (m *MerchantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Merchant).
func (m *MerchantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MerchantMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, merchant.FieldName)
	}
	if m.email_contact != nil {
		fields = append(fields, merchant.FieldEmailContact)
	}
	if m.logo_path != nil {
		fields = append(fields, merchant.FieldLogoPath)
	}
	if m.webhook_url != nil {
		fields = append(fields, merchant.FieldWebhookURL)
	}
	if m.slack_webhook_url != nil {
		fields = append(fields, merchant.FieldSlackWebhookURL)
	}
	if m.safety_limit != nil {
		fields = append(fields, merchant.FieldSafetyLimit)
	}
	if m.created_by != nil {
		fields = append(fields, merchant.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, merchant.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, merchant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, merchant.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MerchantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case merchant.FieldName:
		return m.Name()
	case merchant.FieldEmailContact:
		return m.EmailContact()
	case merchant.FieldLogoPath:
		return m.LogoPath()
	case merchant.FieldWebhookURL:
		return m.WebhookURL()
	case merchant.FieldSlackWebhookURL:
		return m.SlackWebhookURL()
	case merchant.FieldSafetyLimit:
		return m.SafetyLimit()
	case merchant.FieldCreatedBy:
		return m.CreatedBy()
	case merchant.FieldUpdatedBy:
		return m.UpdatedBy()
	case merchant.FieldCreatedAt:
		return m.CreatedAt()
	case merchant.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MerchantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case merchant.FieldName:
		return m.OldName(ctx)
	case merchant.FieldEmailContact:
		return m.OldEmailContact(ctx)
	case merchant.FieldLogoPath:
		return m.OldLogoPath(ctx)
	case merchant.FieldWebhookURL:
		return m.OldWebhookURL(ctx)
	case merchant.FieldSlackWebhookURL:
		return m.OldSlackWebhookURL(ctx)
	case merchant.FieldSafetyLimit:
		return m.OldSafetyLimit(ctx)
	case merchant.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case merchant.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case merchant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case merchant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Merchant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case merchant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case merchant.FieldEmailContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailContact(v)
		return nil
	case merchant.FieldLogoPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoPath(v)
		return nil
	case merchant.FieldWebhookURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebhookURL(v)
		return nil
	case merchant.FieldSlackWebhookURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlackWebhookURL(v)
		return nil
	case merchant.FieldSafetyLimit:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSafetyLimit(v)
		return nil
	case merchant.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case merchant.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case merchant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case merchant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Merchant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MerchantMutation) AddedFields() []string {
	var fields []string
	if m.addsafety_limit != nil {
		fields = append(fields, merchant.FieldSafetyLimit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MerchantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case merchant.FieldSafetyLimit:
		return m.AddedSafetyLimit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case merchant.FieldSafetyLimit:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSafetyLimit(v)
		return nil
	}
	return fmt.Errorf("unknown Merchant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MerchantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MerchantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MerchantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Merchant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MerchantMutation) ResetField(name string) error {
	switch name {
	case merchant.FieldName:
		m.ResetName()
		return nil
	case merchant.FieldEmailContact:
		m.ResetEmailContact()
		return nil
	case merchant.FieldLogoPath:
		m.ResetLogoPath()
		return nil
	case merchant.FieldWebhookURL:
		m.ResetWebhookURL()
		return nil
	case merchant.FieldSlackWebhookURL:
		m.ResetSlackWebhookURL()
		return nil
	case merchant.FieldSafetyLimit:
		m.ResetSafetyLimit()
		return nil
	case merchant.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case merchant.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case merchant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case merchant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Merchant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MerchantMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MerchantMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MerchantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MerchantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MerchantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MerchantMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MerchantMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Merchant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MerchantMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Merchant edge %s", name)
}

// PaymentMutation represents an operation that mutates the Payment nodes in the graph.
type PaymentMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	merchant_id    *int64
	addmerchant_id *int64
	_type          *int32
	add_type       *int32
	amount         *int64
	addamount      *int64
	created_at     *time.Time
	updated_at     *time.Time
	created_by     *string
	updated_by     *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Payment, error)
	predicates     []predicate.Payment
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows management of the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for the Payment entity.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the ID field of the mutation.
func withPaymentID(id int64) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Payment entities.
func (m *PaymentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PaymentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetMerchantID sets the "merchant_id" field.
func (m *PaymentMutation) SetMerchantID(i int64) {
	m.merchant_id = &i
	m.addmerchant_id = nil
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *PaymentMutation) MerchantID() (r int64, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldMerchantID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// AddMerchantID adds i to the "merchant_id" field.
func (m *PaymentMutation) AddMerchantID(i int64) {
	if m.addmerchant_id != nil {
		*m.addmerchant_id += i
	} else {
		m.addmerchant_id = &i
	}
}

// AddedMerchantID returns the value that was added to the "merchant_id" field in this mutation.
func (m *PaymentMutation) AddedMerchantID() (r int64, exists bool) {
	v := m.addmerchant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *PaymentMutation) ResetMerchantID() {
	m.merchant_id = nil
	m.addmerchant_id = nil
}

// SetType sets the "type" field.
func (m *PaymentMutation) SetType(i int32) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *PaymentMutation) GetType() (r int32, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *PaymentMutation) AddType(i int32) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *PaymentMutation) AddedType() (r int32, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *PaymentMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetAmount sets the "amount" field.
func (m *PaymentMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *PaymentMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PaymentMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PaymentMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PaymentMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PaymentMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PaymentMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PaymentMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.merchant_id != nil {
		fields = append(fields, payment.FieldMerchantID)
	}
	if m._type != nil {
		fields = append(fields, payment.FieldType)
	}
	if m.amount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	if m.created_at != nil {
		fields = append(fields, payment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, payment.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, payment.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, payment.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldMerchantID:
		return m.MerchantID()
	case payment.FieldType:
		return m.GetType()
	case payment.FieldAmount:
		return m.Amount()
	case payment.FieldCreatedAt:
		return m.CreatedAt()
	case payment.FieldUpdatedAt:
		return m.UpdatedAt()
	case payment.FieldCreatedBy:
		return m.CreatedBy()
	case payment.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case payment.FieldType:
		return m.OldType(ctx)
	case payment.FieldAmount:
		return m.OldAmount(ctx)
	case payment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case payment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case payment.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case payment.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldMerchantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case payment.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case payment.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case payment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case payment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case payment.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case payment.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMutation) AddedFields() []string {
	var fields []string
	if m.addmerchant_id != nil {
		fields = append(fields, payment.FieldMerchantID)
	}
	if m.add_type != nil {
		fields = append(fields, payment.FieldType)
	}
	if m.addamount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldMerchantID:
		return m.AddedMerchantID()
	case payment.FieldType:
		return m.AddedType()
	case payment.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payment.FieldMerchantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMerchantID(v)
		return nil
	case payment.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case payment.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case payment.FieldType:
		m.ResetType()
		return nil
	case payment.FieldAmount:
		m.ResetAmount()
		return nil
	case payment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case payment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case payment.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case payment.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Payment edge %s", name)
}

// VoucherMutation represents an operation that mutates the Voucher nodes in the graph.
type VoucherMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	merchant_id       *int64
	addmerchant_id    *int64
	payment_id        *int64
	addpayment_id     *int64
	amount            *int64
	addamount         *int64
	_type             *int32
	add_type          *int32
	status            *int32
	addstatus         *int32
	payee_provider    *int32
	addpayee_provider *int32
	payee_account     *string
	payee_name        *string
	payer_provider    *int32
	addpayer_provider *int32
	payer_account     *string
	payer_name        *string
	tx_id             *string
	image_url         *string
	creator_note      *string
	handled_by        *string
	handler_note      *string
	created_at        *time.Time
	updated_at        *time.Time
	created_by        *string
	updated_by        *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Voucher, error)
	predicates        []predicate.Voucher
}

var _ ent.Mutation = (*VoucherMutation)(nil)

// voucherOption allows management of the mutation configuration using functional options.
type voucherOption func(*VoucherMutation)

// newVoucherMutation creates new mutation for the Voucher entity.
func newVoucherMutation(c config, op Op, opts ...voucherOption) *VoucherMutation {
	m := &VoucherMutation{
		config:        c,
		op:            op,
		typ:           TypeVoucher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVoucherID sets the ID field of the mutation.
func withVoucherID(id int64) voucherOption {
	return func(m *VoucherMutation) {
		var (
			err   error
			once  sync.Once
			value *Voucher
		)
		m.oldValue = func(ctx context.Context) (*Voucher, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Voucher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVoucher sets the old Voucher of the mutation.
func withVoucher(node *Voucher) voucherOption {
	return func(m *VoucherMutation) {
		m.oldValue = func(context.Context) (*Voucher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VoucherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VoucherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Voucher entities.
func (m *VoucherMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *VoucherMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetMerchantID sets the "merchant_id" field.
func (m *VoucherMutation) SetMerchantID(i int64) {
	m.merchant_id = &i
	m.addmerchant_id = nil
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *VoucherMutation) MerchantID() (r int64, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldMerchantID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// AddMerchantID adds i to the "merchant_id" field.
func (m *VoucherMutation) AddMerchantID(i int64) {
	if m.addmerchant_id != nil {
		*m.addmerchant_id += i
	} else {
		m.addmerchant_id = &i
	}
}

// AddedMerchantID returns the value that was added to the "merchant_id" field in this mutation.
func (m *VoucherMutation) AddedMerchantID() (r int64, exists bool) {
	v := m.addmerchant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *VoucherMutation) ResetMerchantID() {
	m.merchant_id = nil
	m.addmerchant_id = nil
}

// SetPaymentID sets the "payment_id" field.
func (m *VoucherMutation) SetPaymentID(i int64) {
	m.payment_id = &i
	m.addpayment_id = nil
}

// PaymentID returns the value of the "payment_id" field in the mutation.
func (m *VoucherMutation) PaymentID() (r int64, exists bool) {
	v := m.payment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentID returns the old "payment_id" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldPaymentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentID: %w", err)
	}
	return oldValue.PaymentID, nil
}

// AddPaymentID adds i to the "payment_id" field.
func (m *VoucherMutation) AddPaymentID(i int64) {
	if m.addpayment_id != nil {
		*m.addpayment_id += i
	} else {
		m.addpayment_id = &i
	}
}

// AddedPaymentID returns the value that was added to the "payment_id" field in this mutation.
func (m *VoucherMutation) AddedPaymentID() (r int64, exists bool) {
	v := m.addpayment_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaymentID clears the value of the "payment_id" field.
func (m *VoucherMutation) ClearPaymentID() {
	m.payment_id = nil
	m.addpayment_id = nil
	m.clearedFields[voucher.FieldPaymentID] = struct{}{}
}

// PaymentIDCleared returns if the "payment_id" field was cleared in this mutation.
func (m *VoucherMutation) PaymentIDCleared() bool {
	_, ok := m.clearedFields[voucher.FieldPaymentID]
	return ok
}

// ResetPaymentID resets all changes to the "payment_id" field.
func (m *VoucherMutation) ResetPaymentID() {
	m.payment_id = nil
	m.addpayment_id = nil
	delete(m.clearedFields, voucher.FieldPaymentID)
}

// SetAmount sets the "amount" field.
func (m *VoucherMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *VoucherMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *VoucherMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *VoucherMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *VoucherMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetType sets the "type" field.
func (m *VoucherMutation) SetType(i int32) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *VoucherMutation) GetType() (r int32, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *VoucherMutation) AddType(i int32) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *VoucherMutation) AddedType() (r int32, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *VoucherMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetStatus sets the "status" field.
func (m *VoucherMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VoucherMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VoucherMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VoucherMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *VoucherMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[voucher.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *VoucherMutation) StatusCleared() bool {
	_, ok := m.clearedFields[voucher.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *VoucherMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, voucher.FieldStatus)
}

// SetPayeeProvider sets the "payee_provider" field.
func (m *VoucherMutation) SetPayeeProvider(i int32) {
	m.payee_provider = &i
	m.addpayee_provider = nil
}

// PayeeProvider returns the value of the "payee_provider" field in the mutation.
func (m *VoucherMutation) PayeeProvider() (r int32, exists bool) {
	v := m.payee_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldPayeeProvider returns the old "payee_provider" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldPayeeProvider(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayeeProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayeeProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayeeProvider: %w", err)
	}
	return oldValue.PayeeProvider, nil
}

// AddPayeeProvider adds i to the "payee_provider" field.
func (m *VoucherMutation) AddPayeeProvider(i int32) {
	if m.addpayee_provider != nil {
		*m.addpayee_provider += i
	} else {
		m.addpayee_provider = &i
	}
}

// AddedPayeeProvider returns the value that was added to the "payee_provider" field in this mutation.
func (m *VoucherMutation) AddedPayeeProvider() (r int32, exists bool) {
	v := m.addpayee_provider
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayeeProvider clears the value of the "payee_provider" field.
func (m *VoucherMutation) ClearPayeeProvider() {
	m.payee_provider = nil
	m.addpayee_provider = nil
	m.clearedFields[voucher.FieldPayeeProvider] = struct{}{}
}

// PayeeProviderCleared returns if the "payee_provider" field was cleared in this mutation.
func (m *VoucherMutation) PayeeProviderCleared() bool {
	_, ok := m.clearedFields[voucher.FieldPayeeProvider]
	return ok
}

// ResetPayeeProvider resets all changes to the "payee_provider" field.
func (m *VoucherMutation) ResetPayeeProvider() {
	m.payee_provider = nil
	m.addpayee_provider = nil
	delete(m.clearedFields, voucher.FieldPayeeProvider)
}

// SetPayeeAccount sets the "payee_account" field.
func (m *VoucherMutation) SetPayeeAccount(s string) {
	m.payee_account = &s
}

// PayeeAccount returns the value of the "payee_account" field in the mutation.
func (m *VoucherMutation) PayeeAccount() (r string, exists bool) {
	v := m.payee_account
	if v == nil {
		return
	}
	return *v, true
}

// OldPayeeAccount returns the old "payee_account" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldPayeeAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayeeAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayeeAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayeeAccount: %w", err)
	}
	return oldValue.PayeeAccount, nil
}

// ClearPayeeAccount clears the value of the "payee_account" field.
func (m *VoucherMutation) ClearPayeeAccount() {
	m.payee_account = nil
	m.clearedFields[voucher.FieldPayeeAccount] = struct{}{}
}

// PayeeAccountCleared returns if the "payee_account" field was cleared in this mutation.
func (m *VoucherMutation) PayeeAccountCleared() bool {
	_, ok := m.clearedFields[voucher.FieldPayeeAccount]
	return ok
}

// ResetPayeeAccount resets all changes to the "payee_account" field.
func (m *VoucherMutation) ResetPayeeAccount() {
	m.payee_account = nil
	delete(m.clearedFields, voucher.FieldPayeeAccount)
}

// SetPayeeName sets the "payee_name" field.
func (m *VoucherMutation) SetPayeeName(s string) {
	m.payee_name = &s
}

// PayeeName returns the value of the "payee_name" field in the mutation.
func (m *VoucherMutation) PayeeName() (r string, exists bool) {
	v := m.payee_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPayeeName returns the old "payee_name" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldPayeeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayeeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayeeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayeeName: %w", err)
	}
	return oldValue.PayeeName, nil
}

// ClearPayeeName clears the value of the "payee_name" field.
func (m *VoucherMutation) ClearPayeeName() {
	m.payee_name = nil
	m.clearedFields[voucher.FieldPayeeName] = struct{}{}
}

// PayeeNameCleared returns if the "payee_name" field was cleared in this mutation.
func (m *VoucherMutation) PayeeNameCleared() bool {
	_, ok := m.clearedFields[voucher.FieldPayeeName]
	return ok
}

// ResetPayeeName resets all changes to the "payee_name" field.
func (m *VoucherMutation) ResetPayeeName() {
	m.payee_name = nil
	delete(m.clearedFields, voucher.FieldPayeeName)
}

// SetPayerProvider sets the "payer_provider" field.
func (m *VoucherMutation) SetPayerProvider(i int32) {
	m.payer_provider = &i
	m.addpayer_provider = nil
}

// PayerProvider returns the value of the "payer_provider" field in the mutation.
func (m *VoucherMutation) PayerProvider() (r int32, exists bool) {
	v := m.payer_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldPayerProvider returns the old "payer_provider" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldPayerProvider(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayerProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayerProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayerProvider: %w", err)
	}
	return oldValue.PayerProvider, nil
}

// AddPayerProvider adds i to the "payer_provider" field.
func (m *VoucherMutation) AddPayerProvider(i int32) {
	if m.addpayer_provider != nil {
		*m.addpayer_provider += i
	} else {
		m.addpayer_provider = &i
	}
}

// AddedPayerProvider returns the value that was added to the "payer_provider" field in this mutation.
func (m *VoucherMutation) AddedPayerProvider() (r int32, exists bool) {
	v := m.addpayer_provider
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayerProvider clears the value of the "payer_provider" field.
func (m *VoucherMutation) ClearPayerProvider() {
	m.payer_provider = nil
	m.addpayer_provider = nil
	m.clearedFields[voucher.FieldPayerProvider] = struct{}{}
}

// PayerProviderCleared returns if the "payer_provider" field was cleared in this mutation.
func (m *VoucherMutation) PayerProviderCleared() bool {
	_, ok := m.clearedFields[voucher.FieldPayerProvider]
	return ok
}

// ResetPayerProvider resets all changes to the "payer_provider" field.
func (m *VoucherMutation) ResetPayerProvider() {
	m.payer_provider = nil
	m.addpayer_provider = nil
	delete(m.clearedFields, voucher.FieldPayerProvider)
}

// SetPayerAccount sets the "payer_account" field.
func (m *VoucherMutation) SetPayerAccount(s string) {
	m.payer_account = &s
}

// PayerAccount returns the value of the "payer_account" field in the mutation.
func (m *VoucherMutation) PayerAccount() (r string, exists bool) {
	v := m.payer_account
	if v == nil {
		return
	}
	return *v, true
}

// OldPayerAccount returns the old "payer_account" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldPayerAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayerAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayerAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayerAccount: %w", err)
	}
	return oldValue.PayerAccount, nil
}

// ClearPayerAccount clears the value of the "payer_account" field.
func (m *VoucherMutation) ClearPayerAccount() {
	m.payer_account = nil
	m.clearedFields[voucher.FieldPayerAccount] = struct{}{}
}

// PayerAccountCleared returns if the "payer_account" field was cleared in this mutation.
func (m *VoucherMutation) PayerAccountCleared() bool {
	_, ok := m.clearedFields[voucher.FieldPayerAccount]
	return ok
}

// ResetPayerAccount resets all changes to the "payer_account" field.
func (m *VoucherMutation) ResetPayerAccount() {
	m.payer_account = nil
	delete(m.clearedFields, voucher.FieldPayerAccount)
}

// SetPayerName sets the "payer_name" field.
func (m *VoucherMutation) SetPayerName(s string) {
	m.payer_name = &s
}

// PayerName returns the value of the "payer_name" field in the mutation.
func (m *VoucherMutation) PayerName() (r string, exists bool) {
	v := m.payer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPayerName returns the old "payer_name" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldPayerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayerName: %w", err)
	}
	return oldValue.PayerName, nil
}

// ClearPayerName clears the value of the "payer_name" field.
func (m *VoucherMutation) ClearPayerName() {
	m.payer_name = nil
	m.clearedFields[voucher.FieldPayerName] = struct{}{}
}

// PayerNameCleared returns if the "payer_name" field was cleared in this mutation.
func (m *VoucherMutation) PayerNameCleared() bool {
	_, ok := m.clearedFields[voucher.FieldPayerName]
	return ok
}

// ResetPayerName resets all changes to the "payer_name" field.
func (m *VoucherMutation) ResetPayerName() {
	m.payer_name = nil
	delete(m.clearedFields, voucher.FieldPayerName)
}

// SetTxID sets the "tx_id" field.
func (m *VoucherMutation) SetTxID(s string) {
	m.tx_id = &s
}

// TxID returns the value of the "tx_id" field in the mutation.
func (m *VoucherMutation) TxID() (r string, exists bool) {
	v := m.tx_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTxID returns the old "tx_id" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldTxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxID: %w", err)
	}
	return oldValue.TxID, nil
}

// ClearTxID clears the value of the "tx_id" field.
func (m *VoucherMutation) ClearTxID() {
	m.tx_id = nil
	m.clearedFields[voucher.FieldTxID] = struct{}{}
}

// TxIDCleared returns if the "tx_id" field was cleared in this mutation.
func (m *VoucherMutation) TxIDCleared() bool {
	_, ok := m.clearedFields[voucher.FieldTxID]
	return ok
}

// ResetTxID resets all changes to the "tx_id" field.
func (m *VoucherMutation) ResetTxID() {
	m.tx_id = nil
	delete(m.clearedFields, voucher.FieldTxID)
}

// SetImageURL sets the "image_url" field.
func (m *VoucherMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *VoucherMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *VoucherMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[voucher.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *VoucherMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[voucher.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *VoucherMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, voucher.FieldImageURL)
}

// SetCreatorNote sets the "creator_note" field.
func (m *VoucherMutation) SetCreatorNote(s string) {
	m.creator_note = &s
}

// CreatorNote returns the value of the "creator_note" field in the mutation.
func (m *VoucherMutation) CreatorNote() (r string, exists bool) {
	v := m.creator_note
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorNote returns the old "creator_note" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldCreatorNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatorNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatorNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorNote: %w", err)
	}
	return oldValue.CreatorNote, nil
}

// ClearCreatorNote clears the value of the "creator_note" field.
func (m *VoucherMutation) ClearCreatorNote() {
	m.creator_note = nil
	m.clearedFields[voucher.FieldCreatorNote] = struct{}{}
}

// CreatorNoteCleared returns if the "creator_note" field was cleared in this mutation.
func (m *VoucherMutation) CreatorNoteCleared() bool {
	_, ok := m.clearedFields[voucher.FieldCreatorNote]
	return ok
}

// ResetCreatorNote resets all changes to the "creator_note" field.
func (m *VoucherMutation) ResetCreatorNote() {
	m.creator_note = nil
	delete(m.clearedFields, voucher.FieldCreatorNote)
}

// SetHandledBy sets the "handled_by" field.
func (m *VoucherMutation) SetHandledBy(s string) {
	m.handled_by = &s
}

// HandledBy returns the value of the "handled_by" field in the mutation.
func (m *VoucherMutation) HandledBy() (r string, exists bool) {
	v := m.handled_by
	if v == nil {
		return
	}
	return *v, true
}

// OldHandledBy returns the old "handled_by" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldHandledBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHandledBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHandledBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandledBy: %w", err)
	}
	return oldValue.HandledBy, nil
}

// ClearHandledBy clears the value of the "handled_by" field.
func (m *VoucherMutation) ClearHandledBy() {
	m.handled_by = nil
	m.clearedFields[voucher.FieldHandledBy] = struct{}{}
}

// HandledByCleared returns if the "handled_by" field was cleared in this mutation.
func (m *VoucherMutation) HandledByCleared() bool {
	_, ok := m.clearedFields[voucher.FieldHandledBy]
	return ok
}

// ResetHandledBy resets all changes to the "handled_by" field.
func (m *VoucherMutation) ResetHandledBy() {
	m.handled_by = nil
	delete(m.clearedFields, voucher.FieldHandledBy)
}

// SetHandlerNote sets the "handler_note" field.
func (m *VoucherMutation) SetHandlerNote(s string) {
	m.handler_note = &s
}

// HandlerNote returns the value of the "handler_note" field in the mutation.
func (m *VoucherMutation) HandlerNote() (r string, exists bool) {
	v := m.handler_note
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlerNote returns the old "handler_note" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldHandlerNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHandlerNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHandlerNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlerNote: %w", err)
	}
	return oldValue.HandlerNote, nil
}

// ClearHandlerNote clears the value of the "handler_note" field.
func (m *VoucherMutation) ClearHandlerNote() {
	m.handler_note = nil
	m.clearedFields[voucher.FieldHandlerNote] = struct{}{}
}

// HandlerNoteCleared returns if the "handler_note" field was cleared in this mutation.
func (m *VoucherMutation) HandlerNoteCleared() bool {
	_, ok := m.clearedFields[voucher.FieldHandlerNote]
	return ok
}

// ResetHandlerNote resets all changes to the "handler_note" field.
func (m *VoucherMutation) ResetHandlerNote() {
	m.handler_note = nil
	delete(m.clearedFields, voucher.FieldHandlerNote)
}

// SetCreatedAt sets the "created_at" field.
func (m *VoucherMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VoucherMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VoucherMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VoucherMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VoucherMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VoucherMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *VoucherMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VoucherMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VoucherMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VoucherMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VoucherMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VoucherMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// Op returns the operation name.
func (m *VoucherMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Voucher).
func (m *VoucherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VoucherMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.merchant_id != nil {
		fields = append(fields, voucher.FieldMerchantID)
	}
	if m.payment_id != nil {
		fields = append(fields, voucher.FieldPaymentID)
	}
	if m.amount != nil {
		fields = append(fields, voucher.FieldAmount)
	}
	if m._type != nil {
		fields = append(fields, voucher.FieldType)
	}
	if m.status != nil {
		fields = append(fields, voucher.FieldStatus)
	}
	if m.payee_provider != nil {
		fields = append(fields, voucher.FieldPayeeProvider)
	}
	if m.payee_account != nil {
		fields = append(fields, voucher.FieldPayeeAccount)
	}
	if m.payee_name != nil {
		fields = append(fields, voucher.FieldPayeeName)
	}
	if m.payer_provider != nil {
		fields = append(fields, voucher.FieldPayerProvider)
	}
	if m.payer_account != nil {
		fields = append(fields, voucher.FieldPayerAccount)
	}
	if m.payer_name != nil {
		fields = append(fields, voucher.FieldPayerName)
	}
	if m.tx_id != nil {
		fields = append(fields, voucher.FieldTxID)
	}
	if m.image_url != nil {
		fields = append(fields, voucher.FieldImageURL)
	}
	if m.creator_note != nil {
		fields = append(fields, voucher.FieldCreatorNote)
	}
	if m.handled_by != nil {
		fields = append(fields, voucher.FieldHandledBy)
	}
	if m.handler_note != nil {
		fields = append(fields, voucher.FieldHandlerNote)
	}
	if m.created_at != nil {
		fields = append(fields, voucher.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, voucher.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, voucher.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, voucher.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VoucherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case voucher.FieldMerchantID:
		return m.MerchantID()
	case voucher.FieldPaymentID:
		return m.PaymentID()
	case voucher.FieldAmount:
		return m.Amount()
	case voucher.FieldType:
		return m.GetType()
	case voucher.FieldStatus:
		return m.Status()
	case voucher.FieldPayeeProvider:
		return m.PayeeProvider()
	case voucher.FieldPayeeAccount:
		return m.PayeeAccount()
	case voucher.FieldPayeeName:
		return m.PayeeName()
	case voucher.FieldPayerProvider:
		return m.PayerProvider()
	case voucher.FieldPayerAccount:
		return m.PayerAccount()
	case voucher.FieldPayerName:
		return m.PayerName()
	case voucher.FieldTxID:
		return m.TxID()
	case voucher.FieldImageURL:
		return m.ImageURL()
	case voucher.FieldCreatorNote:
		return m.CreatorNote()
	case voucher.FieldHandledBy:
		return m.HandledBy()
	case voucher.FieldHandlerNote:
		return m.HandlerNote()
	case voucher.FieldCreatedAt:
		return m.CreatedAt()
	case voucher.FieldUpdatedAt:
		return m.UpdatedAt()
	case voucher.FieldCreatedBy:
		return m.CreatedBy()
	case voucher.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VoucherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case voucher.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case voucher.FieldPaymentID:
		return m.OldPaymentID(ctx)
	case voucher.FieldAmount:
		return m.OldAmount(ctx)
	case voucher.FieldType:
		return m.OldType(ctx)
	case voucher.FieldStatus:
		return m.OldStatus(ctx)
	case voucher.FieldPayeeProvider:
		return m.OldPayeeProvider(ctx)
	case voucher.FieldPayeeAccount:
		return m.OldPayeeAccount(ctx)
	case voucher.FieldPayeeName:
		return m.OldPayeeName(ctx)
	case voucher.FieldPayerProvider:
		return m.OldPayerProvider(ctx)
	case voucher.FieldPayerAccount:
		return m.OldPayerAccount(ctx)
	case voucher.FieldPayerName:
		return m.OldPayerName(ctx)
	case voucher.FieldTxID:
		return m.OldTxID(ctx)
	case voucher.FieldImageURL:
		return m.OldImageURL(ctx)
	case voucher.FieldCreatorNote:
		return m.OldCreatorNote(ctx)
	case voucher.FieldHandledBy:
		return m.OldHandledBy(ctx)
	case voucher.FieldHandlerNote:
		return m.OldHandlerNote(ctx)
	case voucher.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case voucher.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case voucher.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case voucher.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Voucher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoucherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case voucher.FieldMerchantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case voucher.FieldPaymentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentID(v)
		return nil
	case voucher.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case voucher.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case voucher.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case voucher.FieldPayeeProvider:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayeeProvider(v)
		return nil
	case voucher.FieldPayeeAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayeeAccount(v)
		return nil
	case voucher.FieldPayeeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayeeName(v)
		return nil
	case voucher.FieldPayerProvider:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayerProvider(v)
		return nil
	case voucher.FieldPayerAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayerAccount(v)
		return nil
	case voucher.FieldPayerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayerName(v)
		return nil
	case voucher.FieldTxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxID(v)
		return nil
	case voucher.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case voucher.FieldCreatorNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorNote(v)
		return nil
	case voucher.FieldHandledBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandledBy(v)
		return nil
	case voucher.FieldHandlerNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlerNote(v)
		return nil
	case voucher.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case voucher.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case voucher.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case voucher.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Voucher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VoucherMutation) AddedFields() []string {
	var fields []string
	if m.addmerchant_id != nil {
		fields = append(fields, voucher.FieldMerchantID)
	}
	if m.addpayment_id != nil {
		fields = append(fields, voucher.FieldPaymentID)
	}
	if m.addamount != nil {
		fields = append(fields, voucher.FieldAmount)
	}
	if m.add_type != nil {
		fields = append(fields, voucher.FieldType)
	}
	if m.addstatus != nil {
		fields = append(fields, voucher.FieldStatus)
	}
	if m.addpayee_provider != nil {
		fields = append(fields, voucher.FieldPayeeProvider)
	}
	if m.addpayer_provider != nil {
		fields = append(fields, voucher.FieldPayerProvider)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VoucherMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case voucher.FieldMerchantID:
		return m.AddedMerchantID()
	case voucher.FieldPaymentID:
		return m.AddedPaymentID()
	case voucher.FieldAmount:
		return m.AddedAmount()
	case voucher.FieldType:
		return m.AddedType()
	case voucher.FieldStatus:
		return m.AddedStatus()
	case voucher.FieldPayeeProvider:
		return m.AddedPayeeProvider()
	case voucher.FieldPayerProvider:
		return m.AddedPayerProvider()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoucherMutation) AddField(name string, value ent.Value) error {
	switch name {
	case voucher.FieldMerchantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMerchantID(v)
		return nil
	case voucher.FieldPaymentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaymentID(v)
		return nil
	case voucher.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case voucher.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case voucher.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case voucher.FieldPayeeProvider:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayeeProvider(v)
		return nil
	case voucher.FieldPayerProvider:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayerProvider(v)
		return nil
	}
	return fmt.Errorf("unknown Voucher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VoucherMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(voucher.FieldPaymentID) {
		fields = append(fields, voucher.FieldPaymentID)
	}
	if m.FieldCleared(voucher.FieldStatus) {
		fields = append(fields, voucher.FieldStatus)
	}
	if m.FieldCleared(voucher.FieldPayeeProvider) {
		fields = append(fields, voucher.FieldPayeeProvider)
	}
	if m.FieldCleared(voucher.FieldPayeeAccount) {
		fields = append(fields, voucher.FieldPayeeAccount)
	}
	if m.FieldCleared(voucher.FieldPayeeName) {
		fields = append(fields, voucher.FieldPayeeName)
	}
	if m.FieldCleared(voucher.FieldPayerProvider) {
		fields = append(fields, voucher.FieldPayerProvider)
	}
	if m.FieldCleared(voucher.FieldPayerAccount) {
		fields = append(fields, voucher.FieldPayerAccount)
	}
	if m.FieldCleared(voucher.FieldPayerName) {
		fields = append(fields, voucher.FieldPayerName)
	}
	if m.FieldCleared(voucher.FieldTxID) {
		fields = append(fields, voucher.FieldTxID)
	}
	if m.FieldCleared(voucher.FieldImageURL) {
		fields = append(fields, voucher.FieldImageURL)
	}
	if m.FieldCleared(voucher.FieldCreatorNote) {
		fields = append(fields, voucher.FieldCreatorNote)
	}
	if m.FieldCleared(voucher.FieldHandledBy) {
		fields = append(fields, voucher.FieldHandledBy)
	}
	if m.FieldCleared(voucher.FieldHandlerNote) {
		fields = append(fields, voucher.FieldHandlerNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VoucherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VoucherMutation) ClearField(name string) error {
	switch name {
	case voucher.FieldPaymentID:
		m.ClearPaymentID()
		return nil
	case voucher.FieldStatus:
		m.ClearStatus()
		return nil
	case voucher.FieldPayeeProvider:
		m.ClearPayeeProvider()
		return nil
	case voucher.FieldPayeeAccount:
		m.ClearPayeeAccount()
		return nil
	case voucher.FieldPayeeName:
		m.ClearPayeeName()
		return nil
	case voucher.FieldPayerProvider:
		m.ClearPayerProvider()
		return nil
	case voucher.FieldPayerAccount:
		m.ClearPayerAccount()
		return nil
	case voucher.FieldPayerName:
		m.ClearPayerName()
		return nil
	case voucher.FieldTxID:
		m.ClearTxID()
		return nil
	case voucher.FieldImageURL:
		m.ClearImageURL()
		return nil
	case voucher.FieldCreatorNote:
		m.ClearCreatorNote()
		return nil
	case voucher.FieldHandledBy:
		m.ClearHandledBy()
		return nil
	case voucher.FieldHandlerNote:
		m.ClearHandlerNote()
		return nil
	}
	return fmt.Errorf("unknown Voucher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VoucherMutation) ResetField(name string) error {
	switch name {
	case voucher.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case voucher.FieldPaymentID:
		m.ResetPaymentID()
		return nil
	case voucher.FieldAmount:
		m.ResetAmount()
		return nil
	case voucher.FieldType:
		m.ResetType()
		return nil
	case voucher.FieldStatus:
		m.ResetStatus()
		return nil
	case voucher.FieldPayeeProvider:
		m.ResetPayeeProvider()
		return nil
	case voucher.FieldPayeeAccount:
		m.ResetPayeeAccount()
		return nil
	case voucher.FieldPayeeName:
		m.ResetPayeeName()
		return nil
	case voucher.FieldPayerProvider:
		m.ResetPayerProvider()
		return nil
	case voucher.FieldPayerAccount:
		m.ResetPayerAccount()
		return nil
	case voucher.FieldPayerName:
		m.ResetPayerName()
		return nil
	case voucher.FieldTxID:
		m.ResetTxID()
		return nil
	case voucher.FieldImageURL:
		m.ResetImageURL()
		return nil
	case voucher.FieldCreatorNote:
		m.ResetCreatorNote()
		return nil
	case voucher.FieldHandledBy:
		m.ResetHandledBy()
		return nil
	case voucher.FieldHandlerNote:
		m.ResetHandlerNote()
		return nil
	case voucher.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case voucher.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case voucher.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case voucher.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Voucher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VoucherMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VoucherMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VoucherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VoucherMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VoucherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VoucherMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VoucherMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Voucher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VoucherMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Voucher edge %s", name)
}
