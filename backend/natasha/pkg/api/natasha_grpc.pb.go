// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package natasha

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// NatashaClient is the client API for Natasha service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NatashaClient interface {
	CreateMerchant(ctx context.Context, in *CreateMerchantRequest, opts ...grpc.CallOption) (*CreateMerchantReply, error)
	UpdateMerchant(ctx context.Context, in *UpdateMerchantRequest, opts ...grpc.CallOption) (*UpdateMerchantReply, error)
	ListMerchants(ctx context.Context, in *ListMerchantsRequest, opts ...grpc.CallOption) (*ListMerchantsReply, error)
	GetMerchant(ctx context.Context, in *GetMerchantRequest, opts ...grpc.CallOption) (*GetMerchantReply, error)
}

type natashaClient struct {
	cc grpc.ClientConnInterface
}

func NewNatashaClient(cc grpc.ClientConnInterface) NatashaClient {
	return &natashaClient{cc}
}

func (c *natashaClient) CreateMerchant(ctx context.Context, in *CreateMerchantRequest, opts ...grpc.CallOption) (*CreateMerchantReply, error) {
	out := new(CreateMerchantReply)
	err := c.cc.Invoke(ctx, "/natasha.Natasha/CreateMerchant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natashaClient) UpdateMerchant(ctx context.Context, in *UpdateMerchantRequest, opts ...grpc.CallOption) (*UpdateMerchantReply, error) {
	out := new(UpdateMerchantReply)
	err := c.cc.Invoke(ctx, "/natasha.Natasha/UpdateMerchant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natashaClient) ListMerchants(ctx context.Context, in *ListMerchantsRequest, opts ...grpc.CallOption) (*ListMerchantsReply, error) {
	out := new(ListMerchantsReply)
	err := c.cc.Invoke(ctx, "/natasha.Natasha/ListMerchants", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *natashaClient) GetMerchant(ctx context.Context, in *GetMerchantRequest, opts ...grpc.CallOption) (*GetMerchantReply, error) {
	out := new(GetMerchantReply)
	err := c.cc.Invoke(ctx, "/natasha.Natasha/GetMerchant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NatashaServer is the server API for Natasha service.
// All implementations must embed UnimplementedNatashaServer
// for forward compatibility
type NatashaServer interface {
	CreateMerchant(context.Context, *CreateMerchantRequest) (*CreateMerchantReply, error)
	UpdateMerchant(context.Context, *UpdateMerchantRequest) (*UpdateMerchantReply, error)
	ListMerchants(context.Context, *ListMerchantsRequest) (*ListMerchantsReply, error)
	GetMerchant(context.Context, *GetMerchantRequest) (*GetMerchantReply, error)
	mustEmbedUnimplementedNatashaServer()
}

// UnimplementedNatashaServer must be embedded to have forward compatible implementations.
type UnimplementedNatashaServer struct {
}

func (*UnimplementedNatashaServer) CreateMerchant(context.Context, *CreateMerchantRequest) (*CreateMerchantReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMerchant not implemented")
}
func (*UnimplementedNatashaServer) UpdateMerchant(context.Context, *UpdateMerchantRequest) (*UpdateMerchantReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMerchant not implemented")
}
func (*UnimplementedNatashaServer) ListMerchants(context.Context, *ListMerchantsRequest) (*ListMerchantsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMerchants not implemented")
}
func (*UnimplementedNatashaServer) GetMerchant(context.Context, *GetMerchantRequest) (*GetMerchantReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMerchant not implemented")
}
func (*UnimplementedNatashaServer) mustEmbedUnimplementedNatashaServer() {}

func RegisterNatashaServer(s *grpc.Server, srv NatashaServer) {
	s.RegisterService(&_Natasha_serviceDesc, srv)
}

func _Natasha_CreateMerchant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMerchantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatashaServer).CreateMerchant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/natasha.Natasha/CreateMerchant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatashaServer).CreateMerchant(ctx, req.(*CreateMerchantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Natasha_UpdateMerchant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMerchantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatashaServer).UpdateMerchant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/natasha.Natasha/UpdateMerchant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatashaServer).UpdateMerchant(ctx, req.(*UpdateMerchantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Natasha_ListMerchants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMerchantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatashaServer).ListMerchants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/natasha.Natasha/ListMerchants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatashaServer).ListMerchants(ctx, req.(*ListMerchantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Natasha_GetMerchant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMerchantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NatashaServer).GetMerchant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/natasha.Natasha/GetMerchant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NatashaServer).GetMerchant(ctx, req.(*GetMerchantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Natasha_serviceDesc = grpc.ServiceDesc{
	ServiceName: "natasha.Natasha",
	HandlerType: (*NatashaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMerchant",
			Handler:    _Natasha_CreateMerchant_Handler,
		},
		{
			MethodName: "UpdateMerchant",
			Handler:    _Natasha_UpdateMerchant_Handler,
		},
		{
			MethodName: "ListMerchants",
			Handler:    _Natasha_ListMerchants_Handler,
		},
		{
			MethodName: "GetMerchant",
			Handler:    _Natasha_GetMerchant_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "natasha/api/natasha.proto",
}

// BlackWidowClient is the client API for BlackWidow service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BlackWidowClient interface {
	MakePayment(ctx context.Context, in *MakePaymentRequest, opts ...grpc.CallOption) (*MakePaymentReply, error)
	GetMerchantBalance(ctx context.Context, in *GetMerchantBalanceRequest, opts ...grpc.CallOption) (*GetMerchantBalanceReply, error)
	ListPayments(ctx context.Context, in *ListPaymentsRequest, opts ...grpc.CallOption) (*ListPaymentsReply, error)
	NotifyRejectPayment(ctx context.Context, in *NotifyRejectPaymentRequest, opts ...grpc.CallOption) (*NotifyRejectPaymentReply, error)
}

type blackWidowClient struct {
	cc grpc.ClientConnInterface
}

func NewBlackWidowClient(cc grpc.ClientConnInterface) BlackWidowClient {
	return &blackWidowClient{cc}
}

func (c *blackWidowClient) MakePayment(ctx context.Context, in *MakePaymentRequest, opts ...grpc.CallOption) (*MakePaymentReply, error) {
	out := new(MakePaymentReply)
	err := c.cc.Invoke(ctx, "/natasha.BlackWidow/MakePayment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blackWidowClient) GetMerchantBalance(ctx context.Context, in *GetMerchantBalanceRequest, opts ...grpc.CallOption) (*GetMerchantBalanceReply, error) {
	out := new(GetMerchantBalanceReply)
	err := c.cc.Invoke(ctx, "/natasha.BlackWidow/GetMerchantBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blackWidowClient) ListPayments(ctx context.Context, in *ListPaymentsRequest, opts ...grpc.CallOption) (*ListPaymentsReply, error) {
	out := new(ListPaymentsReply)
	err := c.cc.Invoke(ctx, "/natasha.BlackWidow/ListPayments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blackWidowClient) NotifyRejectPayment(ctx context.Context, in *NotifyRejectPaymentRequest, opts ...grpc.CallOption) (*NotifyRejectPaymentReply, error) {
	out := new(NotifyRejectPaymentReply)
	err := c.cc.Invoke(ctx, "/natasha.BlackWidow/NotifyRejectPayment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BlackWidowServer is the server API for BlackWidow service.
// All implementations must embed UnimplementedBlackWidowServer
// for forward compatibility
type BlackWidowServer interface {
	MakePayment(context.Context, *MakePaymentRequest) (*MakePaymentReply, error)
	GetMerchantBalance(context.Context, *GetMerchantBalanceRequest) (*GetMerchantBalanceReply, error)
	ListPayments(context.Context, *ListPaymentsRequest) (*ListPaymentsReply, error)
	NotifyRejectPayment(context.Context, *NotifyRejectPaymentRequest) (*NotifyRejectPaymentReply, error)
	mustEmbedUnimplementedBlackWidowServer()
}

// UnimplementedBlackWidowServer must be embedded to have forward compatible implementations.
type UnimplementedBlackWidowServer struct {
}

func (*UnimplementedBlackWidowServer) MakePayment(context.Context, *MakePaymentRequest) (*MakePaymentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakePayment not implemented")
}
func (*UnimplementedBlackWidowServer) GetMerchantBalance(context.Context, *GetMerchantBalanceRequest) (*GetMerchantBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMerchantBalance not implemented")
}
func (*UnimplementedBlackWidowServer) ListPayments(context.Context, *ListPaymentsRequest) (*ListPaymentsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPayments not implemented")
}
func (*UnimplementedBlackWidowServer) NotifyRejectPayment(context.Context, *NotifyRejectPaymentRequest) (*NotifyRejectPaymentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyRejectPayment not implemented")
}
func (*UnimplementedBlackWidowServer) mustEmbedUnimplementedBlackWidowServer() {}

func RegisterBlackWidowServer(s *grpc.Server, srv BlackWidowServer) {
	s.RegisterService(&_BlackWidow_serviceDesc, srv)
}

func _BlackWidow_MakePayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MakePaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlackWidowServer).MakePayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/natasha.BlackWidow/MakePayment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlackWidowServer).MakePayment(ctx, req.(*MakePaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlackWidow_GetMerchantBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMerchantBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlackWidowServer).GetMerchantBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/natasha.BlackWidow/GetMerchantBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlackWidowServer).GetMerchantBalance(ctx, req.(*GetMerchantBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlackWidow_ListPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPaymentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlackWidowServer).ListPayments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/natasha.BlackWidow/ListPayments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlackWidowServer).ListPayments(ctx, req.(*ListPaymentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlackWidow_NotifyRejectPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyRejectPaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlackWidowServer).NotifyRejectPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/natasha.BlackWidow/NotifyRejectPayment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlackWidowServer).NotifyRejectPayment(ctx, req.(*NotifyRejectPaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BlackWidow_serviceDesc = grpc.ServiceDesc{
	ServiceName: "natasha.BlackWidow",
	HandlerType: (*BlackWidowServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MakePayment",
			Handler:    _BlackWidow_MakePayment_Handler,
		},
		{
			MethodName: "GetMerchantBalance",
			Handler:    _BlackWidow_GetMerchantBalance_Handler,
		},
		{
			MethodName: "ListPayments",
			Handler:    _BlackWidow_ListPayments_Handler,
		},
		{
			MethodName: "NotifyRejectPayment",
			Handler:    _BlackWidow_NotifyRejectPayment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "natasha/api/natasha.proto",
}

// RomanoffClient is the client API for Romanoff service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RomanoffClient interface {
	ListVouchers(ctx context.Context, in *ListVouchersRequest, opts ...grpc.CallOption) (*ListVouchersReply, error)
	GetVoucher(ctx context.Context, in *GetVoucherRequest, opts ...grpc.CallOption) (*GetVoucherReply, error)
	CreateVoucher(ctx context.Context, in *CreateVoucherRequest, opts ...grpc.CallOption) (*CreateVoucherReply, error)
	SubmitVoucher(ctx context.Context, in *SubmitVoucherRequest, opts ...grpc.CallOption) (*SubmitVoucherReply, error)
	CancelVoucher(ctx context.Context, in *CancelVoucherRequest, opts ...grpc.CallOption) (*CancelVoucherReply, error)
}

type romanoffClient struct {
	cc grpc.ClientConnInterface
}

func NewRomanoffClient(cc grpc.ClientConnInterface) RomanoffClient {
	return &romanoffClient{cc}
}

func (c *romanoffClient) ListVouchers(ctx context.Context, in *ListVouchersRequest, opts ...grpc.CallOption) (*ListVouchersReply, error) {
	out := new(ListVouchersReply)
	err := c.cc.Invoke(ctx, "/natasha.Romanoff/ListVouchers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *romanoffClient) GetVoucher(ctx context.Context, in *GetVoucherRequest, opts ...grpc.CallOption) (*GetVoucherReply, error) {
	out := new(GetVoucherReply)
	err := c.cc.Invoke(ctx, "/natasha.Romanoff/GetVoucher", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *romanoffClient) CreateVoucher(ctx context.Context, in *CreateVoucherRequest, opts ...grpc.CallOption) (*CreateVoucherReply, error) {
	out := new(CreateVoucherReply)
	err := c.cc.Invoke(ctx, "/natasha.Romanoff/CreateVoucher", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *romanoffClient) SubmitVoucher(ctx context.Context, in *SubmitVoucherRequest, opts ...grpc.CallOption) (*SubmitVoucherReply, error) {
	out := new(SubmitVoucherReply)
	err := c.cc.Invoke(ctx, "/natasha.Romanoff/SubmitVoucher", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *romanoffClient) CancelVoucher(ctx context.Context, in *CancelVoucherRequest, opts ...grpc.CallOption) (*CancelVoucherReply, error) {
	out := new(CancelVoucherReply)
	err := c.cc.Invoke(ctx, "/natasha.Romanoff/CancelVoucher", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RomanoffServer is the server API for Romanoff service.
// All implementations must embed UnimplementedRomanoffServer
// for forward compatibility
type RomanoffServer interface {
	ListVouchers(context.Context, *ListVouchersRequest) (*ListVouchersReply, error)
	GetVoucher(context.Context, *GetVoucherRequest) (*GetVoucherReply, error)
	CreateVoucher(context.Context, *CreateVoucherRequest) (*CreateVoucherReply, error)
	SubmitVoucher(context.Context, *SubmitVoucherRequest) (*SubmitVoucherReply, error)
	CancelVoucher(context.Context, *CancelVoucherRequest) (*CancelVoucherReply, error)
	mustEmbedUnimplementedRomanoffServer()
}

// UnimplementedRomanoffServer must be embedded to have forward compatible implementations.
type UnimplementedRomanoffServer struct {
}

func (*UnimplementedRomanoffServer) ListVouchers(context.Context, *ListVouchersRequest) (*ListVouchersReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVouchers not implemented")
}
func (*UnimplementedRomanoffServer) GetVoucher(context.Context, *GetVoucherRequest) (*GetVoucherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVoucher not implemented")
}
func (*UnimplementedRomanoffServer) CreateVoucher(context.Context, *CreateVoucherRequest) (*CreateVoucherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVoucher not implemented")
}
func (*UnimplementedRomanoffServer) SubmitVoucher(context.Context, *SubmitVoucherRequest) (*SubmitVoucherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitVoucher not implemented")
}
func (*UnimplementedRomanoffServer) CancelVoucher(context.Context, *CancelVoucherRequest) (*CancelVoucherReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelVoucher not implemented")
}
func (*UnimplementedRomanoffServer) mustEmbedUnimplementedRomanoffServer() {}

func RegisterRomanoffServer(s *grpc.Server, srv RomanoffServer) {
	s.RegisterService(&_Romanoff_serviceDesc, srv)
}

func _Romanoff_ListVouchers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVouchersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RomanoffServer).ListVouchers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/natasha.Romanoff/ListVouchers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RomanoffServer).ListVouchers(ctx, req.(*ListVouchersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Romanoff_GetVoucher_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVoucherRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RomanoffServer).GetVoucher(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/natasha.Romanoff/GetVoucher",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RomanoffServer).GetVoucher(ctx, req.(*GetVoucherRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Romanoff_CreateVoucher_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVoucherRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RomanoffServer).CreateVoucher(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/natasha.Romanoff/CreateVoucher",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RomanoffServer).CreateVoucher(ctx, req.(*CreateVoucherRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Romanoff_SubmitVoucher_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitVoucherRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RomanoffServer).SubmitVoucher(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/natasha.Romanoff/SubmitVoucher",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RomanoffServer).SubmitVoucher(ctx, req.(*SubmitVoucherRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Romanoff_CancelVoucher_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelVoucherRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RomanoffServer).CancelVoucher(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/natasha.Romanoff/CancelVoucher",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RomanoffServer).CancelVoucher(ctx, req.(*CancelVoucherRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Romanoff_serviceDesc = grpc.ServiceDesc{
	ServiceName: "natasha.Romanoff",
	HandlerType: (*RomanoffServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListVouchers",
			Handler:    _Romanoff_ListVouchers_Handler,
		},
		{
			MethodName: "GetVoucher",
			Handler:    _Romanoff_GetVoucher_Handler,
		},
		{
			MethodName: "CreateVoucher",
			Handler:    _Romanoff_CreateVoucher_Handler,
		},
		{
			MethodName: "SubmitVoucher",
			Handler:    _Romanoff_SubmitVoucher_Handler,
		},
		{
			MethodName: "CancelVoucher",
			Handler:    _Romanoff_CancelVoucher_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "natasha/api/natasha.proto",
}
